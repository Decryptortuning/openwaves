#include "esp_phy_lib.elf.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BT_tx_LE_en(u32 enable)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51000 = _DAT_3ff51000 & 0xffffffc3 | 0x50;
  memw();
  memw();
  _DAT_3ff51004 = _DAT_3ff51004 | 0x800000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int hoppe_tx_tone(uint16 freq,uint16 delay_num,S16 reg_freq_1,U8 tone1_atten,int bt,int *alltime)

{
  uint32_t stime;
  
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  if (bt != 0) {
    memw();
    _DAT_60002000 = 0xd;
    memw();
    _DAT_60002004 = 1;
    memw();
    _DAT_60002010 = 0x4500;
  }
  do {
    memw();
  } while (-1 < _DAT_60002010);
  memw();
  _DAT_60002010 = 0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff46090 = _DAT_3ff46090 & 0xffffe1ff | 0xe00;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_tx_8m_disable(void)

{
  memw();
  memw();
  _DAT_3ff51040 = _DAT_3ff51040 & 0xfffffffe;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_fill_tx_buffer_1m_1010(void)

{
  U32 packet_1m [12];
  
  memcpy(packet_1m,&DAT_000525d8,0x30);
  memw();
  _DAT_60012000 = packet_1m[0];
  memw();
  _DAT_3ff51004 = 0x8200;
  memw();
  _DAT_3ff51010 = 0x170;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_fill_tx_buffer_1m_0011(void)

{
  uint32 packet_1m [12];
  
  memcpy(packet_1m,&DAT_00052608,0x30);
  memw();
  _DAT_60012000 = packet_1m[0];
  memw();
  _DAT_3ff51004 = 0x200;
  memw();
  _DAT_3ff51010 = 0x174;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_fill_tx_buffer_1m_prbs9(void)

{
  uint32 packet_1m [12];
  
  memcpy(packet_1m,&DAT_00052638,0x30);
  memw();
  _DAT_60012000 = packet_1m[0];
  memw();
  _DAT_3ff51004 = 0x200;
  memw();
  _DAT_3ff51010 = 0x174;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_fill_tx_buffer_2m_1010(void)

{
  U32 packet_2m [15];
  U32 packet_1m [5];
  
  memcpy(packet_1m,&DAT_00052668,0x14);
  memw();
  _DAT_60012000 = packet_1m[0];
  memw();
  _DAT_60012004 = packet_1m[1];
  memw();
  _DAT_60012008 = packet_1m[2];
  memw();
  _DAT_6001200c = packet_1m[3];
  memw();
  _DAT_60012010 = packet_1m[4];
  memw();
  _DAT_3ff51004 = 0x8200;
  memw();
  _DAT_3ff51010 = 0x80;
  memcpy(packet_2m,&DAT_0005267c,0x3c);
  memw();
  URam60012014 = packet_2m[0];
  memw();
  _DAT_3ff51008 = 0x400985;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_fill_tx_buffer_2m_prbs9(void)

{
  U32 packet_2m [15];
  U32 packet_1m [5];
  
  memcpy(packet_1m,&DAT_000526b8,0x14);
  memw();
  _DAT_60012000 = packet_1m[0];
  memw();
  _DAT_60012004 = packet_1m[1];
  memw();
  _DAT_60012008 = packet_1m[2];
  memw();
  _DAT_6001200c = packet_1m[3];
  memw();
  _DAT_60012010 = packet_1m[4];
  memw();
  _DAT_3ff51004 = 0x200;
  memw();
  _DAT_3ff51010 = 0x84;
  memcpy(packet_2m,&DAT_000526cc,0x3c);
  memw();
  URam60012014 = packet_2m[0];
  memw();
  _DAT_3ff51008 = 0x985;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_fill_tx_buffer_3m_1010(void)

{
  U32 packet_3m [22];
  U32 packet_1m [5];
  
  memcpy(packet_1m,&DAT_00052708,0x14);
  memw();
  _DAT_60012000 = packet_1m[0];
  memw();
  _DAT_60012004 = packet_1m[1];
  memw();
  _DAT_60012008 = packet_1m[2];
  memw();
  _DAT_6001200c = packet_1m[3];
  memw();
  _DAT_60012010 = packet_1m[4];
  memw();
  _DAT_3ff51004 = 0x8200;
  memw();
  _DAT_3ff51010 = 0x80;
  memcpy(packet_3m,&DAT_0005271c,0x58);
  memw();
  URam60012014 = packet_3m[0];
  memw();
  _DAT_3ff51008 = 0x468005;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_fill_tx_buffer_3m_prbs9(void)

{
  U32 packet_3m [23];
  U32 packet_1m [5];
  
  memcpy(packet_1m,&DAT_00052774,0x14);
  memw();
  _DAT_60012000 = packet_1m[0];
  memw();
  _DAT_60012004 = packet_1m[1];
  memw();
  _DAT_60012008 = packet_1m[2];
  memw();
  _DAT_6001200c = packet_1m[3];
  memw();
  _DAT_60012010 = packet_1m[4];
  memw();
  _DAT_3ff51004 = 0x200;
  memw();
  _DAT_3ff51010 = 0x84;
  memcpy(packet_3m,&DAT_00052788,0x5c);
  memw();
  URam60012014 = packet_3m[0];
  memw();
  _DAT_3ff51008 = 0x6c005;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_start_tx_1m(uint freq_point)

{
  memw();
  memw();
  _DAT_3ff51004 = _DAT_3ff51004 | 0x4000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_start_tx_1m_new(void)

{
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
  memw();
  memw();
  _DAT_3ff51004 = _DAT_3ff51004 | 0x4000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_start_tx_2m_3m(uint freq_point)

{
  memw();
  _DAT_3ff51014 = 0xf0141;
  memw();
  memw();
  _DAT_3ff51004 = _DAT_3ff51004 | 0x4000;
  memw();
  memw();
  _DAT_3ff51008 = _DAT_3ff51008 | 0x200000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_start_tx_2m_3m_new(void)

{
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
  memw();
  _DAT_3ff51014 = 0x18021;
  memw();
  memw();
  _DAT_3ff51004 = _DAT_3ff51004 | 0x4000;
  memw();
  memw();
  _DAT_3ff51008 = _DAT_3ff51008 | 0x200000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_wait4tx_end(uint data_rate)

{
  do {
    memw();
  } while (-1 < (int)_DAT_3ff51004);
  if (1 < data_rate) {
    do {
      memw();
    } while (-1 < (int)_DAT_3ff51008);
  }
  memw();
  memw();
  _DAT_3ff51004 = _DAT_3ff51004 & 0xffffbfff;
  memw();
  memw();
  _DAT_3ff51008 = _DAT_3ff51008 & 0xffdfffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_wait4tx_end_new(void)

{
  do {
    memw();
  } while ((_DAT_3ff51030 & 0x40) == 0);
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
  memw();
  memw();
  _DAT_3ff51004 = _DAT_3ff51004 & 0xffffbfff;
  memw();
  memw();
  _DAT_3ff51008 = _DAT_3ff51008 & 0xffdfffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_start_tx(uint32 data_rate,uint freq_point)

{
  if (data_rate == 1) {
    memw();
    memw();
    _DAT_3ff51004 = _DAT_3ff51004 | 0x4000;
    return;
  }
  if (1 < data_rate) {
    memw();
    _DAT_3ff51014 = 0xf0141;
    memw();
    _DAT_3ff51004 = _DAT_3ff51004 | 0x4000;
    memw();
    memw();
    _DAT_3ff51008 = _DAT_3ff51008 | 0x200000;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_start_tx_8m(uint32 data_rate)

{
  if (data_rate == 1) {
    memw();
    memw();
    _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
    memw();
    memw();
    _DAT_3ff51004 = _DAT_3ff51004 | 0x4000;
    return;
  }
  if (1 < data_rate) {
    memw();
    _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
    memw();
    memw();
    _DAT_3ff51014 = 0x18021;
    memw();
    _DAT_3ff51004 = _DAT_3ff51004 | 0x4000;
    memw();
    memw();
    _DAT_3ff51008 = _DAT_3ff51008 | 0x200000;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_set_tx_on_guard_time(void)

{
  memw();
  _DAT_3ff5100c = 0x14a3203c;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_set_tx_on_guard_time_new(void)

{
  memw();
  _DAT_3ff5100c = 0x14a321e0;
  memw();
  memw();
  _DAT_3ff51044 = _DAT_3ff51044 & 0xffffff00 | 0x50;
  return;
}



// WARNING: Unknown calling convention

void BT_fill_tx_buffer(uint32 data_rate,uint32 data_type)

{
  if (data_rate == 1) {
    if (data_type == 0) {
      BT_fill_tx_buffer_1m_1010();
      return;
    }
    if (data_type == 1) {
      BT_fill_tx_buffer_1m_0011();
      return;
    }
    if (data_type == 2) {
      BT_fill_tx_buffer_1m_prbs9();
      return;
    }
  }
  else if (data_rate == 2) {
    if (data_type == 0) {
      BT_fill_tx_buffer_2m_1010();
      return;
    }
    if (data_type == 1) {
      BT_fill_tx_buffer_2m_prbs9();
      return;
    }
  }
  else if (data_rate == 3) {
    if (data_type == 0) {
      BT_fill_tx_buffer_3m_1010();
      return;
    }
    if (data_type == 1) {
      BT_fill_tx_buffer_3m_prbs9();
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_tx_forever(uint16 tx_freq_offset_500k)

{
  memw();
  _DAT_60002018 = 0x32005014;
  memw();
  _DAT_60002000 = 0x19;
  memw();
  _DAT_60002004 = (uint)tx_freq_offset_500k << 1 | 1;
  memw();
  _DAT_6000200c = 1;
  memw();
  _DAT_6000201c = 10;
  memw();
  _DAT_60002010 = 0x4080;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_start_tx_packet(uint16 tx_freq_offset_500k,uint32 data_rate,uint32 delay)

{
  memw();
  memw();
  memw();
  _DAT_3ff46090 = _DAT_3ff46090 & 0xfffff9ff | 0x1a00;
  memw();
  memw();
  BT_start_tx(data_rate,(uint)tx_freq_offset_500k);
  do {
    memw();
  } while (-1 < (int)_DAT_3ff51004);
  if (data_rate < 2) {
    memw();
    memw();
    memw();
    memw();
    if (data_rate == 1) {
      _DAT_3ff51004 = _DAT_3ff51004 & 0xffffbfff;
      _DAT_3ff51008 = _DAT_3ff51008 & 0xffdfffff;
      ets_delay_us(2);
      goto LAB_00010a16;
    }
  }
  else {
    do {
      memw();
    } while (-1 < (int)_DAT_3ff51008);
    memw();
    memw();
    memw();
    memw();
    if (data_rate == 2) {
      _DAT_3ff51004 = _DAT_3ff51004 & 0xffffbfff;
      _DAT_3ff51008 = _DAT_3ff51008 & 0xffdfffff;
      ets_delay_us(0x24);
      goto LAB_00010a16;
    }
  }
  _DAT_3ff51008 = _DAT_3ff51008 & 0xffdfffff;
  _DAT_3ff51004 = _DAT_3ff51004 & 0xffffbfff;
  if (data_rate == 3) {
    ets_delay_us(0x19);
  }
LAB_00010a16:
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff46090 = _DAT_3ff46090 & 0xffffe7ff | 0xe00;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_start_tx_packet_8m(uint16 tx_freq_offset_500k,uint32 data_rate,uint32 delay)

{
  memw();
  memw();
  memw();
  _DAT_3ff46090 = _DAT_3ff46090 & 0xfffff9ff | 0x1a00;
  memw();
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
  memw();
  BT_tx_8m_enable((uint)tx_freq_offset_500k);
  BT_start_tx_8m(data_rate);
  do {
    memw();
  } while ((_DAT_3ff51030 & 0x40) == 0);
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
  memw();
  memw();
  _DAT_3ff51004 = _DAT_3ff51004 & 0xffffbfff;
  memw();
  memw();
  _DAT_3ff51008 = _DAT_3ff51008 & 0xffdfffff;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff46090 = _DAT_3ff46090 & 0xffffe7ff | 0xe00;
  memw();
  memw();
  _DAT_3ff51040 = _DAT_3ff51040 & 0xfffffffe;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_tx_packet(uint16 freq_odd,uint16 freq_even,uint16 tx_freq_offset_500k,uint32 slot_time,
                 uint32 delay,uint32 data_rate,uint32 data_type,uint32 tx_slot,uint32 tx_off_delay)

{
  uint uVar1;
  STATUS SVar2;
  uint uVar3;
  uint uVar4;
  
  uVar1 = _DAT_60033c00;
  memw();
  memw();
  _DAT_3ff5100c = 0x14a3203c;
  uVar3 = _DAT_60033c00 + slot_time * 2;
  BT_fill_tx_buffer(data_rate,data_type);
  do {
    uVar4 = uVar3 + delay;
    while (uVar1 < uVar3) {
      memw();
      uVar1 = _DAT_60033c00;
    }
    uVar3 = slot_time * 2 + uVar1;
    while (uVar1 < uVar4) {
      memw();
      uVar1 = _DAT_60033c00;
    }
    BT_start_tx_packet(tx_freq_offset_500k,data_rate,tx_off_delay);
    while (uVar1 < uVar3 - slot_time) {
      memw();
      uVar1 = _DAT_60033c00;
    }
    while (uVar1 < delay + (uVar3 - slot_time)) {
      memw();
      uVar1 = _DAT_60033c00;
    }
    if (1 < tx_slot) {
      BT_start_tx_packet(tx_freq_offset_500k,data_rate,tx_off_delay);
    }
    SVar2 = GetStopCmd();
  } while (SVar2 != OK);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_tx_packet_8m(uint16 freq_odd,uint16 freq_even,uint16 tx_freq_offset_500k,uint32 slot_time,
                    uint32 delay,uint32 data_rate,uint32 data_type,uint32 tx_slot,
                    uint32 tx_off_delay)

{
  uint uVar1;
  STATUS SVar2;
  uint uVar3;
  uint uVar4;
  
  uVar1 = _DAT_60033c00;
  memw();
  memw();
  _DAT_3ff5100c = 0x14a321e0;
  memw();
  _DAT_3ff51044 = _DAT_3ff51044 & 0xffffff00 | 0x50;
  memw();
  uVar3 = _DAT_60033c00 + slot_time * 2;
  BT_fill_tx_buffer(data_rate,data_type);
  do {
    uVar4 = uVar3 + delay;
    while (uVar1 < uVar3) {
      memw();
      uVar1 = _DAT_60033c00;
    }
    uVar3 = slot_time * 2 + uVar1;
    while (uVar1 < uVar4) {
      memw();
      uVar1 = _DAT_60033c00;
    }
    BT_start_tx_packet_8m(tx_freq_offset_500k,data_rate,tx_off_delay);
    while (uVar1 < uVar3 - slot_time) {
      memw();
      uVar1 = _DAT_60033c00;
    }
    while (uVar1 < delay + (uVar3 - slot_time)) {
      memw();
      uVar1 = _DAT_60033c00;
    }
    if (1 < tx_slot) {
      BT_start_tx_packet_8m(tx_freq_offset_500k,data_rate,tx_off_delay);
    }
    SVar2 = GetStopCmd();
  } while (SVar2 != OK);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_mac_iqview_debug(u32 nowhite)

{
  memw();
  _DAT_600321b8 = 0xfffffffc;
  memw();
  memw();
  memw();
  _DAT_60032124 = _DAT_60032124 & 0xfffffeff;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600321b0 = 0x6bc6967e;
  memw();
  memw();
  _DAT_600320a8 = _DAT_600320a8 & 0xff000000 | 0xc6967e;
  memw();
  memw();
  _DAT_600321bc = _DAT_600321bc | 0x30000000;
  if (nowhite == 1) {
    memw();
    memw();
    memw();
    _DAT_60032124 = _DAT_60032124 | 3;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_rx_start(uint16 data_rate,uint16 freq_offset_500k,uint16 start,uint16 bit_len,uint16 freq)

{
  ets_delay_us(0xd2);
  memw();
  _DAT_3ff5101c = 0x80000000;
  memw();
  _DAT_60012000 = 0;
  BT_mac_iqview_debug(1);
  BT_init_rx_filters(freq_offset_500k);
  memw();
  memw();
  memw();
  _DAT_3ff51018 = (bit_len & 0x3fff) << 0xf | _DAT_3ff51018 & 0x60007fff;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 0x33;
  memw();
  if (start == 1) {
    memw();
    _DAT_3ff51018 = _DAT_3ff51018 | 0x80000000;
    memw();
  }
  memw();
  _DAT_3ff5101c = 0;
  phy_printf("BT_rx_end!\n");
  do {
    memw();
  } while ((_DAT_3ff51030 & 2) == 0);
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 2;
  memw();
  memw();
  _DAT_3ff51018 = _DAT_3ff51018 & 0x7fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_bb_tx_end_int_init(void)

{
  memw();
  _DAT_3ff5102c = _DAT_3ff5102c | 0x40;
  memw();
  phy_bt_pll_track(true);
  phy_bt_power_track(true);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_bb_tx_end_service(void)

{
  memw();
  if ((_DAT_3ff51034 & 0x40) != 0) {
    memw();
    _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
    memw();
    bt_track_pll_cap();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_bb_rx_start_int_init(void)

{
  memw();
  _DAT_3ff5102c = _DAT_3ff5102c | 0x41;
  memw();
  phy_bt_pll_track(true);
  phy_bt_power_track(true);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_bb_rx_start_service(void)

{
  memw();
  if ((_DAT_3ff51034 & 0x41) != 0) {
    memw();
    _DAT_3ff51038 = _DAT_3ff51038 | 0x41;
    memw();
    bt_track_pll_cap();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_rw_start_int_init(void)

{
  memw();
  _DAT_3ff510f8 = _DAT_3ff510f8 | 9;
  memw();
  phy_bt_pll_track(true);
  phy_bt_power_track(true);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_rw_start_service(void)

{
  memw();
  if ((_DAT_3ff51100 & 9) != 0) {
    memw();
    _DAT_3ff51104 = _DAT_3ff51104 | 9;
    memw();
    bt_track_pll_cap();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_tx_LE_en(u32 enable)

{
  u32 unaff_a10;
  
  if (enable == 1) {
    BT_tx_LE_en(unaff_a10);
    return;
  }
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51000 = _DAT_3ff51000 & 0xffffff83;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LE_fill_tx_access_addr(u32 ac)

{
  memw();
  if ((ac & 1) == 0) {
    memw();
    _DAT_60012000 = 0xaa;
  }
  else {
    memw();
    _DAT_60012000 = 0x55;
  }
  memw();
  memw();
  _DAT_60012000 = _DAT_60012000 | 0xac00;
  memw();
  memw();
  _DAT_60012004 = _DAT_60012004 & 0xffffff00;
  return;
}



// WARNING: Unknown calling convention

void LE_fill_tx_PDU_byte(u32 nbyte,u32 data)

{
  uint uVar1;
  uint *puVar2;
  
  uVar1 = nbyte + 5 & 3;
  puVar2 = (uint *)(((nbyte + 5 >> 2) + 0x18004800) * 4);
  memw();
  memw();
  *puVar2 = (0xff << 0x20 - (uVar1 * -8 + 0x20) ^ 0xffffffffU) & *puVar2 |
            (data & 0xff) << 0x20 - (uVar1 * -8 + 0x20);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LE_fill_tx_header_adv(u32 type,u32 length)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_60012004 =
       (((type << 0xc | length << 2) & 0xff00) >> 8) << 0x10 |
       (length << 2 & 0xff) << 8 | _DAT_60012004 & 0xff0000ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LE_fill_tx_header_data(u32 length)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_60012004 =
       ((length << 3 & 0xff00) >> 8) << 0x10 |
       (length << 3 & 0xff) << 8 | _DAT_60012004 & 0xff0000ff;
  return;
}



// WARNING: Unknown calling convention

void LE_fill_tx_payload_byte(u32 nbyte,u32 data)

{
  uint uVar1;
  uint *puVar2;
  
  uVar1 = nbyte + 7 & 3;
  puVar2 = (uint *)(((nbyte + 7 >> 2) + 0x18004800) * 4);
  memw();
  memw();
  *puVar2 = (0xff << 0x20 - (uVar1 * -8 + 0x20) ^ 0xffffffffU) & *puVar2 |
            (data & 0xff) << 0x20 - (uVar1 * -8 + 0x20);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void LE_fill_tx_buffer_1010(void)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_60012000 = 0xacaa;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_60012004 = 0xaa005000;
  memw();
  memw();
  _DAT_3ff5101c = _DAT_3ff5101c & 0x7fffffff;
  memw();
  memw();
  _DAT_3ff51004 = _DAT_3ff51004 & 0xff800000 | 0x8200;
  memw();
  _DAT_3ff51010 = 0xd8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LE_start_tx(u32 channel,u32 data_type,u32 loop)

{
  u32 enable;
  STATUS SVar1;
  uint8 in_a12;
  
  memw();
  _DAT_3ff5c080 = _DAT_3ff5c080 | 0xc0;
  memw();
  memw();
  _DAT_3ff5103c = _DAT_3ff5103c & 0x7fffffff;
  memw();
  set_chan_freq_sw_start('\0',(sint16)channel,in_a12);
  enable = 0x3f;
  BT_tx_8m_enable(0x3f);
  memw();
  _DAT_3ff5100c = 0x14a321e0;
  memw();
  _DAT_3ff51044 = _DAT_3ff51044 & 0xffffff00 | 0x50;
  memw();
  BT_tx_LE_en(enable);
  LE_fill_tx_buffer_1010();
  if (loop == 0) {
    memw();
    memw();
    memw();
    memw();
    do {
      memw();
    } while ((_DAT_3ff51030 & 0x40) == 0);
    memw();
    _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
    memw();
    memw();
    _DAT_3ff51004 = _DAT_3ff51004 & 0xffffbfff;
    memw();
    memw();
    _DAT_3ff51008 = _DAT_3ff51008 & 0xffdfffff;
    memw();
  }
  else {
    while( true ) {
      memw();
      memw();
      memw();
      memw();
      do {
        memw();
      } while ((_DAT_3ff51030 & 0x40) == 0);
      memw();
      _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
      memw();
      memw();
      _DAT_3ff51004 = _DAT_3ff51004 & 0xffffbfff;
      memw();
      memw();
      _DAT_3ff51008 = _DAT_3ff51008 & 0xffdfffff;
      memw();
      SVar1 = GetStopCmd();
      if (SVar1 == OK) break;
      ets_delay_us(300);
    }
  }
  memw();
  memw();
  memw();
  _DAT_3ff51000 = _DAT_3ff51000 & 0xffffff83;
  memw();
  phy_printf("LE tx end!\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_get_pwr(u32 n,u32 *power_min,u32 *power_average,u32 *power_filted)

{
  u32 uVar1;
  int iVar2;
  uint uVar3;
  u32 uVar4;
  uint uVar5;
  
  iVar2 = 0;
  memw();
  *power_min = 0;
  *power_filted = 0;
  _DAT_3ff51090 = _DAT_3ff51090 | 0x80000000;
  memw();
  uVar1 = n;
  do {
    ets_delay_us(0x14);
    memw();
    _DAT_600321bc = _DAT_600321bc | 0x80000000;
    memw();
    while (uVar5 = _DAT_3ff51090, memw(), (_DAT_60032100 & 2) == 0) {
      memw();
      uVar3 = _DAT_3ff51090 >> 0xf & 0xff;
      if (0xa5 - uVar3 < 0x24) {
        uVar1 = uVar1 - 1;
        iVar2 = iVar2 + (0x100 - uVar3);
      }
      memw();
      uVar3 = _DAT_3ff51090 >> 0x17 & 0xff;
      if (uVar3 < 0x80) {
        uVar4 = *power_min;
      }
      else {
        uVar4 = 0x100 - uVar3;
      }
      memw();
      *power_min = uVar4;
      uVar5 = uVar5 >> 7 & 0xff;
      uVar3 = 0x100 - uVar5;
      if ((0x7f < uVar5) && (*power_filted < uVar3)) {
        *power_filted = uVar3;
      }
      if (uVar1 == 0) {
        memw();
        _DAT_600321bc = _DAT_600321bc & 0x7fffffff;
        memw();
        memw();
        _DAT_60032108 = _DAT_60032108 | 2;
        memw();
        memw();
        memw();
        *power_average = ((n >> 1) + iVar2) / n;
        memw();
        _DAT_3ff51090 = _DAT_3ff51090 & 0x7fffffff;
        return;
      }
    }
    memw();
    _DAT_60032108 = _DAT_60032108 | 2;
    memw();
    memw();
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_hoppe(void)

{
  int iVar1;
  int iVar2;
  undefined4 in_a12;
  
  phy_printf("hoppe test!\n");
  do {
    iVar1 = 0;
    do {
      set_chan_freq_sw_start('\0',(sint16)iVar1,(uint8)in_a12);
      iVar2 = iVar1 + 1;
      phy_printf("hoppe%2d\n",iVar1);
      iVar1 = iVar2;
    } while (iVar2 != 0x4f);
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BTAutotest(void)

{
  uint8 rf_cal_data [2048];
  u32 power_average;
  u32 power_min;
  
  ets_isr_unmask(0x20);
  wifi_init_bt();
  bt_bb_init_cmplx();
  force_bt_mode();
  phy_printf("\n\n\nForce BT\n");
  phy_printf("BT autotest!\n");
  uart_div_modify(0,0x56c);
                    // WARNING: Subroutine does not return
  BT_testmode_tester(0xdbbddaab,0xfaab,0x6b3211);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void le_uart_intr(void *para)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  u8 *puVar6;
  int iVar7;
  u32 uVar8;
  u32 uVar9;
  u32 uVar10;
  u32 uVar11;
  u32 uVar12;
  u32 uVar13;
  
  memw();
  if ((_DAT_3ff40008 & 1) != 0) {
    memw();
    _DAT_3ff40010 = 1;
    memw();
    if ((_DAT_3ff4001c & 0xff) != 0) {
      puVar6 = byte + nbyte;
      do {
        memw();
        nbyte = (u32)(puVar6 + -0x60bf3);
        *puVar6 = (u8)_DAT_3ff40000;
        memw();
        puVar6 = puVar6 + 1;
      } while ((_DAT_3ff4001c & 0xff) != 0);
    }
    bVar5 = false;
    bVar4 = false;
    bVar3 = false;
    bVar2 = false;
    bVar1 = false;
    uVar8 = cmd;
    uVar9 = nbyte;
    uVar10 = new_cmd;
    uVar11 = nbyte;
    uVar12 = idx_byte;
    uVar13 = ncmd;
    while( true ) {
      iVar7 = uVar13 * -8;
      if ((uVar11 == 0) || (uVar10 != 0)) break;
      if (uVar11 == uVar12) {
        bVar2 = true;
        uVar9 = 0;
        uVar11 = 0;
        uVar12 = 0;
      }
      else {
        uVar13 = uVar13 + 1;
        bVar4 = true;
        uVar8 = uVar8 | (uint)byte[uVar12] << 0x20 - (0x20 - (iVar7 + 8U & 0x1f));
        uVar12 = uVar12 + 1;
        bVar3 = true;
        if (uVar13 == 2) {
          bVar5 = true;
          bVar4 = true;
          uVar10 = 1;
          bVar3 = true;
          uVar13 = 0;
        }
      }
      bVar1 = true;
    }
    if (bVar1) {
      idx_byte = uVar12;
    }
    if (bVar2) {
      nbyte = uVar9;
    }
    if (bVar3) {
      ncmd = uVar13;
    }
    if (bVar4) {
      cmd = uVar8;
    }
    if (bVar5) {
      new_cmd = uVar10;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

u32 le_dtm_tx_timer(u32 init)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_6003243c = _DAT_6003243c | 0x100;
  memw();
  _DAT_6003247c = 0x271;
  memw();
  memw();
  _DAT_6003245c = _DAT_6003245c & 0xfffffffe | 1;
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void le_bb_init(void)

{
  BT_tx_LE_en(1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_le_rx_base(u32 addr)

{
  memw();
  _DAT_60032444 = addr;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_le_tx_attributes(u32 type,u32 crypt,u32 len,u32 link_addr,u32 device_sel)

{
  memw();
  if (type == 1) {
    _DAT_6003241c = _DAT_6003241c | 0x40000000;
    memw();
    memw();
    _DAT_60032420 = (len & 0x3f) << 8 | _DAT_60032420 & 0xffffc0ff;
    memw();
  }
  else {
    _DAT_6003241c = _DAT_6003241c & 0xbfffffff;
    memw();
    memw();
    _DAT_60032420 = (len & 0x1f) << 8 | _DAT_60032420 & 0xffffe0ff;
    memw();
  }
  if (crypt == 1) {
    memw();
    _DAT_6003241c = _DAT_6003241c | 0x20000000;
    memw();
  }
  else {
    memw();
    _DAT_6003241c = _DAT_6003241c & 0xdfffffff;
    memw();
  }
  memw();
  memw();
  memw();
  memw();
  _DAT_6003241c = (len & 0xff) << 0x14 | _DAT_6003241c & 0xf00c0000 | link_addr & 0x3ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_le_tx_header(u32 header)

{
  memw();
  memw();
  _DAT_60032420 = _DAT_60032420 & 0xffff0000 | header & 0xffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_le_rx_attributes(u32 type,u32 crypt,u32 device_sel)

{
  memw();
  if (type == 1) {
    _DAT_60032424 = _DAT_60032424 | 0x40000000;
    memw();
  }
  else {
    _DAT_60032424 = _DAT_60032424 & 0xbfffffff;
    memw();
  }
  if (crypt == 1) {
    memw();
    memw();
    _DAT_60032424 = _DAT_60032424 | 0x20000000;
    return;
  }
  memw();
  memw();
  _DAT_60032424 = _DAT_60032424 & 0xdfffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_ac_timer(u32 en,u32 delay)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_60032428 = _DAT_60032428 & 0x7ffffe00 | en << 0x1f | delay & 0x1ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_ifs(u32 ifs,u32 rxtx_delay,u32 txrx_delay)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_6003242c =
       (txrx_delay & 0xff) << 8 |
       (rxtx_delay & 0xff) << 0x10 | _DAT_6003242c & 0xff000000 | ifs & 0xff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void le_tx_en(u32 device_sel)

{
  memw();
  memw();
  _DAT_6003243c = _DAT_6003243c | 1;
  do {
    memw();
  } while ((_DAT_60032434 & 1) != 0);
  memw();
  memw();
  _DAT_6003241c = _DAT_6003241c | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 le_wait4tx_end(void)

{
  do {
    memw();
  } while ((_DAT_60032434 & 1) == 0);
  memw();
  memw();
  _DAT_6003243c = _DAT_6003243c | 1;
  memw();
  return _DAT_60032414 & 0xff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void le_rx_en(u32 device_sel)

{
  memw();
  memw();
  _DAT_6003243c = _DAT_6003243c | 2;
  do {
    memw();
  } while ((_DAT_60032434 & 2) != 0);
  memw();
  memw();
  _DAT_60032424 = _DAT_60032424 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 le_wait4rx_end(void)

{
  do {
    memw();
  } while ((_DAT_60032434 & 2) == 0);
  memw();
  memw();
  _DAT_6003243c = _DAT_6003243c | 2;
  memw();
  return _DAT_60032454 & 0xff;
}



// WARNING: Unknown calling convention

u32 get_le_rx_header(u32 rx_base)

{
  memw();
  return *(uint *)rx_base & 0xffff;
}



// WARNING: Unknown calling convention

u32 get_le_rx_len(u32 rx_base,u32 type)

{
  memw();
  if (type == 0) {
    return *(uint *)rx_base >> 8 & 0x1f;
  }
  return *(uint *)rx_base >> 8 & 0x3f;
}



// WARNING: Unknown calling convention

u32 get_le_payload_4byte(u32 rx_base,u32 i)

{
  memw();
  return *(u32 *)(i * 4 + rx_base + 8);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void le_init_loopback(u32 chan_id,u32 type,u32 crypt,u32 device_sel)

{
  uint8 in_a12;
  
  memw();
  _DAT_60032444 = &DAT_3ffc9000;
  set_chan_freq_sw_start('\0',(sint16)chan_id,in_a12);
  BT_tx_LE_en(1);
  set_le_rx_attributes(type,crypt,device_sel);
  set_le_tx_attributes(type,crypt,10,0x3ffc9000,device_sel);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void le_rx_compare(u32 len,u32 *total_bits,u32 *err_bits,u32 *ref)

{
  u32 word_len;
  u32 last_mask;
  uint uVar1;
  int iVar2;
  uint uVar3;
  u32 uVar4;
  uint uVar5;
  
  uVar3 = len & 3;
  memw();
  uVar1 = 0xffff;
  if (((uVar3 != 2) && (uVar1 = 0xffffff, uVar3 != 3)) && (uVar1 = 0, uVar3 == 1)) {
    uVar1 = 0xff;
  }
  iVar2 = _DAT_60032110 + 8;
  uVar4 = 0;
  *err_bits = 0;
  uVar3 = 0;
  iVar2 = iVar2 - (int)ref;
  do {
    memw();
    uVar5 = *(uint *)(iVar2 + (int)ref) ^ *ref;
    if (uVar3 == len >> 2) {
      uVar5 = uVar1 & uVar5;
    }
    uVar4 = uVar4 + (uVar5 & 1);
    *err_bits = uVar4;
    uVar3 = uVar3 + 1;
    ref = ref + 1;
  } while (uVar3 != (len >> 2) + 1);
  *total_bits = len << 3;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void le_loopback_slave(u32 type,u32 crypt,u32 device_sel,u32 loop_time,u32 *total_bits,u32 *err_bits
                      ,u32 *ref,u32 *cnpac)

{
  uint uVar1;
  uint uVar2;
  u32 len;
  uint local_50;
  
  memw();
  *cnpac = 0;
  _DAT_60032428 = _DAT_60032428 & 0x7fffffff;
  memw();
  if (loop_time != 0) {
    local_50 = 0;
    uVar1 = 0x43;
    do {
      memw();
      memw();
      do {
        memw();
      } while ((_DAT_60032434 & 2) != 0);
      memw();
      _DAT_60032424 = _DAT_60032424 | 0x80000000;
      memw();
      do {
        memw();
      } while ((_DAT_60032434 & 2) == 0);
      memw();
      _DAT_6003243c = _DAT_6003243c | 2;
      memw();
      memw();
      uVar2 = _DAT_60032454 & 0xff;
      if ((uVar2 == 0) || (uVar2 == 0x41 || uVar2 == 0)) {
        if (type == 0) {
          memw();
          len = _DAT_3ffc9000 >> 8 & 0x1f;
        }
        else {
          memw();
          len = _DAT_3ffc9000 >> 8 & 0x3f;
        }
        set_le_tx_attributes(type,crypt,len,0x3ffc9004,device_sel);
        memw();
        _DAT_6003243c = _DAT_6003243c | 1;
        memw();
        do {
          memw();
        } while ((_DAT_60032434 & 1) != 0);
        memw();
        local_50 = local_50 + 1;
        _DAT_6003241c = _DAT_6003241c | 0x80000000;
        memw();
        if ((uVar1 == 0) || (uVar1 == 0x41)) {
          *cnpac = *cnpac + 1;
        }
        le_rx_compare(len,total_bits,err_bits,ref);
        phy_printf(&DAT_00053038);
        do {
          memw();
        } while ((_DAT_60032434 & 1) == 0);
        memw();
        _DAT_6003243c = _DAT_6003243c | 1;
        memw();
        memw();
      }
      memw();
      memw();
      memw();
      _DAT_60032428 = _DAT_60032428 & 0xfffffe00 | 0x80000064;
      memw();
      uVar1 = uVar2;
    } while (local_50 < loop_time);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void le_run_master(u32 device_sel)

{
  STATUS SVar1;
  u32 cmd;
  
  memw();
  _DAT_60032428 = _DAT_60032428 | 0x80000000;
  memw();
  do {
    memw();
    memw();
    do {
      memw();
    } while ((_DAT_60032434 & 1) != 0);
    memw();
    _DAT_6003241c = _DAT_6003241c | 0x80000000;
    memw();
    do {
      memw();
    } while ((_DAT_60032434 & 1) == 0);
    memw();
    memw();
    memw();
    memw();
    memw();
    do {
      memw();
    } while ((_DAT_60032434 & 2) != 0);
    memw();
    _DAT_60032424 = _DAT_60032424 | 0x80000000;
    memw();
    do {
      memw();
    } while ((_DAT_60032434 & 2) == 0);
    memw();
    _DAT_6003243c = _DAT_6003243c | 3;
    memw();
    memw();
    SVar1 = GetStopCmd();
  } while ((SVar1 != BUSY) && (SVar1 != OK && SVar1 != BUSY));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void le_test_master(u32 chan_id,u32 type,u32 crypt,u32 device_sel,u32 len)

{
  uint8 in_a12;
  u32 my_PRBS9 [257];
  
  memw();
  _DAT_60032444 = &DAT_3ffc9000;
  set_chan_freq_sw_start('\0',(sint16)chan_id,in_a12);
  BT_tx_LE_en(1);
  prbs9_gen(my_PRBS9);
  set_le_rx_attributes(type,crypt,device_sel);
  set_le_tx_attributes(type,crypt,len,(u32)my_PRBS9,device_sel);
  le_run_master(device_sel);
  return;
}



// WARNING: Unknown calling convention

void le_test_slave(u32 chan_id,u32 type,u32 crypt,u32 device_sel)

{
  u32 my_PRBS9 [257];
  u32 cnpac;
  u32 err_bits;
  u32 total_bits;
  
  prbs9_gen(my_PRBS9);
  le_init_loopback(chan_id,type,crypt,device_sel);
  do {
    le_loopback_slave(type,crypt,device_sel,1000,&total_bits,&err_bits,my_PRBS9,&cnpac);
    phy_printf("total_pac: %d, consec_pac: %d, total_bits: %d, err_bits: %d\n ",1000,cnpac,
               total_bits,err_bits);
  } while( true );
}



// WARNING: Unknown calling convention

u32 get_ADV_PDU_type(u32 rx_base)

{
  memw();
  return *(uint *)rx_base & 0xf;
}



// WARNING: Unknown calling convention

u32 get_ADV_PDU_header(u32 rx_base,LE_rx_adv_header *header)

{
  uint uVar1;
  
  memw();
  uVar1 = *(uint *)rx_base;
  header->type = uVar1 & 0xf;
  header->TxAdd = uVar1 >> 6 & 1;
  header->RxAdd = uVar1 >> 7 & 1;
  header->len = (uVar1 & 0x3f00) >> 8;
  return rx_base;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void fill_ADV_PAC(u32 PDU_type,u32 TxAdd,u32 RxAdd,u32 len,u32 payload_link)

{
  memw();
  _DAT_60032420 =
       (len & 0x3f) << 8 | _DAT_60032420 & 0xffff0000 | (RxAdd & 1) << 7 | PDU_type & 0xf |
       (TxAdd & 1) << 6;
  memw();
  set_le_tx_attributes(1,0,len,payload_link,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void fill_DATA_PAC(u32 LLID,u32 SN,u32 NESN,u32 MD,u32 len,u32 payload_link)

{
  memw();
  _DAT_60032420 =
       (len & 0x1f) << 8 | _DAT_60032420 & 0xffff0000 | (MD & 1) << 4 | (SN & 1) << 3 | LLID & 3 |
       (NESN & 1) << 2;
  memw();
  set_le_tx_attributes(0,0,len,payload_link,0);
  return;
}



// WARNING: Unknown calling convention

sint16 noise_init_le(void)

{
  sint16 sVar1;
  
  sVar1 = (*g_phyFuns->check_noise_floor_)();
  return sVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LE_rx_prbs9_status(u32 *total_bits,u32 *err_bits,u32 type)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  u32 uVar4;
  uint uVar5;
  uint *puVar6;
  u32 *puVar7;
  
  puVar6 = _DAT_60032444;
  memw();
  memw();
  if (type == 0) {
    uVar2 = *_DAT_60032444 >> 8 & 0x1f;
  }
  else {
    uVar2 = *_DAT_60032444 >> 8 & 0x3f;
  }
  uVar1 = uVar2 & 3;
  if (uVar1 == 2) {
    uVar3 = 0xffff;
  }
  else if (uVar1 == 3) {
    uVar3 = 0xffffff;
  }
  else {
    uVar3 = 0xff;
    if (uVar1 != 1) {
      uVar3 = 0;
      *err_bits = 0;
      goto LAB_00012f92;
    }
  }
  *err_bits = 0;
LAB_00012f92:
  uVar4 = 0;
  puVar7 = PRBS9;
  puVar6 = puVar6 + 2;
  uVar1 = 0;
  do {
    memw();
    uVar5 = *puVar6 ^ *puVar7;
    if (uVar1 == uVar2 >> 2) {
      uVar5 = uVar5 & uVar3;
    }
    uVar4 = uVar4 + (uVar5 & 1);
    *err_bits = uVar4;
    uVar1 = uVar1 + 1;
    puVar6 = puVar6 + 1;
    puVar7 = puVar7 + 1;
  } while ((uVar2 >> 2) + 1 != uVar1);
  *total_bits = uVar2 << 3;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LE_rx_per(u32 chan_id,u32 type)

{
  sint16 sVar1;
  uint uVar2;
  STATUS unaff_a9;
  u32 noise_filted_1m;
  u32 noise_average_1m;
  u32 noise_min_1m;
  int iStack_70;
  uint uStack_6c;
  int iStack_68;
  int iStack_64;
  int iStack_60;
  int iStack_5c;
  int iStack_58;
  int iStack_54;
  int iStack_50;
  int iStack_4c;
  int iStack_48;
  int iStack_44;
  int iStack_40;
  int iStack_3c;
  int iStack_38;
  int iStack_34;
  
  noise_min_1m = 0;
  noise_average_1m = 0;
  noise_filted_1m = 0;
  le_init_loopback(chan_id,type,0,0);
  sVar1 = (*g_phyFuns->check_noise_floor_)();
  iStack_34 = (int)sVar1;
  BT_get_pwr(100,&noise_min_1m,&noise_average_1m,&noise_filted_1m);
  phy_printf("LE rx per\n");
  memw();
  _DAT_6003240c = 0xe1764129;
  memw();
  _DAT_60032408 = _DAT_60032408 & 0x3fffffff | 0x40000000;
  memw();
  memw();
  _DAT_6003242c = _DAT_6003242c & 0xffffff00 | 0x14;
  memw();
  memw();
  _DAT_60032418 = _DAT_60032418 & 0xff | 0x55555500;
  memw();
  memw();
  memw();
  memw();
  _DAT_60032458 = _DAT_60032458 | 3;
  memw();
  memw();
  _DAT_3ff5106c = _DAT_3ff5106c & 0xfff0ffff | 0xa0000;
  memw();
  memw();
  _DAT_3ff5c0d0 = _DAT_3ff5c0d0 & 0xfffffe00 | 0x1be;
  memw();
  memw();
  memw();
  memw();
  uStack_6c = 0;
  _DAT_60032430 = _DAT_60032430 | 10;
  memw();
  iStack_58 = 0;
  iStack_5c = 0;
  iStack_60 = 0;
  iStack_64 = 0;
  iStack_38 = 0;
  iStack_3c = 0;
  iStack_40 = 0;
  iStack_44 = 0;
  iStack_48 = 0;
  iStack_50 = 0;
  iStack_54 = 0;
  iStack_4c = 0;
  iStack_68 = 0;
  do {
    memw();
    iStack_70 = 0;
    _DAT_60032424 = _DAT_60032424 | 0x80000000;
    memw();
    while (memw(), (_DAT_60032434 & 2) == 0) {
      unaff_a9 = GetStopCmd();
      if ((unaff_a9 == BUSY) || (unaff_a9 == OK)) {
        memw();
        iStack_70 = 1;
        memw();
        memw();
        _DAT_60032424 = _DAT_60032424 & 0x7fffffff | 0x10000000;
        memw();
      }
    }
    memw();
    _DAT_60032424 = _DAT_60032424 & 0xefffffff;
    memw();
    memw();
    _DAT_6003243c = _DAT_6003243c | 2;
    memw();
    memw();
    uVar2 = _DAT_60032454 & 0xff;
    if (((uVar2 - 0x43 & 0xfffffffd) != 0) && (1 < uVar2 - 0x38)) {
      switch(uVar2) {
      case 0:
        memw();
        memw();
        uStack_6c = uStack_6c + ((_DAT_3ff51078 >> 0x10 & 0xff) - (_DAT_3ff51074 & 0xff)) + 0x100;
        iStack_54 = iStack_54 + 1;
        break;
      case 1:
        iStack_4c = iStack_4c + 1;
        break;
      case 2:
        iStack_48 = iStack_48 + 1;
        break;
      default:
        iStack_40 = iStack_40 + 1;
        break;
      case 4:
        iStack_3c = iStack_3c + 1;
        break;
      case 8:
        iStack_38 = iStack_38 + 1;
        break;
      case 0x41:
        memw();
        memw();
        uStack_6c = uStack_6c + ((_DAT_3ff51078 >> 0x10 & 0xff) - (_DAT_3ff51074 & 0xff)) + 0x100;
        iStack_50 = iStack_50 + 1;
        break;
      case 0x44:
        iStack_44 = iStack_44 + 1;
      }
      memw();
      iStack_68 = iStack_68 + 1;
      iStack_64 = iStack_64 + (uint)((_DAT_3ff51050 & 0x80) != 0);
      iStack_60 = iStack_60 + (uint)((_DAT_3ff51050 & 0x40) != 0);
      iStack_5c = iStack_5c + (uint)((_DAT_3ff51050 & 0x2a) != 0);
      iStack_58 = iStack_58 + (uint)((_DAT_3ff51050 & 0x15) != 0);
    }
    if (iStack_70 == 0) {
      unaff_a9 = GetStopCmd();
    }
  } while ((unaff_a9 != BUSY && unaff_a9 != OK) && (iStack_70 == 0));
  uVar2 = iStack_54 + iStack_50;
  if (uVar2 != 0) {
    uStack_6c = ((uVar2 >> 1) + uStack_6c) / uVar2;
  }
  phy_printf(" %x %x %x %x %x %x %x %x %x w %x %x %x %x p %x %x %x %x\n",iStack_68,iStack_54,
             iStack_50,iStack_4c,iStack_48,iStack_44,iStack_3c,iStack_38,iStack_40,iStack_64,
             iStack_60,iStack_5c,iStack_58,uStack_6c,iStack_34,noise_filted_1m,noise_average_1m);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LE_rx_per_debug(void)

{
  do {
    LE_rx_per(0x42,0);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LE_rx_ber(u32 bits,u32 type,u32 chan_id)

{
  sint16 sVar1;
  STATUS SVar2;
  uint uVar3;
  uint uVar4;
  u32 get_err_bits;
  u32 get_total_bits;
  uint uStack_50;
  u32 uStack_4c;
  u32 uStack_48;
  u32 uStack_44;
  uint uStack_40;
  u32 uStack_3c;
  u32 uStack_38;
  u32 uStack_34;
  u32 uStack_30;
  int iStack_2c;
  uint uStack_28;
  
  uStack_4c = bits;
  uStack_34 = type;
  le_init_loopback(chan_id,type,0,0);
  sVar1 = (*g_phyFuns->check_noise_floor_)();
  iStack_2c = (int)sVar1;
  memw();
  _DAT_6003240c = 0xe1764129;
  memw();
  _DAT_60032408 = _DAT_60032408 & 0x3fffffff | 0x40000000;
  memw();
  memw();
  _DAT_6003242c = _DAT_6003242c & 0xffffff00 | 0x14;
  memw();
  memw();
  _DAT_60032418 = _DAT_60032418 & 0xff | 0x55555500;
  memw();
  memw();
  memw();
  memw();
  _DAT_60032458 = _DAT_60032458 | 3;
  memw();
  prbs9_gen(PRBS9);
  get_total_bits = 0;
  get_err_bits = 0;
  if (uStack_4c == 0) {
    uStack_48 = uStack_4c;
    uStack_38 = uStack_4c;
    uStack_30 = uStack_4c;
    uStack_40 = uStack_4c;
    uStack_3c = uStack_4c;
    uStack_50 = uStack_4c;
    uStack_44 = uStack_4c;
  }
  else {
    uStack_48 = 0;
    uVar3 = 0;
    uStack_38 = 0;
    uStack_30 = 0;
    uStack_40 = 0;
    uStack_44 = 0;
    uStack_3c = 0;
    uStack_50 = 0;
    do {
      memw();
      uVar3 = uVar3 + 1;
      _DAT_60032424 = _DAT_60032424 | 0x80000000;
      memw();
      while (memw(), (_DAT_60032434 & 2) == 0) {
        SVar2 = GetStopCmd();
        if ((SVar2 == BUSY) || (SVar2 == OK || SVar2 == BUSY)) {
          memw();
          memw();
          memw();
          _DAT_60032424 = _DAT_60032424 & 0x7fffffff | 0x10000000;
          memw();
        }
      }
      memw();
      _DAT_60032424 = _DAT_60032424 & 0xefffffff;
      memw();
      memw();
      _DAT_6003243c = _DAT_6003243c | 2;
      memw();
      memw();
      uVar4 = _DAT_60032454 & 0xff;
      if ((uVar4 == 0) || (uVar4 == 0x41 || uVar4 == 0)) {
        uStack_28 = uVar4;
        LE_rx_prbs9_status(&get_total_bits,&get_err_bits,uStack_34);
        if (uStack_28 == 0) {
          uStack_30 = uStack_30 + 1;
          uStack_48 = uStack_48 + (get_err_bits != 0);
        }
        memw();
        memw();
        uStack_50 = uStack_50 + get_total_bits;
        uStack_3c = uStack_3c + get_err_bits;
        uStack_44 = uStack_44 + ((_DAT_3ff51078 >> 0x10 & 0xff) - (_DAT_3ff51074 & 0xff)) + 0x100;
        uStack_40 = uStack_40 + 1;
        uStack_38 = uStack_38 + (uStack_28 == 0x41);
      }
      if ((500 < uVar3) && (uStack_50 == 0)) {
        uStack_50 = 0;
        break;
      }
    } while (uStack_50 < uStack_4c);
    if ((uStack_44 != 0) && (uStack_40 != 0)) {
      uStack_44 = ((uStack_40 >> 1) + uStack_44) / uStack_40;
    }
  }
  phy_printf("%x %x p %x %x n %x %x %x %x\n",uStack_50,uStack_3c,uStack_44,iStack_2c,uStack_40,
             uStack_30,uStack_38,uStack_48);
  return;
}



// WARNING: Unknown calling convention

void fill_TEST_PAC(LE_DTM_state *state)

{
  u32 PDU_type;
  u32 *payload_link;
  u32 ADV_PAYLOAD [11];
  
  PDU_type = state->pac_type;
  payload_link = PRBS9;
  if (((PDU_type != 0) && (ADV_PAYLOAD[0] = 0xf0f0f0f, payload_link = ADV_PAYLOAD, PDU_type != 1))
     && (ADV_PAYLOAD[0] = 0x55555555, payload_link = ADV_PAYLOAD, PDU_type != 2)) {
    ADV_PAYLOAD[0] = 0xaaaaaaaa;
    payload_link = ADV_PAYLOAD;
  }
  fill_ADV_PAC(PDU_type,0,0,state->len,(u32)payload_link);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 le_dtm_tx_timer(u32 init)

{
  bool bVar1;
  u32 uVar2;
  u32 unaff_a10;
  
  if (init == 1) {
    uVar2 = le_dtm_tx_timer(unaff_a10);
    return uVar2;
  }
  memw();
  bVar1 = (_DAT_60032434 & 0x100) != 0;
  if (bVar1) {
    memw();
    _DAT_6003243c = _DAT_6003243c | 0x100;
    memw();
    memw();
    _DAT_6003247c = 0x26c;
    memw();
    _DAT_6003245c = _DAT_6003245c | 1;
    memw();
  }
  return (uint)bVar1;
}



// WARNING: Unknown calling convention

void le_dtm_state_refresh(LE_DTM_state *state,u32 cmd)

{
  uint uVar1;
  
  uVar1 = cmd >> 0xe & 3;
  state->lst_cmd = state->cmd;
  state->cmd = uVar1;
  state->chan = cmd >> 8 & 0x3f;
  state->len = cmd >> 2 & 0x3f;
  state->pac_type = cmd & 3;
  if ((uVar1 != 0) && (uVar1 != 3)) {
    state->state = 1;
    return;
  }
  state->state = 0;
  return;
}



// WARNING: Unknown calling convention

void le_dtm_rsp(LE_DTM_state *state)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = 0;
  uVar2 = 0;
  if ((state->cmd == 3) && (uVar2 = 0x80, state->lst_cmd == 1)) {
    uVar2 = ((ushort)rx_pac | 0x8000) >> 8;
    uVar1 = (ushort)rx_pac & 0xff;
  }
  uart_tx_one_char(uVar2);
  uart_tx_one_char(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void le_dtm(void)

{
  int iVar1;
  LE_DTM_state *init;
  u32 uVar2;
  uint uVar3;
  uint uVar4;
  u32 local_30;
  
  iVar1 = GetUartDevice();
  core.state = 0;
  prbs9_gen(PRBS9);
  memw();
  memw();
  memw();
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xff00ffff | 0x110000;
  memw();
  BT_tx_LE_en(1);
  memw();
  _DAT_60032444 = &DAT_3ffc9000;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff5c0d0 = _DAT_3ff5c0d0 & 0xfffffe00 | 0x1be;
  memw();
  memw();
  _DAT_6003240c = 0x71764129;
  memw();
  _DAT_60032408 = _DAT_60032408 & 0x3fffffff | 0x40000000;
  memw();
  memw();
  _DAT_6003242c = _DAT_6003242c & 0xff000000 | 0x10a14;
  memw();
  memw();
  _DAT_60032418 = _DAT_60032418 & 0xff | 0x55555500;
  memw();
  memw();
  memw();
  memw();
  _DAT_60032458 = _DAT_60032458 | 3;
  memw();
  memw();
  uVar4 = iVar1 + 0x18;
  memw();
  memw();
  _DAT_60032428 = _DAT_60032428 & 0x7ffffe00 | 0x1ff;
  memw();
  memw();
  memw();
  memw();
  _DAT_60032424 = _DAT_60032424 & 0xdfffffff | 0x40000000;
  memw();
  ets_isr_attach(5,le_uart_intr);
  ets_isr_unmask(0x20);
  local_30 = 0;
  do {
    while( true ) {
      while( true ) {
        uVar2 = new_cmd;
        if (new_cmd == 1) {
          uVar3 = cmd >> 0xe & 3;
          uVar4 = cmd >> 8 & 0x3f;
          core.len = cmd >> 2 & 0x3f;
          core.pac_type = cmd & 3;
          new_cmd = 0;
          core.lst_cmd = core.cmd;
          if ((uVar3 == 0) || (uVar3 == 3)) {
            core.state = 0;
          }
          else {
            core.state = uVar2;
          }
          core.cmd = uVar3;
          core.chan = uVar4;
          le_dtm_rsp(&core);
          cmd = 0;
        }
        if (core.state != 1) break;
        if (core.cmd == 2) {
          memw();
          _DAT_3ff51044 = _DAT_3ff51044 & 0xffffff00 | 0xa0;
          memw();
          core.state = core.cmd;
          set_chan_freq_sw_start('\0',(short)core.chan * 2 + 1,(uint8)uVar4);
          init = &core;
          fill_TEST_PAC(&core);
          le_dtm_tx_timer((u32)init);
          rx_pac = 0;
        }
        else {
          if (core.cmd != 1) goto LAB_00013c28;
          core.state = 2;
          set_chan_freq_sw_start('\0',(sint16)(core.chan << 1),(uint8)uVar4);
          memw();
          local_30 = 0;
          _DAT_6003243c = _DAT_6003243c | 2;
          memw();
          rx_pac = 0;
        }
      }
      if (core.state == 0) break;
      if (core.state == 2) {
        if (core.cmd == 2) {
          uVar2 = le_dtm_tx_timer(0);
          if (uVar2 == 1) {
            memw();
            memw();
            do {
              memw();
            } while ((_DAT_60032434 & 1) != 0);
            memw();
            _DAT_6003241c = _DAT_6003241c | 0x80000000;
            memw();
            do {
              memw();
            } while ((_DAT_60032434 & 1) == 0);
            memw();
            _DAT_6003243c = _DAT_6003243c | 1;
            memw();
            memw();
            if ((_DAT_60032414 & 0xff) != 0) {
              phy_printf(&DAT_000530e4);
            }
          }
        }
        else if (core.cmd == 1) {
          memw();
          _DAT_60032424 = _DAT_60032424 | 0x80000000;
          memw();
          while (memw(), (_DAT_60032434 & 2) == 0) {
            if (new_cmd == 1) {
              memw();
              local_30 = new_cmd;
              _DAT_60032424 = _DAT_60032424 & 0x7fffffff;
              memw();
              memw();
              memw();
            }
          }
          memw();
          _DAT_60032424 = _DAT_60032424 & 0xefffffff;
          memw();
          memw();
          _DAT_6003243c = _DAT_6003243c | 2;
          memw();
          memw();
          if ((local_30 == 0) && ((_DAT_60032454 & 0xff) == 0)) {
            rx_pac = rx_pac + 1;
          }
        }
        else {
LAB_00013c28:
          core.state = 0;
        }
      }
    }
    if (core.cmd - 1 < 2) {
      core.state = 1;
    }
  } while( true );
}



// WARNING: Unknown calling convention

uint32_t rf_rw_reg_rd(uint16_t addr)

{
  return 0;
}



// WARNING: Unknown calling convention

void rf_rw_reg_wr(uint16_t addr,uint32_t value)

{
  return;
}



// WARNING: Unknown calling convention

uint8_t rf_rw_txpwr_dbm_get(uint8_t txpwr_idx,uint8_t modulation)

{
  return "\n\b\x06\x04\x02"[txpwr_idx];
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rf_rw_reset(void)

{
  return;
}



// WARNING: Unknown calling convention

int8_t rf_rw_rssi_convert(uint8_t rssi_reg)

{
  return rssi_reg;
}



// WARNING: Unknown calling convention

bool rf_rw_txpwr_inc(uint8_t link_id)

{
  return true;
}



// WARNING: Unknown calling convention

void rf_rw_txpwr_max_set(uint8_t link_id)

{
  return;
}



// WARNING: Unknown calling convention

uint8_t rf_rw_txpwr_cs_get(int8_t txpwr_dbm)

{
  uint uVar1;
  uint uVar2;
  int8_t iVar3;
  
  if (txpwr_dbm < -7) {
    return '\t';
  }
  iVar3 = -6;
  uVar1 = 8;
  while( true ) {
    uVar2 = uVar1 - 1 & 0xff;
    if (txpwr_dbm <= iVar3) {
      return (uint8_t)uVar1;
    }
    if (uVar2 == 0xff) break;
    iVar3 = "\n\b\x06\x04\x02"[uVar2];
    uVar1 = uVar2;
  }
  return '\0';
}



undefined4 rf_rw_txpwr_dec(void)

{
  return 1;
}



void rf_rw_force_agc_enable(void)

{
  return;
}



void rf_rw_sleep(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_em_radio_table(void)

{
  memw();
  _DAT_3ffb0040 = 0x6040200;
  memw();
  _DAT_3ffb0044 = 0xe0c0a08;
  memw();
  _DAT_3ffb0048 = 0x16141210;
  memw();
  _DAT_3ffb004c = 0x1e1c1a18;
  memw();
  _DAT_3ffb0050 = 0x26242220;
  memw();
  _DAT_3ffb0054 = 0x2e2c2a28;
  memw();
  _DAT_3ffb0058 = 0x36343230;
  memw();
  _DAT_3ffb005c = 0x3e3c3a38;
  memw();
  _DAT_3ffb0060 = 0x46444240;
  memw();
  _DAT_3ffb0064 = 0x4e4c4a48;
  memw();
  _DAT_3ffb0068 = 0x7050301;
  memw();
  _DAT_3ffb006c = 0xf0d0b09;
  memw();
  _DAT_3ffb0070 = 0x17151311;
  memw();
  _DAT_3ffb0074 = 0x1f1d1b19;
  memw();
  _DAT_3ffb0078 = 0x27252321;
  memw();
  _DAT_3ffb007c = 0x2f2d2b29;
  memw();
  _DAT_3ffb0080 = 0x37353331;
  memw();
  _DAT_3ffb0084 = 0x3f3d3b39;
  memw();
  _DAT_3ffb0088 = 0x47454341;
  memw();
  _DAT_3ffb008c = 0x4d4b49;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rf_rw_bt_init(void)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51098 = _DAT_3ff51098 & 0xe0000001 | 0xa900dd;
  memw();
  memw();
  memw();
  memw();
  _DAT_60031080 = _DAT_60031080 & 0xff00ff00 | 0x820082;
  memw();
  memw();
  _DAT_60031070 = _DAT_60031070 & 0xffbfffff;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_60031074 = _DAT_60031074 & 0xffe0ffff | 0x20000;
  memw();
  memw();
  _DAT_60031274 = _DAT_60031274 & 0xffe0ffff | 0x20000;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_60031000 = _DAT_60031000 & 0xfffffff0 | 0x7003;
  memw();
  memw();
  memw();
  memw();
  _DAT_600310b0 = _DAT_600310b0 & 0xfc00fe00 | 0x1c200e6;
  memw();
  memw();
  _DAT_60031028 = _DAT_60031028 & 0xc0fffe00 | 0x35010190;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rf_rw_le_init(void)

{
  memw();
  memw();
  _DAT_3ff51098 = _DAT_3ff51098 | 1;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff5109c = _DAT_3ff5109c & 0xff000000 | 0x625024;
  memw();
  memw();
  _DAT_60031270 = _DAT_60031270 & 0xffbfffff;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_60031280 = _DAT_60031280 & 0x8000ff00 | 0x14640064;
  memw();
  memw();
  memw();
  memw();
  _DAT_60031074 = _DAT_60031074 & 0xffe0ffff | 0x20000;
  memw();
  memw();
  _DAT_60031274 = _DAT_60031274 & 0xffe0ffff | 0x20000;
  memw();
  memw();
  _DAT_60031200 = _DAT_60031200 & 0xfffffff8 | 0xf4;
  memw();
  memw();
  memw();
  memw();
  _DAT_600312f0 = _DAT_600312f0 & 0x7c00fe00 | 0x1ae00d2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bt_core_on(void)

{
  memw();
  memw();
  _DAT_60031000 = _DAT_60031000 | 0x100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_core_on(void)

{
  memw();
  memw();
  _DAT_60031200 = _DAT_60031200 | 0x100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bt_core_off(void)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_60031000 = _DAT_60031000 & 0xfffffeff | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_core_off(void)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_60031200 = _DAT_60031200 & 0xfffffeff | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rf_rw_init(rwip_rf_api *api)

{
  api->reg_rd = rf_rw_reg_rd;
  api->reg_wr = rf_rw_reg_wr;
  api->txpwr_dbm_get = rf_rw_txpwr_dbm_get;
  api->txpwr_max = '\0';
  api->sleep = rf_rw_sleep;
  api->reset = rf_rw_reset;
  api->force_agc_enable = rf_rw_force_agc_enable;
  api->rssi_convert = rf_rw_rssi_convert;
  api->txpwr_dec = rf_rw_txpwr_dec;
  api->txpwr_inc = rf_rw_txpwr_inc;
  api->txpwr_max_set = rf_rw_txpwr_max_set;
  api->txpwr_cs_get = rf_rw_txpwr_cs_get;
  api->rssi_high_thr = -0x14;
  api->rssi_low_thr = -0x3c;
  api->rssi_interf_thr = -0x46;
  rw_init_em_radio_table();
  bt_bb_init_cmplx();
  memw();
  _DAT_3ff510a0 = _DAT_3ff510a0 & 0x7fff | 0x3ffb0000;
  memw();
  rf_rw_bt_init();
  rf_rw_le_init();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_scan_refresh(u32 txdesc_refresh,u32 winsz)

{
  memw();
  _DAT_60031218 = _DAT_60031218 | 8;
  memw();
  memw();
  _DAT_3ffb0214 = _DAT_3ffb0214 & 0xffffc000 | winsz & 0x3fff;
  memw();
  if (rw_scan_abort != 0) {
    rw_scan_abort = 0;
    memw();
    _DAT_60033d40 = _DAT_60033d40 & 0xffffffc7 | 0x10;
    memw();
    memw();
    memw();
    phy_printf(&DAT_000530ec);
  }
  memw();
  _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
  memw();
  if (txdesc_refresh != 0) {
    memw();
    _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
    memw();
  }
  memw();
  evt_refresh_ind = 1;
  if ((_DAT_3ffb0210 & 0x3f) == 0x25) {
    memw();
    _DAT_3ffb0210 = _DAT_3ffb0210 & 0xffffffc0 | 0x26;
    memw();
  }
  else if ((_DAT_3ffb0210 & 0x3f) == 0x26) {
    memw();
    _DAT_3ffb0210 = _DAT_3ffb0210 & 0xffffffc0 | 0x27;
    memw();
  }
  else {
    memw();
    _DAT_3ffb0210 = _DAT_3ffb0210 & 0xffffffc0 | 0x25;
    memw();
  }
  phy_printf("EVT %d\n");
  last_scan_event_end = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_et_on_mask(u32 mask)

{
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  if ((mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000302;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_et_init(void)

{
  memw();
  _DAT_6003122c = 0;
  memw();
  _DAT_3ffb0000 = 2;
  memw();
  _DAT_3ffb0004 = 0x2000302;
  memw();
  _DAT_3ffb0008 = 2;
  memw();
  _DAT_3ffb000c = 0x302;
  memw();
  _DAT_3ffb0010 = 2;
  memw();
  _DAT_3ffb0014 = 2;
  memw();
  _DAT_3ffb0018 = 2;
  memw();
  _DAT_3ffb001c = 2;
  memw();
  _DAT_3ffb0020 = 2;
  memw();
  _DAT_3ffb0024 = 0x302;
  memw();
  _DAT_3ffb0028 = 2;
  memw();
  _DAT_3ffb002c = 2;
  memw();
  _DAT_3ffb0030 = 2;
  memw();
  _DAT_3ffb0034 = 2;
  memw();
  _DAT_3ffb0038 = 2;
  memw();
  _DAT_3ffb003c = 0x302;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_set_dbaddr(u32 bdaddru,u32 bdaddrl)

{
  memw();
  _DAT_60031224 = bdaddrl;
  memw();
  memw();
  _DAT_60031228 = _DAT_60031228 & 0xffff0000 | bdaddru & 0xffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_init_cs(u32 format,u32 sync_word,u32 crc_init,u32 ral_en,u32 ral_mode,u32 local_rpa_sel,
                  u32 filter_policy,u32 ch_idx,u32 hopint,u32 fh_en,u32 txpwr,u32 rxwide,u32 rxwinsz
                  ,u32 txdesc,u32 maxevtime)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb021c = 0xffffffff;
  memw();
  memw();
  _DAT_3ffb0224 = 0;
  memw();
  _DAT_3ffb0228 = 0;
  memw();
  _DAT_3ffb022c = 0;
  memw();
  _DAT_3ffb0230 = 0;
  memw();
  _DAT_3ffb0234 = 0;
  memw();
  _DAT_3ffb0238 = 0;
  memw();
  _DAT_3ffb023c = 0;
  memw();
  _DAT_3ffb0240 = 0;
  memw();
  _DAT_3ffb0244 = 0;
  memw();
  _DAT_3ffb0248 = 0;
  memw();
  _DAT_3ffb024c = 0;
  memw();
  _DAT_3ffb0250 = 0;
  memw();
  _DAT_3ffb0254 = 0;
  memw();
  _DAT_3ffb0258 = 0;
  memw();
  _DAT_3ffb025c = 0;
  memw();
  _DAT_3ffb0260 = 0;
  memw();
  _DAT_3ffb026c = 0;
  memw();
  memw();
  _DAT_3ffb0200 = format & 0x1f;
  memw();
  memw();
  _DAT_3ffb0204 = sync_word << 0x10;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb0208 = sync_word >> 0x10 | crc_init << 0x10;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb020c =
       (local_rpa_sel & 1) << 0x12 |
       (ral_mode & 1) << 0x11 | (ral_en & 1) << 0x10 | crc_init >> 0x10 & 0xff |
       filter_policy << 0x18;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb0210 = (txpwr & 0xff) << 0x10 | (fh_en & 1) << 0xf | (hopint & 0x1f) << 8 | ch_idx & 0x3f
  ;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb0214 = (txdesc & 0x7fff) << 0x10 | (rxwide & 1) << 0xf | rxwinsz & 0x3fff;
  memw();
  memw();
  _DAT_3ffb0218 = maxevtime << 0x10;
  memw();
  memw();
  _DAT_3ffb0220 = 0xc8251f;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_cs_set_txpwr(u32 txpwr)

{
  memw();
  memw();
  _DAT_3ffb0210 = (txpwr & 0xff) << 0x10 | _DAT_3ffb0210 & 0xff00ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_txpwr_toggle_test(void)

{
  memw();
  memw();
  if ((_DAT_3ffb0210 >> 0x10 & 0xff) != 0) {
    memw();
    _DAT_3ffb0210 = _DAT_3ffb0210 & 0xff00ffff;
    return;
  }
  memw();
  _DAT_3ffb0210 = _DAT_3ffb0210 & 0xff00ffff | 0x10000;
  return;
}



// WARNING: Unknown calling convention

void rw_le_cs_set_freq(u32 addr,u32 freq)

{
  memw();
  memw();
  *(uint *)(addr + 0x10) = *(uint *)(addr + 0x10) & 0xffffffc0 | freq & 0x3f;
  return;
}



// WARNING: Unknown calling convention

void rw_le_cs_set_txdesc(u32 addr,u32 desc)

{
  memw();
  memw();
  *(u32 *)(addr + 0x14) = (desc & 0x7fff) << 0x10 | *(uint *)(addr + 0x14) & 0x8000ffff;
  return;
}



// WARNING: Unknown calling convention

void rw_le_init_tx_descriptor
               (u32 is_connevt,u32 ptr,u32 nxt_ptr,u32 llid,u32 nesn,u32 sn,u32 md,u32 len,u32 type,
               u32 txadd,u32 rxadd,u32 advlen,u32 bufptr)

{
  uint uVar1;
  
  if (is_connevt == 0) {
    uVar1 = (rxadd & 1) << 0x17 | advlen << 0x18 | (txadd & 1) << 0x16 | (type & 0xf) << 0x10 |
            nxt_ptr & 0x7fff;
  }
  else {
    uVar1 = (md & 1) << 0x14 | len << 0x18 | (sn & 1) << 0x13 | (nesn & 1) << 0x12 |
            nxt_ptr & 0x7fff | (llid & 3) << 0x10;
  }
  memw();
  *(uint *)ptr = uVar1;
  memw();
  *(undefined4 *)(ptr + 4) = 0;
  memw();
  memw();
  *(uint *)(ptr + 4) = *(uint *)(ptr + 4) & 0xffff0000 | bufptr & 0xffff;
  return;
}



// WARNING: Unknown calling convention

void rw_le_init_rx_descryptor(u32 ptr,u32 nxt_ptr,u32 bufptr,u32 ralptr)

{
  memw();
  *(undefined4 *)ptr = 0;
  memw();
  *(undefined4 *)(ptr + 4) = 0;
  memw();
  *(undefined4 *)(ptr + 8) = 0;
  memw();
  memw();
  *(uint *)ptr = *(uint *)ptr & 0xffff8000 | nxt_ptr & 0x7fff;
  memw();
  memw();
  *(uint *)(ptr + 8) = *(uint *)(ptr + 8) & 0xffff0000 | bufptr & 0xffff;
  memw();
  memw();
  *(uint *)(ptr + 8) = *(uint *)(ptr + 8) & 0xffff | ralptr << 0x10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_set_current_rxdecriptor(void)

{
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  return;
}



// WARNING: Unknown calling convention

void rw_le_rxstat_unpack(u32 desc_addr,u32 *rxlinklbl,u32 *rxpriverr,u32 *rxtimeerr,
                        u32 *rxbdaddrmatch,u32 *rxnesnerr,u32 *rxsnerr,u32 *rxmicerr,u32 *rxcrcerr,
                        u32 *rxlenerr,u32 *rxtyperr,u32 *rxsyncerr,s8 *rxrssi)

{
  undefined4 uVar1;
  uint uVar2;
  
  memw();
  uVar2 = *(uint *)desc_addr;
  *rxlinklbl = uVar2 >> 0x1b;
  *rxpriverr = uVar2 >> 0x19 & 1;
  *rxtimeerr = uVar2 >> 0x18 & 1;
  *rxbdaddrmatch = uVar2 >> 0x17 & 1;
  *rxsnerr = uVar2 >> 0x15 & 1;
  *rxmicerr = uVar2 >> 0x14 & 1;
  *rxcrcerr = uVar2 >> 0x13 & 1;
  memw();
  uVar1 = *(undefined4 *)(desc_addr + 4);
  *rxlenerr = uVar2 >> 0x12 & 1;
  *rxtyperr = uVar2 >> 0x11 & 1;
  *rxsyncerr = uVar2 >> 0x10 & 1;
  *rxnesnerr = uVar2 >> 0x16 & 1;
  *rxrssi = (s8)((uint)uVar1 >> 0x10);
  return;
}



// WARNING: Unknown calling convention

u32 rw_le_rxdone(u32 desc_addr)

{
  memw();
  return (*(uint *)desc_addr & 0x8000) >> 0xf;
}



// WARNING: Unknown calling convention

void rw_le_rxundone(u32 desc_addr)

{
  memw();
  memw();
  *(uint *)desc_addr = *(uint *)desc_addr & 0xffff7fff;
  return;
}



// WARNING: Unknown calling convention

void rw_le_rx_status_print(u32 desc_addr)

{
  memw();
  memw();
  memw();
  if (((*(uint *)desc_addr & 0x8000) != 0) && ((*(uint *)desc_addr >> 0x10 & 0xff) == 0x80)) {
    phy_printf("rx%3x rssi%d\n",*(uint *)desc_addr >> 0x10 & 0x3ff,
               (int)(char)((uint)*(undefined4 *)(desc_addr + 4) >> 0x10));
    le_rx_n = le_rx_n + 1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_evt_refresh(u32 txdesc_refresh)

{
  memw();
  _DAT_60031218 = _DAT_60031218 | 8;
  memw();
  memw();
  _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
  memw();
  if (txdesc_refresh != 0) {
    memw();
    _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
    memw();
    rw_le_rx_status_print(0x3ffb02c0);
    rw_le_rx_status_print(0x3ffb02d0);
    memw();
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
  }
  evt_refresh_ind = 1;
  return;
}



// WARNING: Unknown calling convention

u32 rw_le_scan_print(u32 desc_addr,u32 filter,u32 rx_adva)

{
  u32 uVar1;
  
  memw();
  memw();
  memw();
  memw();
  uVar1 = 0;
  if ((*(uint *)desc_addr & 0x8000) != 0) {
    if ((*(uint *)desc_addr >> 0x10 & 0x37f) == 0) {
      memw();
      if ((filter == 0) ||
         ((*(uint *)(&DAT_3ffb0000 + (*(uint *)(desc_addr + 8) & 0xffff)) & 0xffffff) == rx_adva)) {
        phy_printf("%d 0x%6x\n",(int)(char)((uint)*(undefined4 *)(desc_addr + 4) >> 0x10));
        uVar1 = 1;
      }
    }
    memw();
    memw();
    *(uint *)desc_addr = *(uint *)desc_addr & 0xffff7fff;
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_evt_refresh(u32 txdesc_refresh)

{
  memw();
  if ((_DAT_60031214 & 8) != 0) {
    rw_evt_refresh(txdesc_refresh);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_scan_refresh(u32 txdesc_refresh,u32 winsz)

{
  memw();
  if ((_DAT_60031214 & 8) != 0) {
    rw_le_scan_refresh(txdesc_refresh,winsz);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_evt_refresh_check_rx(u32 txdesc_refresh)

{
  bool bVar1;
  uint uVar2;
  uint in_a3;
  uint in_a4;
  u32 rssi0;
  uint uVar3;
  
  memw();
  if ((_DAT_60031214 & 8) != 0) {
    memw();
    _DAT_60031218 = _DAT_60031218 | 8;
    memw();
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    if (txdesc_refresh != 0) {
      memw();
      _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
      memw();
      memw();
      _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
      memw();
    }
    evt_refresh_ind = 1;
  }
  uVar2 = 0xdead;
  memw();
  if ((_DAT_3ffb02c0 & 0x8000) != 0) {
    memw();
    memw();
    memw();
    uVar2 = (_DAT_3ffb02c0 & 0x37f0000) >> 0x10;
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    in_a4 = _DAT_3ffb02c4 >> 0x10 & 0xff;
    memw();
  }
  memw();
  if ((_DAT_3ffb02d0 & 0x8000) == 0) {
    uVar3 = 0xdead;
    memw();
    if (uVar2 == 0xdead) {
      return;
    }
    bVar1 = true;
  }
  else {
    memw();
    memw();
    memw();
    uVar3 = (_DAT_3ffb02d0 & 0x37f0000) >> 0x10;
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
    bVar1 = uVar3 != 0;
    in_a3 = _DAT_3ffb02d4 >> 0x10 & 0xff;
    memw();
  }
  if ((uVar2 != 0) && (bVar1)) {
    phy_printf(&DAT_00053118);
    return;
  }
  phy_printf(&DAT_0005311c);
  if (uVar2 == 0) {
    phy_printf(&DAT_00053120,in_a4 - 0x100);
  }
  if (uVar3 == 0) {
    phy_printf(&DAT_00053120,in_a3 - 0x100);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_pktcntl_fsm_print(void)

{
  u32 pktcntl_fsm_data;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffffc0 | 0x82;
  memw();
  memw();
  uVar1 = _DAT_60031254 & 0xf;
  if (pktcntl_fsm_print_start == 0) {
    pktcntl_fsm_print_start = 1;
  }
  else if (uVar1 == pktcntl_fsm_data_last) {
    pktcntl_fsm_data_last = uVar1;
    return;
  }
  switch(uVar1) {
  case 2:
    phy_printf("PC_TXPREAMBLE\n");
    break;
  case 3:
    phy_printf("PC_TXSYNC\n");
    break;
  case 4:
    phy_printf("PC_TXHEADER\n");
    break;
  case 5:
    phy_printf("PC_TXPAYLOAD\n");
    break;
  case 6:
    phy_printf("PC_TXCRC\n");
    break;
  case 7:
    phy_printf("PC_TXSTATUS\n");
    break;
  case 0xf:
    phy_printf("PC_DEAD\n");
  }
  pktcntl_fsm_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_evtschdl_fsm_print(void)

{
  u32 evtschdl_fsm_data;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffffc0 | 0x80;
  memw();
  memw();
  uVar1 = _DAT_60031254 & 7;
  if (evtschdl_fsm_print_start == 0) {
    evtschdl_fsm_print_start = 1;
  }
  else if (uVar1 == evtschdl_fsm_data_last) {
    evtschdl_fsm_data_last = uVar1;
    return;
  }
  switch(uVar1) {
  default:
    phy_printf("ES_IDLE\n");
    break;
  case 1:
    phy_printf("ES_FETCH_MOD_ENTRY\n");
    break;
  case 2:
    phy_printf("ES_FETCH_PTR_ENTRY\n");
    break;
  case 3:
    phy_printf("ES_CHECK_ENTRY\n");
    break;
  case 4:
    phy_printf("ES_UPDATE_ET\n");
    break;
  case 5:
    phy_printf("ES_FETCH_CS_FORMAT\n");
    break;
  case 6:
    phy_printf("ES_FETCH_CS_FCNTOFFSET\n");
    break;
  case 7:
    phy_printf("ES_DEAD\n");
  }
  evtschdl_fsm_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_evtcntl_fsm_print(void)

{
  u32 evtcntl_fsm_data;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffffc0 | 0x81;
  memw();
  memw();
  uVar1 = _DAT_60031254 >> 5 & 7;
  if (evtcntl_fsm_print_start == 0) {
    evtcntl_fsm_print_start = 1;
  }
  else if (uVar1 == evtcntl_fsm_data_last) {
    evtcntl_fsm_data_last = uVar1;
    return;
  }
  switch(uVar1) {
  default:
    phy_printf("EC_IDLE\n");
    break;
  case 1:
    phy_printf("EC_FETCH_CS\n");
    break;
  case 2:
    phy_printf("EC_MASTER\n");
    break;
  case 3:
    phy_printf("EC_SLAVE\n");
    break;
  case 4:
    phy_printf("EC_ISO0MASTER\n");
    break;
  case 5:
    phy_printf("EC_ISO0SLAVE\n");
    break;
  case 6:
    phy_printf("EC_ADVERT\n");
    break;
  case 7:
    phy_printf("EC_SCANINIT\n");
  }
  evtcntl_fsm_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_evtcntladv_fsm_print(void)

{
  u32 evtcntladv_fsm_data;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffffc0 | 0x81;
  memw();
  memw();
  uVar1 = _DAT_60031254 & 0x1f;
  if (evtcntladv_fsm_print_start == 0) {
    evtcntladv_fsm_print_start = 1;
  }
  else if (uVar1 == evtcntladv_fsm_data_last) {
    evtcntladv_fsm_data_last = uVar1;
    return;
  }
  switch(uVar1) {
  case 7:
    phy_printf("ECA_RXCHECK\n");
    break;
  case 9:
    phy_printf("ECA_TXUP1\n");
    break;
  case 10:
    phy_printf("ECA_IFS2\n");
    break;
  case 0xb:
    phy_printf("ECA_TXRESP\n");
    break;
  case 0xc:
    phy_printf("ECA_TXUP2\n");
    break;
  case 0xe:
    phy_printf("ECA_ERROR\n");
  }
  evtcntladv_fsm_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_error_print(void)

{
  u32 le_error_data;
  uint uVar1;
  
  memw();
  uVar1 = _DAT_60031260 & 0x3fffff;
  if (le_error_print_start == 0) {
    le_error_print_start = 1;
  }
  else if (uVar1 == le_error_data_last) {
    le_error_data_last = uVar1;
    return;
  }
  phy_printf("error%x\n",uVar1);
  le_error_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_rx_per_syncw_service_polling(void)

{
  u32 rw_rxlenerr;
  u32 rw_rxtyperr;
  u32 rw_rxsnerr;
  u32 rw_rxnesnerr;
  u32 rw_rxbdaddrmatch;
  u32 rw_rxtimeerr;
  u32 rw_rxpriverr;
  u32 rw_rxsyncerr;
  u32 rw_rxcrcerr;
  u32 rw_rxmicerr;
  u32 rw_rxlinklbl;
  s8 rw_rxrssi;
  
  rw_rxlinklbl = 0;
  rw_rxmicerr = 0;
  rw_rxcrcerr = 0;
  rw_rxsyncerr = 0;
  rw_rxpriverr = 0;
  rw_rxtimeerr = 0;
  rw_rxbdaddrmatch = 0;
  rw_rxnesnerr = 0;
  rw_rxsnerr = 0;
  rw_rxtyperr = 0;
  rw_rxlenerr = 0;
  rw_rxrssi = '\0';
  rw_le_error_print();
  rw_bb_rx_refesh();
  memw();
  if ((_DAT_3ffb02c0 & 0x8000) != 0) {
    rw_le_rxstat_unpack(0x3ffb02c0,&rw_rxlinklbl,&rw_rxpriverr,&rw_rxtimeerr,&rw_rxbdaddrmatch,
                        &rw_rxnesnerr,&rw_rxsnerr,&rw_rxmicerr,&rw_rxcrcerr,&rw_rxlenerr,
                        &rw_rxtyperr,&rw_rxsyncerr,&rw_rxrssi);
    memw();
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    memw();
    if (rw_rxsyncerr == 0) {
      if (rw_rxtyperr == 0) {
        if (rw_rxlenerr == 0) {
          if (rw_rxcrcerr != 0) {
            crc_ep_polling = crc_ep_polling + 1;
LAB_00015508:
            total_rssi_polling = rw_rxrssi + total_rssi_polling;
            total_p_polling = total_p_polling + 1;
            memw();
            total_inband_polling = total_inband_polling + (char)_DAT_3ff51074;
            total_fullband_polling = total_fullband_polling >> 0x18;
            memw();
            memw();
            total_gain_polling = (_DAT_3ff51078 & 0xff0000) + total_gain_polling >> 0x10;
            goto LAB_00015419;
          }
          if (rw_rxmicerr == 0) {
            if (rw_rxsnerr == 0) {
              if (rw_rxnesnerr == 0) {
                if (rw_rxtimeerr == 0) {
                  if (rw_rxpriverr == 0) {
                    cp_polling = cp_polling + 1;
                    goto LAB_00015508;
                  }
                  priv_ep_polling = priv_ep_polling + 1;
                }
                else {
                  time_ep_polling = time_ep_polling + 1;
                }
              }
              else {
                nesn_ep_polling = nesn_ep_polling + 1;
              }
            }
            else {
              sn_ep_polling = sn_ep_polling + 1;
            }
          }
          else {
            mic_ep_polling = mic_ep_polling + 1;
          }
        }
        else {
          len_ep_polling = len_ep_polling + 1;
        }
      }
      else {
        type_ep_polling = type_ep_polling + 1;
      }
      total_p_polling = total_p_polling + 1;
    }
  }
LAB_00015419:
  memw();
  if ((_DAT_3ffb02d0 & 0x8000) != 0) {
    rw_le_rxstat_unpack(0x3ffb02d0,&rw_rxlinklbl,&rw_rxpriverr,&rw_rxtimeerr,&rw_rxbdaddrmatch,
                        &rw_rxnesnerr,&rw_rxsnerr,&rw_rxmicerr,&rw_rxcrcerr,&rw_rxlenerr,
                        &rw_rxtyperr,&rw_rxsyncerr,&rw_rxrssi);
    memw();
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
    if (rw_rxsyncerr == 0) {
      if (rw_rxtyperr == 0) {
        if (rw_rxlenerr == 0) {
          if (rw_rxcrcerr != 0) {
            crc_ep_polling = crc_ep_polling + 1;
LAB_0001556c:
            total_rssi_polling = rw_rxrssi + total_rssi_polling;
            total_p_polling = total_p_polling + 1;
            memw();
            total_inband_polling = total_inband_polling + (char)_DAT_3ff51074;
            memw();
            memw();
            total_fullband_polling = total_fullband_polling >> 0x18;
            total_gain_polling = (_DAT_3ff51078 & 0xff0000) + total_gain_polling >> 0x10;
            return;
          }
          if (rw_rxmicerr == 0) {
            if (rw_rxsnerr == 0) {
              if (rw_rxnesnerr == 0) {
                if (rw_rxtimeerr == 0) {
                  if (rw_rxpriverr == 0) {
                    cp_polling = cp_polling + 1;
                    goto LAB_0001556c;
                  }
                  priv_ep_polling = priv_ep_polling + 1;
                }
                else {
                  time_ep_polling = time_ep_polling + 1;
                }
              }
              else {
                nesn_ep_polling = nesn_ep_polling + 1;
              }
            }
            else {
              sn_ep_polling = sn_ep_polling + 1;
            }
          }
          else {
            mic_ep_polling = mic_ep_polling + 1;
          }
        }
        else {
          len_ep_polling = len_ep_polling + 1;
        }
      }
      else {
        type_ep_polling = type_ep_polling + 1;
      }
      total_p_polling = total_p_polling + 1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void rw_fill_adv_buf(u32 ptr)

{
  memw();
  *(u32 *)ptr = ADV_payload[0];
  return;
}



// WARNING: Unknown calling convention

void rw_fill_scanrsp_buf(u32 ptr)

{
  memw();
  *(u32 *)ptr = SCAN_RSP_payload[0];
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_adv_init(u32 tx_desc0,u32 tx_desc1,u32 format,u32 bdaddrl,u32 bdaddrh,u32 interval)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_60031228 = _DAT_60031228 & 0xffff0000 | bdaddrh & 0xffff | 0x10000;
  memw();
  memw();
  _DAT_600312a0 = _DAT_600312a0 & 0xffffc000 | interval & 0x3fff;
  memw();
  _DAT_60031224 = bdaddrl;
  rw_le_init_cs(format,0x8e89bed6,0x555555,0,0,0,2,0x27,0xb,1,4,0,200,tx_desc0,0);
  memw();
  *(u32 *)tx_desc0 = tx_desc1 & 0x7fff | 0x14400000;
  memw();
  *(undefined4 *)(tx_desc0 + 4) = 0;
  memw();
  memw();
  *(uint *)(tx_desc0 + 4) = *(uint *)(tx_desc0 + 4) & 0xffff0000 | 0x300;
  memw();
  *(u32 *)tx_desc1 = tx_desc0 & 0x7fff | 0x18440000;
  memw();
  *(undefined4 *)(tx_desc1 + 4) = 0;
  memw();
  memw();
  *(uint *)(tx_desc1 + 4) = *(uint *)(tx_desc1 + 4) & 0xffff0000 | 0x400;
  memw();
  _DAT_3ffb0300 = ADV_payload[0];
  memw();
  _DAT_3ffb0400 = SCAN_RSP_payload[0];
  memw();
  _DAT_3ffb0404 = SCAN_RSP_payload[1];
  memw();
  _DAT_3ffb0408 = SCAN_RSP_payload[2];
  memw();
  _DAT_3ffb040c = SCAN_RSP_payload[3];
  memw();
  _DAT_3ffb0410 = SCAN_RSP_payload[4];
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_advscan_init(u32 tx_desc0,u32 format,u32 bdaddrl,u32 bdaddrh,u32 interval)

{
  u32 data0;
  
  memw();
  memw();
  memw();
  memw();
  _DAT_60031228 = _DAT_60031228 & 0xffff0000 | bdaddrh & 0xffff | 0x10000;
  memw();
  memw();
  _DAT_600312a0 = _DAT_600312a0 & 0xffffc000 | interval & 0x3fff;
  memw();
  _DAT_60031224 = bdaddrl;
  rw_le_init_cs(format,0x8e89bed6,0x555555,0,0,0,0,0x27,0xb,0,4,1,8000,tx_desc0,8000);
  memw();
  *(u32 *)tx_desc0 = tx_desc0 & 0x7fff | 0xc430000;
  memw();
  *(undefined4 *)(tx_desc0 + 4) = 0;
  memw();
  memw();
  *(uint *)(tx_desc0 + 4) = *(uint *)(tx_desc0 + 4) & 0xffff0000 | 0x300;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_test_init(u32 tx_desc0,u32 tx_desc1,u32 format,u32 bdaddrl,u32 bdaddrh,u32 interval,
                    u32 freq,u32 txpwr,u32 rxwide,u32 rxwinsz)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_60031228 = _DAT_60031228 & 0xffff0000 | bdaddrh & 0xffff | 0x10000;
  memw();
  memw();
  _DAT_600312a0 = _DAT_600312a0 & 0xffffc000 | interval & 0x3fff;
  memw();
  _DAT_60031224 = bdaddrl;
  rw_le_init_cs(format,0x8e89bed6,0x555555,0,0,0,2,freq,0xb,0,txpwr,rxwide,rxwinsz,tx_desc0,200);
  memw();
  memw();
  _DAT_60031200 = _DAT_60031200 | 0x40000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_adv(void)

{
  phy_printf("\n\n\nRW LE ADV\n");
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_le_et_init();
  rw_le_adv_init(0x3ffb02a0,0x3ffb02b0,5,0xdeadbeef,0xffee,2000);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  phy_printf("RW LE CORE ON\n");
  do {
    do {
      rw_le_error_print();
      memw();
    } while ((_DAT_60031214 & 8) == 0);
    rw_evt_refresh(1);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_advscan(void)

{
  phy_printf("\n\n\nRW LE ADVSCAN\n");
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_le_et_init();
  rw_le_advscan_init(0x3ffb02a0,9,0xdeadbeef,0xffee,2000);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  phy_printf("RW LE CORE ON\n");
  do {
    do {
      rw_le_error_print();
      rw_le_scan_print(0x3ffb02c0,1,0xadbeef);
      memw();
    } while ((_DAT_60031214 & 8) == 0);
    rw_le_scan_refresh(1,4000);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_advscan_test_init(void)

{
  phy_printf("\n\n\nRW LE ADVSCAN\n");
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_le_et_init();
  rw_le_advscan_init(0x3ffb02a0,9,0xdeadbeef,0xffee,2000);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  phy_printf("RW LE CORE ON\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_adv_test_init(void)

{
  phy_printf("\n\n\nRW LE ADV\n");
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_le_et_init();
  rw_le_adv_init(0x3ffb02a0,0x3ffb02b0,5,0xdeadbeef,0xffee,2000);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void freq_print(void)

{
  memw();
  if ((_DAT_3ff51030 & 0x200) != 0) {
    memw();
    _DAT_3ff51038 = _DAT_3ff51038 & 0xfffffdff;
    memw();
    memw();
    memw();
    phy_printf("MEM_RDATA: %d, 0x%x\n",_DAT_3ff4e0c0,_DAT_3ff4e3fc);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void hoppe_print(void)

{
  memw();
  if ((_DAT_3ff51030 & 0x10000000) != 0) {
    memw();
    _DAT_3ff51038 = _DAT_3ff51038 & 0xefffffff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_tx(u32 freqa,u32 freqb,u32 freqc,u32 txpwr,u32 mask)

{
  u32 uVar1;
  STATUS SVar2;
  u32 uVar3;
  
  phy_printf("LE TX\n");
  prbs9_gen(PRBS9);
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  memw();
  if ((mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000302;
  }
  rw_le_test_init(0x3ffb02a0,0x3ffb02b0,2,0xdeadbeef,0xffee,2000,freqa,txpwr,0,0xf);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_3ffb0300 = PRBS9[0];
  memw();
  _DAT_3ffb02a0 = 0x1e0002b0;
  memw();
  memw();
  memw();
  _DAT_3ffb02a4 = 0x300;
  memw();
  _DAT_3ffb02b0 = 0x1e0002a0;
  memw();
  memw();
  memw();
  _DAT_3ffb02b4 = 0x300;
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  uVar3 = freqa;
  do {
    rw_le_error_print();
    memw();
    if ((_DAT_60031214 & 8) != 0) {
      rw_evt_refresh(1);
    }
    if (evt_refresh_ind != 0) {
      evt_refresh_ind = 0;
      uVar1 = freqb;
      if ((uVar3 != freqa) && (uVar1 = freqc, uVar3 != freqb)) {
        uVar1 = freqa;
      }
      uVar3 = uVar1;
      memw();
      _DAT_3ffb0210 = _DAT_3ffb0210 & 0xffffffc0 | uVar3 & 0x3f;
      memw();
    }
    SVar2 = GetStopCmd();
  } while (SVar2 != OK);
  phy_printf("rw done!\n");
  rw_le_core_off();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_tx_nohoppe(u32 freq,u32 txpwr,u32 mask,u32 len,u32 data_type,u32 tx_num_in)

{
  STATUS SVar1;
  
  phy_printf("LE TX NHP\n");
  prbs9_gen(PRBS9);
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  memw();
  if ((mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000302;
  }
  rw_le_test_init(0x3ffb02a0,0x3ffb02b0,2,0xdeadbeef,0xffee,2000,freq,txpwr,0,0xf);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  if (data_type == 0) {
    memw();
    _DAT_3ffb0300 = 0x55555555;
  }
  else if (data_type == 1) {
    memw();
    _DAT_3ffb0300 = 0xf0f0f0f0;
  }
  else {
    _DAT_3ffb0300 = PRBS9[0];
    memw();
  }
  _DAT_3ffb02a0 = len << 0x18 | 0x2b0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02a4 = 0x300;
  _DAT_3ffb02b0 = len << 0x18 | 0x2a0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02b4 = 0x300;
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  bt_tx_num = 0;
  while( true ) {
    rw_txpwr_regulate();
    memw();
    if ((_DAT_60031214 & 8) != 0) {
      rw_evt_refresh(1);
    }
    rw_bb_tx_refesh();
    SVar1 = GetStopCmd();
    if (SVar1 == OK) break;
    if ((tx_num_in != 0) && (tx_num_in <= bt_tx_num)) {
      rw_le_core_off();
      return;
    }
  }
  phy_printf("rw done!\n");
  rw_le_core_off();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram
// WARNING: Unknown calling convention

void rw_le_tx_nohoppe_syncw
               (u32 freq,u32 txpwr,u32 mask,u32 len,u32 data_type,u32 syncw,u32 tx_num_in)

{
  STATUS SVar1;
  
  phy_printf("LE TX NHP\n");
  prbs9_gen(PRBS9);
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  memw();
  if ((mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000302;
  }
  rw_le_test_init(0x3ffb02a0,0x3ffb02b0,0x1c,0xdeadbeef,0xffee,2000,freq,txpwr,0,0xf);
  memw();
  _DAT_3ffb0204 = _DAT_3ffb0204 & 0xffff | syncw << 0x10;
  memw();
  memw();
  _DAT_3ffb0208 = _DAT_3ffb0208 & 0xffff0000 | syncw >> 0x10;
  memw();
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  if (data_type == 0) {
    memw();
    _DAT_3ffb0300 = 0x55555555;
    _DAT_3ffb02b0 = 0x20000;
  }
  else if (data_type == 1) {
    memw();
    _DAT_3ffb0300 = 0xf0f0f0f0;
    _DAT_3ffb02b0 = 0x10000;
  }
  else {
    memw();
    _DAT_3ffb0300 = PRBS9[0];
    _DAT_3ffb02b0 = 0;
  }
  _DAT_3ffb02a0 = len << 0x18 | 0x2b0 | _DAT_3ffb02b0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02a4 = 0x300;
  _DAT_3ffb02b0 = len << 0x18 | 0x2a0 | _DAT_3ffb02b0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02b4 = 0x300;
  memw();
  _DAT_600312e0 = _DAT_600312e0 & 0xffffdfff;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  bt_tx_num = 0;
  while( true ) {
    rw_txpwr_regulate();
    memw();
    if ((_DAT_60031214 & 8) != 0) {
      rw_evt_refresh(1);
    }
    rw_bb_tx_refesh();
    SVar1 = GetStopCmd();
    if (SVar1 == OK) break;
    if ((tx_num_in != 0) && (tx_num_in <= bt_tx_num)) {
      rw_le_core_off();
      return;
    }
  }
  phy_printf("rw done syncw!\n");
  rw_le_core_off();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram
// WARNING: Unknown calling convention

void rw_le_tx_hoppe_syncw(u32 txpwr,u32 mask,u32 len,u32 data_type,u32 syncw)

{
  uint uVar1;
  STATUS SVar2;
  uint uVar3;
  uint uVar4;
  
  phy_printf("LE TX HP\n");
  prbs9_gen(PRBS9);
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  memw();
  if ((mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000302;
  }
  rw_le_test_init(0x3ffb02a0,0x3ffb02b0,0x1c,0xdeadbeef,0xffee,2000,0,txpwr,0,0xf);
  memw();
  _DAT_3ffb0204 = _DAT_3ffb0204 & 0xffff | syncw << 0x10;
  memw();
  memw();
  _DAT_3ffb0208 = _DAT_3ffb0208 & 0xffff0000 | syncw >> 0x10;
  memw();
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  if (data_type == 0) {
    memw();
    _DAT_3ffb0300 = 0x55555555;
    _DAT_3ffb02b0 = 0x20000;
  }
  else if (data_type == 1) {
    memw();
    _DAT_3ffb0300 = 0xf0f0f0f0;
    _DAT_3ffb02b0 = 0x10000;
  }
  else {
    memw();
    _DAT_3ffb0300 = PRBS9[0];
    _DAT_3ffb02b0 = 0;
  }
  _DAT_3ffb02a0 = len << 0x18 | 0x2b0 | _DAT_3ffb02b0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02a4 = 0x300;
  _DAT_3ffb02b0 = len << 0x18 | 0x2a0 | _DAT_3ffb02b0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02b4 = 0x300;
  memw();
  _DAT_600312e0 = _DAT_600312e0 & 0xffffdfff;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  uVar1 = 0;
  uVar3 = 0;
  while( true ) {
    memw();
    if ((_DAT_60031214 & 8) != 0) {
      rw_evt_refresh(1);
    }
    if (evt_refresh_ind != 0) {
      evt_refresh_ind = 0;
      if (uVar1 == 0x27) {
        uVar1 = 0;
        uVar4 = 0;
      }
      else {
        uVar1 = uVar1 + 1;
        uVar4 = uVar1 & 0x3f;
      }
      memw();
      _DAT_3ffb0210 = _DAT_3ffb0210 & 0xffffffc0 | uVar4;
      memw();
    }
    SVar2 = GetStopCmd();
    uVar3 = uVar3 + 1;
    if (SVar2 == OK) break;
    if (10000 < uVar3) {
      memw();
      uVar3 = 0;
      _DAT_60031200 = _DAT_60031200 | 0x4000000;
      memw();
    }
  }
  phy_printf("rw done syncw!\n");
  rw_le_core_off();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_tx_nohoppe_init(u32 freq,u32 txpwr,u32 mask,u32 len)

{
  phy_printf("LE TX NHP\n");
  prbs9_gen(PRBS9);
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  memw();
  if ((mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000302;
  }
  rw_le_test_init(0x3ffb02a0,0x3ffb02b0,2,0xdeadbeef,0xffee,2000,freq,txpwr,0,0xf);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_3ffb0300 = PRBS9[0];
  _DAT_3ffb02a0 = len << 0x18 | 0x2b0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02a4 = 0x300;
  _DAT_3ffb02b0 = len << 0x18 | 0x2a0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02b4 = 0x300;
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  return;
}



// WARNING: Unknown calling convention

void fcc_le_tx(u32 txpwr,u32 chan,u32 len,u32 data_type,u32 tx_num_in)

{
  u32 freq;
  
  freq = 0x25;
  if (chan != 0) {
    if (chan == 0xc) {
      freq = 0x26;
    }
    else if (chan == 0x27) {
      freq = 0x27;
    }
    else {
      freq = chan - 1;
      if ((0xb < chan) && (freq = 0, chan < 0x27)) {
        freq = chan - 2;
      }
    }
  }
  rw_le_tx_nohoppe(freq,txpwr,0xffff,len,data_type,tx_num_in);
  return;
}



// WARNING: Unknown calling convention

void fcc_le_tx_syncw(u32 txpwr,u32 chan,u32 len,u32 data_type,u32 syncw,u32 tx_num_in)

{
  u32 freq;
  
  freq = 0x25;
  if (chan != 0) {
    if (chan == 0xc) {
      freq = 0x26;
    }
    else if (chan == 0x27) {
      freq = 0x27;
    }
    else {
      freq = chan - 1;
      if ((0xb < chan) && (freq = 0, chan < 0x27)) {
        freq = chan - 2;
      }
    }
  }
  rw_le_tx_nohoppe_syncw(freq,txpwr,0xffff,len,data_type,syncw,tx_num_in);
  return;
}



// WARNING: Removing unreachable block (ram,0x000170c1)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_rx_per(u32 chan)

{
  STATUS SVar1;
  uint *puVar2;
  int iVar3;
  u32 rw_rxlenerr;
  u32 rw_rxtyperr;
  u32 rw_rxsnerr;
  u32 rw_rxnesnerr;
  u32 rw_rxbdaddrmatch;
  u32 rw_rxtimeerr;
  u32 rw_rxpriverr;
  u32 rw_rxsyncerr;
  u32 rw_rxcrcerr;
  u32 rw_rxmicerr;
  u32 rw_rxlinklbl;
  s8 rw_rxrssi;
  int iStack_90;
  int iStack_8c;
  int iStack_88;
  int iStack_84;
  int iStack_80;
  int iStack_7c;
  int iStack_78;
  int iStack_74;
  int iStack_70;
  int iStack_6c;
  int iStack_68;
  int iStack_64;
  int iStack_60;
  int iStack_5c;
  int iStack_58;
  uint uStack_54;
  uint uStack_50;
  uint uStack_4c;
  int iStack_48;
  int iStack_44;
  int iStack_40;
  int iStack_3c;
  int iStack_38;
  int iStack_34;
  int iStack_30;
  uint uStack_2c;
  
  memw();
  _DAT_3ff51098 = _DAT_3ff51098 | 0xc0000000;
  memw();
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  memw();
  memw();
  _DAT_3ffb0000 = 0x2000302;
  memw();
  _DAT_60031224 = 0xdeadbeef;
  memw();
  memw();
  memw();
  _DAT_60031228 = _DAT_60031228 & 0xffff0000 | 0x10000;
  memw();
  memw();
  _DAT_600312a0 = _DAT_600312a0 & 0xffffc000 | 0x5dc;
  memw();
  memw();
  _DAT_60031200 = _DAT_60031200 | 0x40000;
  memw();
  rw_le_init_cs(0x1d,0x71764129,0x555555,0,0,0,0,chan,0xb,0,0,1,0x3fff,0,0);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0xc000b00;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_600312f0 = _DAT_600312f0 & 0x7fffffff;
  memw();
  memw();
  _DAT_600312e0 = _DAT_600312e0 | 0x8000000;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 8;
  memw();
  rw_le_core_on();
  phy_printf("RW RX PER\n");
  rw_rxlinklbl = 0;
  rw_rxmicerr = 0;
  rw_rxcrcerr = 0;
  rw_rxsyncerr = 0;
  rw_rxpriverr = 0;
  rw_rxtimeerr = 0;
  rw_rxbdaddrmatch = 0;
  rw_rxnesnerr = 0;
  rw_rxsnerr = 0;
  rw_rxtyperr = 0;
  rw_rxlenerr = 0;
  rw_rxrssi = '\0';
  ets_delay_us(0x14);
  iStack_90 = 0;
  iStack_30 = 0;
  iStack_34 = 0;
  iStack_38 = 0;
  iStack_5c = 0;
  iStack_60 = 0;
  iStack_64 = 0;
  iStack_68 = 0;
  iStack_6c = 0;
  iStack_70 = 0;
  iStack_74 = 0;
  iStack_78 = 0;
  iStack_3c = 0;
  iStack_48 = 0;
  iStack_58 = 0;
  iStack_40 = 0;
  iStack_44 = 0;
  iStack_7c = 0;
  iStack_80 = 0;
  iStack_84 = 0;
  iStack_88 = 0;
  iStack_8c = 0;
  do {
    while (memw(), (_DAT_60031214 & 8) == 0) {
      rw_bb_rx_refesh();
      SVar1 = GetStopCmd();
      if ((SVar1 == BUSY) || (SVar1 == OK)) {
        memw();
        iStack_8c = 1;
        _DAT_60031200 = _DAT_60031200 | 0x4000000;
        memw();
      }
      memw();
      if (((_DAT_3ffb02c0 & 0x8000) != 0) || (memw(), (_DAT_3ffb02d0 & 0x8000) != 0)) {
        memw();
        if ((_DAT_3ffb02c0 & 0x8000) != 0) {
          rw_le_rxstat_unpack(0x3ffb02c0,&rw_rxlinklbl,&rw_rxpriverr,&rw_rxtimeerr,&rw_rxbdaddrmatch
                              ,&rw_rxnesnerr,&rw_rxsnerr,&rw_rxmicerr,&rw_rxcrcerr,&rw_rxlenerr,
                              &rw_rxtyperr,&rw_rxsyncerr,&rw_rxrssi);
          memw();
          _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
          memw();
        }
        memw();
        if ((_DAT_3ffb02d0 & 0x8000) != 0) {
          rw_le_rxstat_unpack(0x3ffb02d0,&rw_rxlinklbl,&rw_rxpriverr,&rw_rxtimeerr,&rw_rxbdaddrmatch
                              ,&rw_rxnesnerr,&rw_rxsnerr,&rw_rxmicerr,&rw_rxcrcerr,&rw_rxlenerr,
                              &rw_rxtyperr,&rw_rxsyncerr,&rw_rxrssi);
          memw();
          _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
          memw();
        }
        if (rw_rxsyncerr == 0) {
          if (rw_rxtyperr == 0) {
            if (rw_rxlenerr == 0) {
              if (rw_rxcrcerr == 0) {
                if (rw_rxmicerr == 0) {
                  if (rw_rxsnerr == 0) {
                    if (rw_rxnesnerr == 0) {
                      if (rw_rxtimeerr == 0) {
                        if (rw_rxpriverr == 0) {
                          iStack_44 = iStack_44 + 1;
                        }
                        else {
                          iStack_90 = iStack_90 + 1;
                        }
                      }
                      else {
                        iStack_30 = iStack_30 + 1;
                      }
                    }
                    else {
                      iStack_34 = iStack_34 + 1;
                    }
                  }
                  else {
                    iStack_38 = iStack_38 + 1;
                  }
                }
                else {
                  iStack_3c = iStack_3c + 1;
                }
              }
              else {
                iStack_40 = iStack_40 + 1;
              }
            }
            else {
              iStack_48 = iStack_48 + 1;
            }
          }
          else {
            iStack_58 = iStack_58 + 1;
          }
          memw();
          uStack_2c = _DAT_3ff51050 >> 6 & 1;
          memw();
          memw();
          memw();
          uStack_50 = _DAT_3ff51050 >> 5 & 1;
          uStack_4c = _DAT_3ff51050 >> 4 & 1;
          uStack_54 = _DAT_3ff51078;
          iStack_7c = iStack_7c + 1;
          iStack_78 = iStack_78 + (_DAT_3ff51050 >> 7 & 1);
          iStack_74 = iStack_74 + uStack_2c;
          iStack_70 = iStack_70 + uStack_50;
          iStack_64 = iStack_64 + uStack_4c;
          iStack_68 = iStack_68 + (uint)((_DAT_3ff51050 & 2) != 0);
          iStack_6c = iStack_6c + (uint)((_DAT_3ff51050 & 8) != 0);
          iStack_60 = iStack_60 + (uint)((_DAT_3ff51050 & 4) != 0);
          iStack_5c = iStack_5c + (_DAT_3ff51050 & 1);
          iStack_88 = iStack_88 + (0x100 - (_DAT_3ff51074 & 0xff));
          iStack_84 = iStack_84 + (0x100 - (_DAT_3ff51078 >> 0x18));
          iStack_80 = iStack_80 + (_DAT_3ff51078 >> 0x10 & 0xff);
        }
      }
    }
    memw();
    puVar2 = (uint *)&DAT_3ffb0000;
    _DAT_60031218 = _DAT_60031218 | 8;
    memw();
    iVar3 = 0x10;
    do {
      memw();
      memw();
      *puVar2 = *puVar2 & 0xffffffcf;
      puVar2 = puVar2 + 1;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
  } while (iStack_8c == 0);
  rw_le_core_off();
  phy_printf("%x %x %x %x %x %x %x %x %x %x w %x %x %x %x %x %x %x %x p %x %x %x\n",iStack_7c,
             iStack_44,iStack_58,iStack_48,iStack_40,iStack_3c,iStack_38,iStack_34,iStack_30,
             iStack_90,iStack_78,iStack_74,iStack_68,iStack_6c,iStack_70,iStack_5c,iStack_60,
             iStack_64,iStack_88,iStack_84,iStack_80);
  return;
}



// WARNING: Unknown calling convention

bool esp_get_lerx_result(int32 *rx_result)

{
  bool bVar1;
  
  *rx_result = esp_rx_result[0];
  bVar1 = esp_rx_valid;
  rx_result[1] = esp_rx_result[1];
  rx_result[2] = esp_rx_result[2];
  return bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void get_bt_rx_rssi(u32 *pwr_in_band,u32 *gain,u32 *pwr_full_band,u32 total_p)

{
  if (total_p != 0) {
    bt_rx_rssi = -((*pwr_in_band + *gain) / total_p);
    memw();
    if ((bt_2480_opt_en) && ((_DAT_3ff5c0d0 & 0x1ff) == 0x1ec)) {
      *pwr_in_band = *pwr_in_band + total_p * 10;
      *pwr_full_band = *pwr_full_band + total_p * 10;
      *gain = *gain + total_p * -10;
    }
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x00017791)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_rx_per_syncw(u32 chan,u32 syncw)

{
  bool bVar1;
  STATUS SVar2;
  int iVar3;
  u32 rw_rxlenerr;
  u32 rw_rxtyperr;
  u32 rw_rxsnerr;
  u32 rw_rxnesnerr;
  u32 rw_rxbdaddrmatch;
  u32 rw_rxtimeerr;
  u32 rw_rxpriverr;
  u32 rw_rxsyncerr;
  u32 rw_rxcrcerr;
  u32 rw_rxmicerr;
  u32 rw_rxlinklbl;
  u32 gain;
  u32 pwr_full_band;
  u32 pwr_in_band;
  s8 rw_rxrssi;
  u32 uStack_70;
  int32 iStack_6c;
  int iStack_68;
  int iStack_64;
  int iStack_60;
  int iStack_5c;
  int iStack_58;
  int iStack_54;
  int iStack_50;
  int iStack_4c;
  int iStack_48;
  int iStack_44;
  int iStack_40;
  int iStack_3c;
  int iStack_38;
  int iStack_34;
  int iStack_30;
  uint uStack_28;
  
  memw();
  pwr_in_band = 0;
  pwr_full_band = 0;
  gain = 0;
  _DAT_3ff51098 = _DAT_3ff51098 | 0xc0000000;
  memw();
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  memw();
  memw();
  _DAT_3ffb0000 = 0x2000302;
  memw();
  _DAT_60031224 = 0xdeadbeef;
  memw();
  memw();
  memw();
  _DAT_60031228 = _DAT_60031228 & 0xffff0000 | 0x10000;
  memw();
  memw();
  _DAT_600312a0 = _DAT_600312a0 & 0xffffc000 | 0x5dc;
  memw();
  memw();
  _DAT_60031200 = _DAT_60031200 | 0x40000;
  memw();
  rw_le_init_cs(0x1d,syncw,0x555555,0,0,0,0,chan,0xb,0,0,1,0x3fff,0,0);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0xc000b00;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_600312f0 = _DAT_600312f0 & 0x7fffffff;
  memw();
  memw();
  _DAT_600312e0 = _DAT_600312e0 | 0x8000000;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 8;
  memw();
  rw_le_core_on();
  phy_printf("RW RX PER\n");
  rw_rxlinklbl = 0;
  rw_rxmicerr = 0;
  rw_rxcrcerr = 0;
  rw_rxsyncerr = 0;
  rw_rxpriverr = 0;
  rw_rxtimeerr = 0;
  rw_rxbdaddrmatch = 0;
  rw_rxnesnerr = 0;
  rw_rxsnerr = 0;
  rw_rxtyperr = 0;
  rw_rxlenerr = 0;
  rw_rxrssi = '\0';
  ets_delay_us(0x14);
  iVar3 = 0;
  iStack_30 = 0;
  iStack_34 = 0;
  iStack_38 = 0;
  iStack_4c = 0;
  iStack_50 = 0;
  iStack_54 = 0;
  iStack_58 = 0;
  iStack_5c = 0;
  iStack_60 = 0;
  iStack_64 = 0;
  iStack_68 = 0;
  iStack_3c = 0;
  iStack_44 = 0;
  iStack_48 = 0;
  iStack_40 = 0;
  uStack_70 = 0;
  iStack_6c = 0;
LAB_00017be0:
  do {
    memw();
    if ((_DAT_60031214 & 8) == 0) {
      rw_bb_rx_refesh();
      SVar2 = GetStopCmd();
      if ((SVar2 != BUSY) && (SVar2 != OK)) {
        memw();
        if (((_DAT_3ffb02c0 & 0x8000) != 0) || (memw(), (_DAT_3ffb02d0 & 0x8000) != 0)) {
          memw();
          if ((_DAT_3ffb02c0 & 0x8000) != 0) {
            rw_le_rxstat_unpack(0x3ffb02c0,&rw_rxlinklbl,&rw_rxpriverr,&rw_rxtimeerr,
                                &rw_rxbdaddrmatch,&rw_rxnesnerr,&rw_rxsnerr,&rw_rxmicerr,
                                &rw_rxcrcerr,&rw_rxlenerr,&rw_rxtyperr,&rw_rxsyncerr,&rw_rxrssi);
            memw();
            _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
            memw();
          }
          memw();
          if ((_DAT_3ffb02d0 & 0x8000) != 0) {
            rw_le_rxstat_unpack(0x3ffb02d0,&rw_rxlinklbl,&rw_rxpriverr,&rw_rxtimeerr,
                                &rw_rxbdaddrmatch,&rw_rxnesnerr,&rw_rxsnerr,&rw_rxmicerr,
                                &rw_rxcrcerr,&rw_rxlenerr,&rw_rxtyperr,&rw_rxsyncerr,&rw_rxrssi);
            memw();
            _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
            memw();
          }
          if (rw_rxsyncerr == 0) {
            if (rw_rxtyperr == 0) {
              if (rw_rxlenerr == 0) {
                if (rw_rxcrcerr == 0) {
                  if (rw_rxmicerr == 0) {
                    if (rw_rxsnerr == 0) {
                      if (rw_rxnesnerr == 0) {
                        if (rw_rxtimeerr == 0) {
                          if (rw_rxpriverr == 0) {
                            memw();
                            memw();
                            memw();
                            pwr_full_band = (pwr_full_band + 0x100) - (_DAT_3ff51078 >> 0x18);
                            gain = gain + (_DAT_3ff51078 >> 0x10 & 0xff);
                            pwr_in_band = (pwr_in_band + 0x100) - (_DAT_3ff51074 & 0xff);
                            uStack_70 = uStack_70 + 1;
                          }
                          else {
                            iVar3 = iVar3 + 1;
                          }
                        }
                        else {
                          iStack_30 = iStack_30 + 1;
                        }
                      }
                      else {
                        iStack_34 = iStack_34 + 1;
                      }
                    }
                    else {
                      iStack_38 = iStack_38 + 1;
                    }
                  }
                  else {
                    iStack_3c = iStack_3c + 1;
                  }
                }
                else {
                  iStack_40 = iStack_40 + 1;
                }
              }
              else {
                iStack_44 = iStack_44 + 1;
              }
            }
            else {
              iStack_48 = iStack_48 + 1;
            }
            memw();
            uStack_28 = _DAT_3ff51050 >> 4 & 1;
            iStack_6c = iStack_6c + 1;
            iStack_68 = iStack_68 + (_DAT_3ff51050 >> 7 & 1);
            iStack_64 = iStack_64 + (_DAT_3ff51050 >> 6 & 1);
            iStack_60 = iStack_60 + (_DAT_3ff51050 >> 5 & 1);
            iStack_54 = iStack_54 + uStack_28;
            iStack_5c = iStack_5c + (uint)((_DAT_3ff51050 & 8) != 0);
            iStack_50 = iStack_50 + (uint)((_DAT_3ff51050 & 4) != 0);
            iStack_58 = iStack_58 + (uint)((_DAT_3ff51050 & 2) != 0);
            iStack_4c = iStack_4c + (_DAT_3ff51050 & 1);
          }
        }
        goto LAB_00017be0;
      }
      memw();
      bVar1 = true;
      _DAT_60031200 = _DAT_60031200 | 0x4000000;
      memw();
    }
    else {
      bVar1 = false;
    }
    memw();
    _DAT_60031218 = _DAT_60031218 | 8;
    memw();
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    if (bVar1) {
      rw_le_core_off();
      get_bt_rx_rssi(&pwr_in_band,&gain,&pwr_full_band,uStack_70);
      esp_rx_result[1] = 0;
      if (uStack_70 != 0) {
        esp_rx_result[1] = (int)-(pwr_in_band + gain) / (int)uStack_70;
      }
      esp_rx_valid = true;
      esp_rx_result[0] = uStack_70;
      esp_rx_result[2] = iStack_6c;
      if (short_log_en != false) {
        phy_printf("rx_num: %d rx_rssi: %d\n",uStack_70);
        return;
      }
      phy_printf("%x %x %x %x %x %x %x %x %x %x w %x %x %x %x %x %x %x %x p %x %x %x\n",iStack_6c,
                 uStack_70,iStack_48,iStack_44,iStack_40,iStack_3c,iStack_38,iStack_34,iStack_30,
                 iVar3,iStack_68,iStack_64,iStack_58,iStack_5c,iStack_60,iStack_4c,iStack_50,
                 iStack_54,pwr_in_band,pwr_full_band,gain);
      return;
    }
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x00017e05)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_rx_per_syncw_rssi(u32 chan,u32 syncw)

{
  bool bVar1;
  STATUS SVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  u32 rw_rxlenerr;
  u32 rw_rxtyperr;
  u32 rw_rxsnerr;
  u32 rw_rxnesnerr;
  u32 rw_rxbdaddrmatch;
  u32 rw_rxtimeerr;
  u32 rw_rxpriverr;
  u32 rw_rxsyncerr;
  u32 rw_rxcrcerr;
  u32 rw_rxmicerr;
  u32 rw_rxlinklbl;
  u32 gain;
  u32 pwr_full_band;
  u32 pwr_in_band;
  s8 rw_rxrssi;
  int iStack_90;
  u32 uStack_8c;
  int iStack_88;
  int iStack_84;
  int iStack_80;
  int iStack_7c;
  int iStack_78;
  int iStack_74;
  int iStack_70;
  int iStack_6c;
  s8 rssi_max;
  uint uStack_64;
  int iStack_60;
  uint uStack_5c;
  uint uStack_58;
  int iStack_54;
  uint uStack_50;
  uint uStack_4c;
  uint uStack_48;
  int iStack_44;
  int iStack_40;
  int iStack_3c;
  int iStack_38;
  int iStack_34;
  int iStack_30;
  int iStack_2c;
  uint uStack_28;
  
  memw();
  pwr_in_band = 0;
  pwr_full_band = 0;
  gain = 0;
  _DAT_3ff51098 = _DAT_3ff51098 | 0xc0000000;
  memw();
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  memw();
  memw();
  _DAT_3ffb0000 = 0x2000302;
  memw();
  _DAT_60031224 = 0xdeadbeef;
  memw();
  memw();
  memw();
  _DAT_60031228 = _DAT_60031228 & 0xffff0000 | 0x10000;
  memw();
  memw();
  _DAT_600312a0 = _DAT_600312a0 & 0xffffc000 | 0x5dc;
  memw();
  memw();
  _DAT_60031200 = _DAT_60031200 | 0x40000;
  memw();
  rw_le_init_cs(0x1d,syncw,0x555555,0,0,0,0,chan,0xb,0,0,1,0x3fff,0,0);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0xc000b00;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_600312f0 = _DAT_600312f0 & 0x7fffffff;
  memw();
  memw();
  _DAT_600312e0 = _DAT_600312e0 | 0x8000000;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 8;
  memw();
  rw_le_core_on();
  phy_printf("RW RX PER\n");
  rw_rxlinklbl = 0;
  rw_rxmicerr = 0;
  rw_rxcrcerr = 0;
  rw_rxsyncerr = 0;
  rw_rxpriverr = 0;
  rw_rxtimeerr = 0;
  rw_rxbdaddrmatch = 0;
  rw_rxnesnerr = 0;
  rw_rxsnerr = 0;
  rw_rxtyperr = 0;
  rw_rxlenerr = 0;
  rw_rxrssi = '\0';
  ets_delay_us(0x14);
  iStack_90 = 0;
  iStack_2c = 0;
  iStack_30 = 0;
  iStack_34 = 0;
  iStack_38 = 0;
  iStack_6c = 0;
  iStack_70 = 0;
  iStack_74 = 0;
  iStack_78 = 0;
  iStack_7c = 0;
  iStack_80 = 0;
  iStack_84 = 0;
  iStack_88 = 0;
  iStack_3c = 0;
  iStack_54 = 0;
  iStack_60 = 0;
  iStack_40 = 0;
  iStack_44 = 0;
  uStack_8c = 0;
LAB_000182e2:
  do {
    memw();
    if ((_DAT_60031214 & 8) == 0) {
      rw_bb_rx_refesh();
      SVar2 = GetStopCmd();
      if ((SVar2 != BUSY) && (SVar2 != OK)) {
        memw();
        if (((_DAT_3ffb02c0 & 0x8000) != 0) || (memw(), (_DAT_3ffb02d0 & 0x8000) != 0)) {
          memw();
          if ((_DAT_3ffb02c0 & 0x8000) != 0) {
            rw_le_rxstat_unpack(0x3ffb02c0,&rw_rxlinklbl,&rw_rxpriverr,&rw_rxtimeerr,
                                &rw_rxbdaddrmatch,&rw_rxnesnerr,&rw_rxsnerr,&rw_rxmicerr,
                                &rw_rxcrcerr,&rw_rxlenerr,&rw_rxtyperr,&rw_rxsyncerr,&rw_rxrssi);
            memw();
            _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
            memw();
          }
          memw();
          if ((_DAT_3ffb02d0 & 0x8000) != 0) {
            rw_le_rxstat_unpack(0x3ffb02d0,&rw_rxlinklbl,&rw_rxpriverr,&rw_rxtimeerr,
                                &rw_rxbdaddrmatch,&rw_rxnesnerr,&rw_rxsnerr,&rw_rxmicerr,
                                &rw_rxcrcerr,&rw_rxlenerr,&rw_rxtyperr,&rw_rxsyncerr,&rw_rxrssi);
            memw();
            _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
            memw();
          }
          if (rw_rxsyncerr == 0) {
            if (rw_rxtyperr == 0) {
              if (rw_rxlenerr == 0) {
                if (rw_rxcrcerr == 0) {
                  if (rw_rxmicerr == 0) {
                    if (rw_rxsnerr == 0) {
                      if (rw_rxnesnerr == 0) {
                        if (rw_rxtimeerr == 0) {
                          if (rw_rxpriverr == 0) {
                            bVar1 = true;
                            iStack_44 = iStack_44 + 1;
                          }
                          else {
                            iStack_2c = iStack_2c + 1;
                            bVar1 = false;
                          }
                        }
                        else {
                          iStack_30 = iStack_30 + 1;
                          bVar1 = false;
                        }
                      }
                      else {
                        iStack_34 = iStack_34 + 1;
                        bVar1 = false;
                      }
                    }
                    else {
                      iStack_38 = iStack_38 + 1;
                      bVar1 = false;
                    }
                  }
                  else {
                    iStack_3c = iStack_3c + 1;
                    bVar1 = false;
                  }
                }
                else {
                  iStack_40 = iStack_40 + 1;
                  bVar1 = false;
                }
              }
              else {
                iStack_54 = iStack_54 + 1;
                bVar1 = false;
              }
            }
            else {
              iStack_60 = iStack_60 + 1;
              bVar1 = false;
            }
            memw();
            memw();
            memw();
            memw();
            uVar6 = _DAT_3ff51078 >> 0x10 & 0xff;
            pwr_in_band = (pwr_in_band + 0x100) - (_DAT_3ff51074 & 0xff);
            uStack_48 = _DAT_3ff51050 >> 6 & 1;
            uStack_50 = _DAT_3ff51050 >> 7 & 1;
            pwr_full_band = (pwr_full_band + 0x100) - (_DAT_3ff51078 >> 0x18);
            uStack_28 = (uint)((_DAT_3ff51050 & 8) != 0);
            gain = gain + uVar6;
            uStack_8c = uStack_8c + 1;
            uStack_4c = _DAT_3ff51050 >> 5 & 1;
            iStack_88 = iStack_88 + uStack_50;
            iStack_84 = iStack_84 + uStack_48;
            iStack_80 = iStack_80 + uStack_4c;
            iStack_74 = iStack_74 + (_DAT_3ff51050 >> 4 & 1);
            iStack_7c = iStack_7c + uStack_28;
            iStack_70 = iStack_70 + (uint)((_DAT_3ff51050 & 4) != 0);
            iStack_78 = iStack_78 + (uint)((_DAT_3ff51050 & 2) != 0);
            iStack_6c = iStack_6c + (_DAT_3ff51050 & 1);
            if (bVar1) {
              if (iStack_90 == 0) {
                _rssi_max = (uint)(byte)rw_rxrssi;
                iStack_90 = 1;
                uStack_64 = uVar6;
                uStack_5c = _rssi_max;
                uStack_58 = uVar6;
              }
              else {
                iVar4 = (int)(char)_rssi_max;
                iVar3 = (int)rw_rxrssi;
                iVar5 = (int)(char)uStack_5c;
                _rssi_max = (uint)(iVar4 < iVar3) * iVar3 + (uint)(iVar4 >= iVar3) * iVar4 & 0xff;
                uStack_5c = (uint)(iVar5 < iVar3) * iVar5 + (uint)(iVar5 >= iVar3) * iVar3 & 0xff;
                uStack_64 = (uStack_64 < uVar6) * uStack_64 + (uStack_64 >= uVar6) * uVar6;
                uStack_58 = (uStack_58 < uVar6) * uVar6 + (uStack_58 >= uVar6) * uStack_58;
              }
            }
          }
        }
        goto LAB_000182e2;
      }
      bVar1 = true;
      memw();
      _DAT_60031200 = _DAT_60031200 | 0x4000000;
      memw();
    }
    else {
      bVar1 = false;
    }
    memw();
    _DAT_60031218 = _DAT_60031218 | 8;
    memw();
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    if (bVar1) {
      rw_le_core_off();
      get_bt_rx_rssi(&pwr_in_band,&gain,&pwr_full_band,uStack_8c);
      phy_printf("%x %x %x %x %x %x %x %x %x %x w %x %x %x %x %x %x %x %x p %x %x %x r %d %d %d %d\n"
                 ,uStack_8c,iStack_44,iStack_60,iStack_54,iStack_40,iStack_3c,iStack_38,iStack_34,
                 iStack_30,iStack_2c,iStack_88,iStack_84,iStack_78,iStack_7c,iStack_80,iStack_6c,
                 iStack_70,iStack_74,pwr_in_band,pwr_full_band,gain,uStack_58,uStack_64,
                 (int)(char)_rssi_max,(int)(char)uStack_5c);
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_rx_per_init(u32 chan)

{
  int iVar1;
  undefined4 *puVar2;
  
  phy_printf("RW RX PER\n");
  memw();
  _DAT_3ff51098 = _DAT_3ff51098 | 0xc0000000;
  memw();
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  puVar2 = (undefined4 *)&DAT_3ffb0000;
  memw();
  iVar1 = 0x10;
  _DAT_6003122c = _DAT_6003122c & 0xffff;
  memw();
  memw();
  _DAT_3ffb0000 = 0x2000302;
  while( true ) {
    puVar2 = puVar2 + 1;
    iVar1 = iVar1 + -1;
    if (iVar1 == 0) break;
    memw();
    *puVar2 = 0;
  }
  memw();
  _DAT_60031224 = 0xdeadbeef;
  memw();
  memw();
  memw();
  _DAT_60031228 = _DAT_60031228 & 0xffff0000 | 0x10000;
  memw();
  memw();
  _DAT_600312a0 = _DAT_600312a0 & 0xffffc000 | 0x5dc;
  memw();
  memw();
  _DAT_60031200 = _DAT_60031200 | 0x40000;
  memw();
  rw_le_init_cs(0x1d,0x71764129,0x555555,0,0,0,0,chan,0xb,0,0,1,8,0,0);
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0xc000b00;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_600312f0 = _DAT_600312f0 & 0x7fffffff;
  memw();
  memw();
  _DAT_600312e0 = _DAT_600312e0 | 0x8000000;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 8;
  memw();
  rw_le_core_on();
  return;
}



// WARNING: Unknown calling convention

void rw_le_rx_per_syncw_polling(u32 chan)

{
  rw_le_rx_per_init(chan);
  cmd_polling_attach(false,0,rw_le_rx_per_syncw_service_polling,(void *)0x0);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_rx_per_syncw_polling_stop(void)

{
  cmd_polling_dettach(false,0,rw_le_rx_per_syncw_service_polling);
  rw_le_core_off();
  phy_printf("%x %x %x %x %x %x %x %x %x %x p %d %d %d %x\n",total_p_polling,cp_polling,
             type_ep_polling,len_ep_polling,crc_ep_polling,mic_ep_polling,sn_ep_polling,
             nesn_ep_polling,time_ep_polling,priv_ep_polling,total_rssi_polling,total_inband_polling
             ,total_fullband_polling,total_gain_polling);
  total_p_polling = 0;
  priv_ep_polling = 0;
  cp_polling = 0;
  type_ep_polling = 0;
  total_inband_polling = 0;
  len_ep_polling = 0;
  crc_ep_polling = 0;
  mic_ep_polling = 0;
  sn_ep_polling = 0;
  nesn_ep_polling = 0;
  time_ep_polling = 0;
  total_rssi_polling = 0;
  total_fullband_polling = 0;
  total_gain_polling = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_le_adv_cmd(u32 txpwr)

{
  rw_le_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_le_et_init();
  rw_le_adv_init(0x3ffb02a0,0x3ffb02b0,5,0xdeadbeef,0xffee,2000);
  memw();
  _DAT_3ffb0210 = (txpwr & 0xff) << 0x10 | _DAT_3ffb0210 & 0xff00ffff;
  memw();
  memw();
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  memw();
  _DAT_3ffb02c8 = 0xc000b00;
  memw();
  memw();
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  memw();
  _DAT_3ffb02d8 = 0x8000700;
  memw();
  memw();
  _DAT_6003122c = _DAT_6003122c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_60031218 = _DAT_60031218 | 0x4000;
  memw();
  rw_le_core_on();
  return;
}



// WARNING: Unknown calling convention

void cmd_polling_test0(u32 a)

{
  phy_printf(&DAT_00053450,a);
  return;
}



// WARNING: Unknown calling convention

void cmd_polling_test1(u32 b)

{
  phy_printf("j%x,%x\n",arga[0],arga[1]);
  return;
}



// WARNING: Unknown calling convention

void cmd_polling_test2(polling_sample *b)

{
  phy_printf("k%x,%x\n",b->phase,b->power);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void cmd_polling_test3(void)

{
  cmd_polling_test3::loop = cmd_polling_test3::loop + 1;
  phy_printf(&DAT_00053468,cmd_polling_test3::loop);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bb_rx_refesh(void)

{
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 2;
  memw();
  bt_track_pll_cap();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bb_tx_refesh(void)

{
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 0x40;
  memw();
  bt_track_pll_cap();
  bt_tx_num = bt_tx_num + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_txpwr_regulate(void)

{
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 0x200;
  memw();
  ets_delay_us(0x32);
  memw();
  phy_set_bt_dig_gain((byte)((uint)_DAT_3ff4e168 >> 0x18) & 0x7f);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_frm_refresh(u32 txdesc_refresh)

{
  uint8 uVar1;
  STATUS SVar2;
  
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  SVar2 = GetStopCmd();
  if (SVar2 == OK) {
    rw_bt_core_off();
    uVar1 = phy_get_tx_rate();
    phy_printf("rw done! %d\n",uVar1);
    run_end = 1;
  }
  memw();
  memw();
  _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
  if (txdesc_refresh != 0) {
    memw();
    _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
    memw();
  }
  frm_refresh_ind = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_frm_refresh_pscan(u32 txdesc_refresh)

{
  uint8 uVar1;
  STATUS SVar2;
  
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  memw();
  if ((_DAT_3ffb0200 & 0x1f) == 7) {
    memw();
    _DAT_3ffb0200 = _DAT_3ffb0200 & 0xffffffe0 | 5;
    memw();
  }
  SVar2 = GetStopCmd();
  if (SVar2 == OK) {
    rw_bt_core_off();
    uVar1 = phy_get_tx_rate();
    phy_printf("rw done! %d\n",uVar1);
    run_end = 1;
  }
  memw();
  memw();
  _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
  if (txdesc_refresh != 0) {
    memw();
    _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
    memw();
  }
  frm_refresh_ind = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_tx_pwr_check(void)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  phy_printf("tx pwr check\n%x, %x, %x, %x, %x\n",_DAT_3ff46000 & 1,_DAT_3ff46000 >> 2 & 0xff,
             _DAT_3ff46000 >> 1 & 1,_DAT_3ff46000 >> 10 & 0xff,_DAT_3ff46000 >> 0x12 & 0xff);
  memw();
  memw();
  memw();
  memw();
  phy_printf("tx gain ctrl\n%x, %x, %x, %x\n",_DAT_3ff46004,_DAT_3ff46008,_DAT_3ff4600c,
             _DAT_3ff46010);
  memw();
  _DAT_3ff4506c = _DAT_3ff4506c & 0xfffffff0 | 8;
  memw();
  memw();
  _DAT_3ff46010 = _DAT_3ff46010 & 0xffffff | 0xec000000;
  memw();
  memw();
  phy_printf("bt tx gain map: %x\n",_DAT_3ff4506c,0xe8);
  memw();
  memw();
  phy_printf("bt tx gain: %x, %x\n",_DAT_3ff4600c,_DAT_3ff46010);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_tx_pwr_force(void)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  phy_printf("tx pwr check\n%x, %x, %x, %x, %x\n",_DAT_3ff46000 & 1,_DAT_3ff46000 >> 2 & 0xff,
             _DAT_3ff46000 >> 1 & 1,(_DAT_3ff46000 & 0x3fc00) >> 10,
             (_DAT_3ff46000 & 0x3fc0000) >> 0x12);
  memw();
  memw();
  memw();
  memw();
  phy_printf("tx gain ctrl\n%x, %x, %x, %x\n",_DAT_3ff46004,_DAT_3ff46008,_DAT_3ff4600c,
             _DAT_3ff46010);
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff46000 = _DAT_3ff46000 & 0xfffffc03 | 0x395;
  return;
}



// WARNING: Unknown calling convention

void rw_bch_gen(u32 lap,u32 *bchl,u32 *bchh)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  uVar2 = 0x2c000000;
  uVar4 = 0x80000000;
  if ((lap & 0x800000) != 0) {
    uVar2 = 0x13000000;
  }
  uVar3 = 0xb0ae27b5;
  uVar1 = 0x20000000;
  uVar2 = ((uVar2 | lap & 0xffffff) ^ 0x20e12365) << 2;
  uVar5 = 0;
  do {
    if ((uVar4 & uVar2) == 0) {
      uVar1 = uVar3 << 0x1f | uVar1 >> 1;
      uVar3 = uVar3 >> 1;
      uVar4 = uVar4 >> 1;
    }
    else {
      uVar2 = uVar2 ^ uVar3;
      uVar5 = uVar5 ^ uVar1;
    }
  } while ((uVar1 & 1) == 0);
  if ((uVar4 & uVar2) != 0) {
    uVar2 = uVar2 ^ uVar3;
    uVar5 = uVar5 ^ uVar1;
  }
  *bchl = uVar5 ^ 0xbbcc54fc;
  *bchh = (uVar2 ^ 0x83848d96) & 3;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bch_gen_test(void)

{
  u32 bchh;
  u32 bchl;
  
  bchl = 0;
  bchh = 0;
  rw_bch_gen(0x9e8b33,&bchl,&bchh);
  phy_printf("\nGIAC0x%8x%8x\n",bchh | 0x4e7a2ccc,bchl);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_dm_activate(void)

{
  mac_write(0x60031390,0x800a);
  memw();
  memw();
  memw();
  memw();
  _DAT_600311e0 = _DAT_600311e0 & 0xffffff00 | 0x800a;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_et_init(void)

{
  memw();
  _DAT_6003102c = 0;
  memw();
  _DAT_3ffb0000 = 0x2000301;
  memw();
  _DAT_3ffb0004 = 1;
  memw();
  _DAT_3ffb0008 = 1;
  memw();
  _DAT_3ffb000c = 1;
  memw();
  _DAT_3ffb0010 = 1;
  memw();
  _DAT_3ffb0014 = 1;
  memw();
  _DAT_3ffb0018 = 1;
  memw();
  _DAT_3ffb001c = 1;
  memw();
  _DAT_3ffb0020 = 1;
  memw();
  _DAT_3ffb0024 = 1;
  memw();
  _DAT_3ffb0028 = 1;
  memw();
  _DAT_3ffb002c = 1;
  memw();
  _DAT_3ffb0030 = 1;
  memw();
  _DAT_3ffb0034 = 1;
  memw();
  _DAT_3ffb0038 = 1;
  memw();
  _DAT_3ffb003c = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_et_csb_init(void)

{
  memw();
  _DAT_6003102c = 0;
  memw();
  _DAT_3ffb0000 = 1;
  memw();
  _DAT_3ffb0004 = 1;
  memw();
  _DAT_3ffb0008 = 0x2000b01;
  memw();
  _DAT_3ffb000c = 1;
  memw();
  _DAT_3ffb0010 = 1;
  memw();
  _DAT_3ffb0014 = 1;
  memw();
  _DAT_3ffb0018 = 1;
  memw();
  _DAT_3ffb001c = 1;
  memw();
  _DAT_3ffb0020 = 1;
  memw();
  _DAT_3ffb0024 = 1;
  memw();
  _DAT_3ffb0028 = 1;
  memw();
  _DAT_3ffb002c = 1;
  memw();
  _DAT_3ffb0030 = 1;
  memw();
  _DAT_3ffb0034 = 1;
  memw();
  _DAT_3ffb0038 = 1;
  memw();
  _DAT_3ffb003c = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_et_off(void)

{
  memw();
  _DAT_6003102c = 0;
  memw();
  _DAT_3ffb0000 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_et_one(u32 one)

{
  memw();
  _DAT_3ffb0000 = 0x82000301;
  memw();
  *(undefined4 *)((one + 0xffec000) * 4) = 0x2000301;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_et_on(void)

{
  memw();
  _DAT_6003102c = 0;
  memw();
  _DAT_3ffb0000 = 0x2000301;
  memw();
  _DAT_3ffb0004 = 0x301;
  memw();
  _DAT_3ffb0008 = 0x2000301;
  memw();
  _DAT_3ffb000c = 0x301;
  memw();
  _DAT_3ffb0010 = 0x2000301;
  memw();
  _DAT_3ffb0014 = 0x301;
  memw();
  _DAT_3ffb0018 = 0x2000301;
  memw();
  _DAT_3ffb001c = 0x301;
  memw();
  _DAT_3ffb0020 = 0x2000301;
  memw();
  _DAT_3ffb0024 = 0x301;
  memw();
  _DAT_3ffb0028 = 0x2000301;
  memw();
  _DAT_3ffb002c = 0x301;
  memw();
  _DAT_3ffb0030 = 0x2000301;
  memw();
  _DAT_3ffb0034 = 0x301;
  memw();
  _DAT_3ffb0038 = 0x2000301;
  memw();
  _DAT_3ffb003c = 0x301;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_et_on_mask(u32 mask)

{
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff;
  if ((mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000301;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_et_fill(u32 mask,u32 cs_addr)

{
  if ((mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    memw();
    _DAT_3ffb0000 = (cs_addr & 0x7fff) << 0x10 | 0x301;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_encryt_space(void)

{
  memw();
  _DAT_3ffb0160 = 0;
  memw();
  _DAT_3ffb0164 = 0;
  memw();
  _DAT_3ffb0168 = 0;
  memw();
  _DAT_3ffb016c = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_cs_inqscan(void)

{
  memw();
  _DAT_3ffb0200 = 9;
  memw();
  _DAT_3ffb0204 = 0;
  memw();
  _DAT_3ffb0208 = 0x8b330100;
  memw();
  _DAT_3ffb020c = 0x9e;
  memw();
  _DAT_3ffb0210 = 0x331a3ae2;
  memw();
  _DAT_3ffb0214 = 0x80072002;
  memw();
  _DAT_3ffb0218 = 0x81000008;
  memw();
  _DAT_3ffb021c = 0xffff02a0;
  memw();
  _DAT_3ffb0220 = 0xffffffff;
  memw();
  _DAT_3ffb0224 = 0x7fffffff;
  memw();
  _DAT_3ffb0228 = 0x1004f;
  memw();
  _DAT_3ffb022c = 5;
  memw();
  _DAT_3ffb0230 = 0;
  memw();
  _DAT_3ffb0234 = 0;
  memw();
  _DAT_3ffb0238 = 0;
  memw();
  _DAT_3ffb023c = 0;
  memw();
  _DAT_3ffb0240 = 0;
  memw();
  _DAT_3ffb0244 = 0;
  memw();
  _DAT_3ffb0248 = 0;
  memw();
  _DAT_3ffb024c = 0;
  memw();
  _DAT_3ffb0250 = 0;
  memw();
  _DAT_3ffb0254 = 0;
  memw();
  _DAT_3ffb0258 = 0;
  memw();
  _DAT_3ffb025c = 0;
  memw();
  _DAT_3ffb0260 = 4;
  memw();
  _DAT_3ffb026c = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_cs_tx_test(void)

{
  memw();
  _DAT_3ffb0200 = 2;
  memw();
  _DAT_3ffb0204 = 0;
  memw();
  memw();
  _DAT_3ffb020c = 0x9e;
  memw();
  _DAT_3ffb0210 = 0x331a3ae2;
  memw();
  _DAT_3ffb0214 = 0x72002;
  memw();
  _DAT_3ffb0218 = 0x2b0008;
  memw();
  _DAT_3ffb021c = 0xffff02a0;
  memw();
  _DAT_3ffb0220 = 0xffffffff;
  memw();
  _DAT_3ffb0224 = 0x7fffffff;
  memw();
  _DAT_3ffb0228 = 0x1004f;
  memw();
  _DAT_3ffb022c = 5;
  memw();
  _DAT_3ffb0230 = 0;
  memw();
  _DAT_3ffb0234 = 0;
  memw();
  _DAT_3ffb0238 = 0;
  memw();
  _DAT_3ffb023c = 0;
  memw();
  _DAT_3ffb0240 = 0;
  memw();
  _DAT_3ffb0244 = 0;
  memw();
  _DAT_3ffb0248 = 0;
  memw();
  _DAT_3ffb024c = 0;
  memw();
  _DAT_3ffb0250 = 0;
  memw();
  _DAT_3ffb0254 = 0;
  memw();
  _DAT_3ffb0258 = 0;
  memw();
  _DAT_3ffb025c = 0;
  memw();
  _DAT_3ffb0260 = 4;
  memw();
  _DAT_3ffb026c = 0;
  memw();
  memw();
  _DAT_3ffb0208 = 0x8b331900;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_cs_rx_test(void)

{
  memw();
  _DAT_3ffb0200 = 3;
  memw();
  _DAT_3ffb0204 = 0;
  memw();
  _DAT_3ffb0208 = 0x8b331100;
  memw();
  _DAT_3ffb020c = 0x9e;
  memw();
  _DAT_3ffb0210 = 0x331a3ae2;
  memw();
  _DAT_3ffb0214 = 0x7ffc2;
  memw();
  _DAT_3ffb0218 = 0x10ff0008;
  memw();
  _DAT_3ffb021c = 0xffff0000;
  memw();
  _DAT_3ffb0220 = 0xffffffff;
  memw();
  _DAT_3ffb0224 = 0x7fffffff;
  memw();
  _DAT_3ffb0228 = 0x1004f;
  memw();
  _DAT_3ffb022c = 0xff;
  memw();
  _DAT_3ffb0230 = 0;
  memw();
  _DAT_3ffb0234 = 0;
  memw();
  _DAT_3ffb0238 = 0;
  memw();
  _DAT_3ffb023c = 0;
  memw();
  _DAT_3ffb0240 = 0;
  memw();
  _DAT_3ffb0244 = 0;
  memw();
  _DAT_3ffb0248 = 0;
  memw();
  _DAT_3ffb024c = 0;
  memw();
  _DAT_3ffb0250 = 0;
  memw();
  _DAT_3ffb0254 = 0;
  memw();
  _DAT_3ffb0258 = 0;
  memw();
  _DAT_3ffb025c = 0;
  memw();
  _DAT_3ffb0260 = 4;
  memw();
  _DAT_3ffb026c = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_init_cs(u32 format,u32 ltaddr,u32 edr,u32 whdsb,u32 bdaddrl,u32 bdaddrh,u32 bchl,u32 bchh,
               u32 txpwr,u32 hoppe_en,u32 freq,u32 tx_eir,u32 rxwide,u32 rxwinsz,u32 txdesc,
               u32 maxfrmtime,u32 rxthr)

{
  memw();
  memw();
  _DAT_3ffb0204 = 0;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb0220 = 0xffffffff;
  memw();
  _DAT_3ffb0224 = 0x7fffffff;
  memw();
  _DAT_3ffb0228 = 0x1004f;
  memw();
  memw();
  _DAT_3ffb0230 = 0;
  memw();
  _DAT_3ffb0234 = 0;
  memw();
  _DAT_3ffb0238 = 0;
  memw();
  _DAT_3ffb023c = 0;
  memw();
  _DAT_3ffb0240 = 0;
  memw();
  _DAT_3ffb0244 = 0;
  memw();
  _DAT_3ffb0248 = 0;
  memw();
  _DAT_3ffb024c = 0;
  memw();
  _DAT_3ffb0250 = 0;
  memw();
  _DAT_3ffb0254 = 0;
  memw();
  _DAT_3ffb0258 = 0;
  memw();
  _DAT_3ffb025c = 0;
  memw();
  _DAT_3ffb0260 = 0;
  memw();
  _DAT_3ffb026c = 0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb0200 = format & 0x1f;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb0208 = (whdsb & 1) << 0xc | (edr & 1) << 0xb | (ltaddr & 7) << 8 | bdaddrl << 0x10;
  memw();
  _DAT_3ffb020c = bdaddrl >> 0x10 | bdaddrh << 0x10;
  memw();
  _DAT_3ffb0210 = bchl;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb0214 =
       (freq & 0x7f) << 0x18 | (txpwr & 0xff) << 0x10 | hoppe_en << 0x1f | bchh & 3 | 0xffc0;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb0218 =
       (rxthr & 7) << 0xd | (rxwinsz & 0xfff) << 0x10 | (tx_eir & 1) << 3 | rxwide << 0x1f;
  memw();
  memw();
  _DAT_3ffb021c = txdesc & 0x7fff | 0xffff0000;
  memw();
  memw();
  _DAT_3ffb022c = maxfrmtime & 0xfff;
  return;
}



// WARNING: Unknown calling convention

void rw_cs_set_freq(u32 addr,u32 freq)

{
  memw();
  memw();
  *(u32 *)(addr + 0x14) = (freq & 0x7f) << 0x18 | *(uint *)(addr + 0x14) & 0x80ffffff;
  return;
}



// WARNING: Unknown calling convention

void rw_cs_set_txdesc(u32 addr,u32 desc)

{
  memw();
  memw();
  *(uint *)(addr + 0x1c) = *(uint *)(addr + 0x1c) & 0xffff8000 | desc & 0x7fff;
  return;
}



// WARNING: Unknown calling convention

u32 rw_cs_get_rxclkn(u32 ptr)

{
  memw();
  memw();
  return (*(uint *)(&DAT_3ffb0054 + ptr) & 0x7ff) << 0x10 | *(uint *)(&DAT_3ffb0050 + ptr) >> 0x10;
}



// WARNING: Unknown calling convention

u32 rw_cs_get_rxbit(u32 ptr)

{
  memw();
  return (*(uint *)(&DAT_3ffb0054 + ptr) & 0x3ff0000) >> 0x10;
}



// WARNING: Unknown calling convention

void rw_init_tx_descriptor
               (u32 ptr,u32 nxt_ptr,u32 seqn,u32 arqn,u32 flow,u32 type,u32 ltaddr,u32 length,
               u32 pflow,u32 llid,u32 aclbufptr,u32 lmpbufptr)

{
  memw();
  *(u32 *)ptr = (arqn & 1) << 0x18 | (seqn & 1) << 0x19 | (flow & 1) << 0x17 | (type & 0xf) << 0x13
                | nxt_ptr & 0x7fff | (ltaddr & 7) << 0x10;
  memw();
  *(u32 *)(ptr + 4) = (length & 0x3ff) << 3 | aclbufptr << 0x10 | llid & 3 | (pflow & 1) << 2;
  memw();
  memw();
  *(uint *)(ptr + 8) = *(uint *)(ptr + 8) & 0xffff0000 | lmpbufptr & 0xffff;
  return;
}



// WARNING: Unknown calling convention

void rw_init_tx_descriptor_dh1or2dh1_test(u32 ptr,u32 nxt_ptr,u32 aclbufptr,u32 lmpbufptr)

{
  memw();
  *(u32 *)ptr = nxt_ptr & 0x7fff | 0xa00000;
  memw();
  *(u32 *)(ptr + 4) = aclbufptr << 0x10 | 0x196;
  memw();
  memw();
  *(uint *)(ptr + 8) = *(uint *)(ptr + 8) & 0xffff0000 | lmpbufptr & 0xffff;
  return;
}



// WARNING: Unknown calling convention

void rw_init_tx_descriptor_dh3or3dh3_test(u32 ptr,u32 nxt_ptr,u32 aclbufptr,u32 lmpbufptr)

{
  memw();
  *(u32 *)ptr = nxt_ptr & 0x7fff | 0xda0000;
  memw();
  *(u32 *)(ptr + 4) = aclbufptr << 0x10 | 0xfa6;
  memw();
  memw();
  *(uint *)(ptr + 8) = *(uint *)(ptr + 8) & 0xffff0000 | lmpbufptr & 0xffff;
  return;
}



// WARNING: Unknown calling convention

void rw_init_tx_descriptor_dm1_test(u32 ptr,u32 nxt_ptr,u32 aclbufptr,u32 lmpbufptr)

{
  memw();
  *(u32 *)ptr = nxt_ptr & 0x7fff | 0x9a0000;
  memw();
  *(u32 *)(ptr + 4) = aclbufptr << 0x10 | 0x56;
  memw();
  memw();
  *(uint *)(ptr + 8) = *(uint *)(ptr + 8) & 0xffff0000 | lmpbufptr & 0xffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_tx_descriptor0(void)

{
  memw();
  _DAT_3ffb02a0 = 0x1102b0;
  memw();
  _DAT_3ffb02a4 = 0x30000d8;
  memw();
  _DAT_3ffb02a8 = 0x700;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_tx_descriptor1(void)

{
  memw();
  _DAT_3ffb02b0 = 0x21902a0;
  memw();
  _DAT_3ffb02b4 = 0x40000d8;
  memw();
  _DAT_3ffb02b8 = 0x800;
  return;
}



// WARNING: Unknown calling convention

void rw_init_rx_descryptor(u32 desc_addr,u32 nxt_desc_addr,u32 aclbuf_addr,u32 lmpbuf_addr)

{
  memw();
  *(undefined4 *)desc_addr = 0;
  memw();
  *(undefined4 *)(desc_addr + 8) = 0;
  memw();
  *(undefined4 *)(desc_addr + 0xc) = 0;
  memw();
  memw();
  *(uint *)desc_addr = *(uint *)desc_addr & 0xffff8000 | nxt_desc_addr & 0x7fff;
  memw();
  memw();
  *(uint *)(desc_addr + 8) = *(uint *)(desc_addr + 8) & 0xffff | aclbuf_addr << 0x10;
  memw();
  memw();
  *(uint *)(desc_addr + 0xc) = *(uint *)(desc_addr + 0xc) & 0xffff0000 | lmpbuf_addr & 0xffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_rx_descryptor0(void)

{
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0x900;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_rx_descryptor1(void)

{
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xa00;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_tx_aclbuffer0(void)

{
  memw();
  _DAT_3ffb0300 = 0x1020800;
  memw();
  _DAT_3ffb0304 = 0x12785f69;
  memw();
  _DAT_3ffb0308 = 0xab2d5610;
  memw();
  _DAT_3ffb030c = 0x67efb201;
  memw();
  _DAT_3ffb0310 = 0x45cd9012;
  memw();
  _DAT_3ffb0314 = 0x23ab7eab;
  memw();
  _DAT_3ffb0318 = 0x1895c67;
  memw();
  _DAT_3ffb031c = 0xef673a45;
  memw();
  _DAT_3ffb0320 = 0xcd451823;
  memw();
  _DAT_3ffb0324 = 0xab23f601;
  memw();
  _DAT_3ffb0328 = 0x8901d4ef;
  memw();
  _DAT_3ffb032c = 0x67efb2cd;
  memw();
  _DAT_3ffb0330 = 0x45cd90ab;
  memw();
  _DAT_3ffb0334 = 0x23ab7e89;
  memw();
  _DAT_3ffb0338 = 0x1895c67;
  memw();
  _DAT_3ffb033c = 0xef673a45;
  memw();
  _DAT_3ffb0340 = 0xcd450023;
  memw();
  _DAT_3ffb0344 = 0xab230201;
  memw();
  _DAT_3ffb0348 = 0x890104ef;
  memw();
  _DAT_3ffb034c = 0x67ef08cd;
  memw();
  _DAT_3ffb0350 = 0x45cda0ab;
  memw();
  _DAT_3ffb0354 = 0x23ab0089;
  memw();
  _DAT_3ffb0358 = 0x1890267;
  memw();
  _DAT_3ffb035c = 0xef674945;
  memw();
  _DAT_3ffb0360 = 0xcd4501cd;
  memw();
  _DAT_3ffb0364 = 0xab23eaab;
  memw();
  _DAT_3ffb0368 = 0x8901c689;
  memw();
  _DAT_3ffb036c = 0x67efa467;
  memw();
  _DAT_3ffb0370 = 0x45cd8245;
  memw();
  _DAT_3ffb0374 = 0x23ab6023;
  memw();
  _DAT_3ffb0378 = 0x1894e01;
  memw();
  _DAT_3ffb037c = 0xef672cef;
  memw();
  _DAT_3ffb0380 = 0xcd450acd;
  memw();
  _DAT_3ffb0384 = 0xab23e8ab;
  memw();
  _DAT_3ffb0388 = 0x8901c689;
  memw();
  _DAT_3ffb038c = 0x67efa467;
  memw();
  _DAT_3ffb0390 = 0x45cd0245;
  memw();
  _DAT_3ffb0394 = 0x23ab2023;
  memw();
  _DAT_3ffb0398 = 0x1894e01;
  memw();
  _DAT_3ffb039c = 0xef278cef;
  memw();
  _DAT_3ffb03a0 = 0xcdb20acd;
  memw();
  _DAT_3ffb03a4 = 0xab7e08ab;
  memw();
  _DAT_3ffb03a8 = 0x895c2689;
  memw();
  _DAT_3ffb03ac = 0x673a3a67;
  memw();
  _DAT_3ffb03b0 = 0x45181845;
  memw();
  _DAT_3ffb03b4 = 0x23f6f623;
  memw();
  _DAT_3ffb03b8 = 0x1d4d401;
  memw();
  _DAT_3ffb03bc = 0xefb2b2ef;
  memw();
  _DAT_3ffb03c0 = 0xcd9090cd;
  memw();
  _DAT_3ffb03c4 = 0xab7e7eab;
  memw();
  _DAT_3ffb03c8 = 0x895c5c89;
  memw();
  _DAT_3ffb03cc = 0x673a3a67;
  memw();
  _DAT_3ffb03d0 = 0x45181845;
  memw();
  _DAT_3ffb03d4 = 0x23f60023;
  memw();
  _DAT_3ffb03d8 = 0x1d46901;
  memw();
  _DAT_3ffb03dc = 0xefb210ef;
  memw();
  _DAT_3ffb03e0 = 0xcd9001cd;
  memw();
  _DAT_3ffb03e4 = 0xab7e12ab;
  memw();
  _DAT_3ffb03e8 = 0x895cab89;
  memw();
  _DAT_3ffb03ec = 0x673a6727;
  memw();
  _DAT_3ffb03f0 = 0x451845b2;
  memw();
  _DAT_3ffb03f4 = 0x23f6237e;
  memw();
  _DAT_3ffb03f8 = 0x1d4015c;
  memw();
  _DAT_3ffb03fc = 0xf0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_tx_aclbuffer1(void)

{
  memw();
  _DAT_3ffb0400 = 0xcd000023;
  memw();
  _DAT_3ffb0404 = 0xab690201;
  memw();
  _DAT_3ffb0408 = 0x891004ef;
  memw();
  _DAT_3ffb040c = 0x670108cd;
  memw();
  _DAT_3ffb0410 = 0x4512a0ab;
  memw();
  _DAT_3ffb0414 = 0x23ab0089;
  memw();
  _DAT_3ffb0418 = 0x1670267;
  memw();
  _DAT_3ffb041c = 0xef454945;
  memw();
  _DAT_3ffb0420 = 0xcd2301cd;
  memw();
  _DAT_3ffb0424 = 0xab01eaab;
  memw();
  _DAT_3ffb0428 = 0x89efc689;
  memw();
  _DAT_3ffb042c = 0x67cda467;
  memw();
  _DAT_3ffb0430 = 0x45ab8245;
  memw();
  _DAT_3ffb0434 = 0x23896023;
  memw();
  _DAT_3ffb0438 = 0x1674e01;
  memw();
  _DAT_3ffb043c = 0xef452cef;
  memw();
  _DAT_3ffb0440 = 0xcd230acd;
  memw();
  _DAT_3ffb0444 = 0xab01e8ab;
  memw();
  _DAT_3ffb0448 = 0x89efc689;
  memw();
  _DAT_3ffb044c = 0x67cda467;
  memw();
  _DAT_3ffb0450 = 0x45ab0245;
  memw();
  _DAT_3ffb0454 = 0x23892023;
  memw();
  _DAT_3ffb0458 = 0x1674e01;
  memw();
  _DAT_3ffb045c = 0xef458cef;
  memw();
  _DAT_3ffb0460 = 0xcdcd0acd;
  memw();
  _DAT_3ffb0464 = 0xabab08ab;
  memw();
  _DAT_3ffb0468 = 0x89892689;
  memw();
  _DAT_3ffb046c = 0x67233a67;
  memw();
  _DAT_3ffb0470 = 0x95011845;
  memw();
  _DAT_3ffb0474 = 0x73eff623;
  memw();
  _DAT_3ffb0478 = 0x50cdd401;
  memw();
  _DAT_3ffb047c = 0x30abb2ef;
  memw();
  _DAT_3ffb0480 = 0x108990cd;
  memw();
  _DAT_3ffb0484 = 0xf0677eab;
  memw();
  _DAT_3ffb0488 = 0xda455c89;
  memw();
  _DAT_3ffb048c = 0xb0233a67;
  memw();
  _DAT_3ffb0490 = 0x90011845;
  memw();
  _DAT_3ffb0494 = 0x74ef0023;
  memw();
  _DAT_3ffb0498 = 0x50cd6901;
  memw();
  _DAT_3ffb049c = 0x3eab2023;
  memw();
  _DAT_3ffb04a0 = 0x1c899501;
  memw();
  _DAT_3ffb04a4 = 0xfa671089;
  memw();
  _DAT_3ffb04a8 = 0xd845b023;
  memw();
  _DAT_3ffb04ac = 0xb6238cef;
  memw();
  _DAT_3ffb04b0 = 0x94017eab;
  memw();
  _DAT_3ffb04b4 = 0x72ef5c89;
  memw();
  _DAT_3ffb04b8 = 0x50cd3a67;
  memw();
  _DAT_3ffb04bc = 0x3eab78ef;
  memw();
  _DAT_3ffb04c0 = 0x1c8910ef;
  memw();
  _DAT_3ffb04c4 = 0xfa6701cd;
  memw();
  _DAT_3ffb04c8 = 0xd04512ab;
  memw();
  _DAT_3ffb04cc = 0xb223ab89;
  memw();
  _DAT_3ffb04d0 = 0x94016727;
  memw();
  _DAT_3ffb04d4 = 0x78ef45b2;
  memw();
  _DAT_3ffb04d8 = 0x20cd237e;
  memw();
  _DAT_3ffb04dc = 0xe0ab015c;
  memw();
  _DAT_3ffb04e0 = 0xc289d4f2;
  memw();
  _DAT_3ffb04e4 = 0xa367b2db;
  memw();
  _DAT_3ffb04e8 = 0x81459067;
  memw();
  _DAT_3ffb04ec = 0x6f237e45;
  memw();
  _DAT_3ffb04f0 = 0x4d015c23;
  memw();
  _DAT_3ffb04f4 = 0x2bef3a01;
  memw();
  _DAT_3ffb04f8 = 0x9cd18ef;
  memw();
  _DAT_3ffb04fc = 0xf1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_tx_lmpbuffer0(void)

{
  memw();
  _DAT_3ffb0700 = 0x1020800;
  memw();
  _DAT_3ffb0704 = 0x12785f69;
  memw();
  _DAT_3ffb0708 = 0xab2d5610;
  memw();
  _DAT_3ffb070c = 0x67efb201;
  memw();
  _DAT_3ffb0710 = 0x45cd9012;
  memw();
  _DAT_3ffb0714 = 0x23ab7eab;
  memw();
  _DAT_3ffb0718 = 0x1895c67;
  memw();
  _DAT_3ffb071c = 0xef673a45;
  memw();
  _DAT_3ffb0720 = 0xcd451823;
  memw();
  _DAT_3ffb0724 = 0xab23f601;
  memw();
  _DAT_3ffb0728 = 0x8901d4ef;
  memw();
  _DAT_3ffb072c = 0x67efb2cd;
  memw();
  _DAT_3ffb0730 = 0x45cd90ab;
  memw();
  _DAT_3ffb0734 = 0x23ab7e89;
  memw();
  _DAT_3ffb0738 = 0x1895c67;
  memw();
  _DAT_3ffb073c = 0xef673a45;
  memw();
  _DAT_3ffb0740 = 0xcd450023;
  memw();
  _DAT_3ffb0744 = 0xab230201;
  memw();
  _DAT_3ffb0748 = 0x890104ef;
  memw();
  _DAT_3ffb074c = 0x67ef08cd;
  memw();
  _DAT_3ffb0750 = 0x45cda0ab;
  memw();
  _DAT_3ffb0754 = 0x23ab0089;
  memw();
  _DAT_3ffb0758 = 0x1890267;
  memw();
  _DAT_3ffb075c = 0xef674945;
  memw();
  _DAT_3ffb0760 = 0xcd4501cd;
  memw();
  _DAT_3ffb0764 = 0xab23eaab;
  memw();
  _DAT_3ffb0768 = 0x8901c689;
  memw();
  _DAT_3ffb076c = 0x67efa467;
  memw();
  _DAT_3ffb0770 = 0x45cd8245;
  memw();
  _DAT_3ffb0774 = 0x23ab6023;
  memw();
  _DAT_3ffb0778 = 0x1894e01;
  memw();
  _DAT_3ffb077c = 0xef672cef;
  memw();
  _DAT_3ffb0780 = 0xcd450acd;
  memw();
  _DAT_3ffb0784 = 0xab23e8ab;
  memw();
  _DAT_3ffb0788 = 0x8901c689;
  memw();
  _DAT_3ffb078c = 0x67efa467;
  memw();
  _DAT_3ffb0790 = 0x45cd0245;
  memw();
  _DAT_3ffb0794 = 0x23ab2023;
  memw();
  _DAT_3ffb0798 = 0x1894e01;
  memw();
  _DAT_3ffb079c = 0xef278cef;
  memw();
  _DAT_3ffb07a0 = 0xcdb20acd;
  memw();
  _DAT_3ffb07a4 = 0xab7e08ab;
  memw();
  _DAT_3ffb07a8 = 0x895c2689;
  memw();
  _DAT_3ffb07ac = 0x673a3a67;
  memw();
  _DAT_3ffb07b0 = 0x45181845;
  memw();
  _DAT_3ffb07b4 = 0x23f6f623;
  memw();
  _DAT_3ffb07b8 = 0x1d4d401;
  memw();
  _DAT_3ffb07bc = 0xefb2b2ef;
  memw();
  _DAT_3ffb07c0 = 0xcd9090cd;
  memw();
  _DAT_3ffb07c4 = 0xab7e7eab;
  memw();
  _DAT_3ffb07c8 = 0x895c5c89;
  memw();
  _DAT_3ffb07cc = 0x673a3a67;
  memw();
  _DAT_3ffb07d0 = 0x45181845;
  memw();
  _DAT_3ffb07d4 = 0x23f60023;
  memw();
  _DAT_3ffb07d8 = 0x1d46901;
  memw();
  _DAT_3ffb07dc = 0xefb210ef;
  memw();
  _DAT_3ffb07e0 = 0xcd9001cd;
  memw();
  _DAT_3ffb07e4 = 0xab7e12ab;
  memw();
  _DAT_3ffb07e8 = 0x895cab89;
  memw();
  _DAT_3ffb07ec = 0x673a6727;
  memw();
  _DAT_3ffb07f0 = 0x451845b2;
  memw();
  _DAT_3ffb07f4 = 0x23f6237e;
  memw();
  _DAT_3ffb07f8 = 0x1d4015c;
  memw();
  _DAT_3ffb07fc = 0xf0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_init_tx_lmpbuffer1(void)

{
  memw();
  _DAT_3ffb0800 = 0xcd000023;
  memw();
  _DAT_3ffb0804 = 0xab690201;
  memw();
  _DAT_3ffb0808 = 0x891004ef;
  memw();
  _DAT_3ffb080c = 0x670108cd;
  memw();
  _DAT_3ffb0810 = 0x4512a0ab;
  memw();
  _DAT_3ffb0814 = 0x23ab0089;
  memw();
  _DAT_3ffb0818 = 0x1670267;
  memw();
  _DAT_3ffb081c = 0xef454945;
  memw();
  _DAT_3ffb0820 = 0xcd2301cd;
  memw();
  _DAT_3ffb0824 = 0xab01eaab;
  memw();
  _DAT_3ffb0828 = 0x89efc689;
  memw();
  _DAT_3ffb082c = 0x67cda467;
  memw();
  _DAT_3ffb0830 = 0x45ab8245;
  memw();
  _DAT_3ffb0834 = 0x23896023;
  memw();
  _DAT_3ffb0838 = 0x1674e01;
  memw();
  _DAT_3ffb083c = 0xef452cef;
  memw();
  _DAT_3ffb0840 = 0xcd230acd;
  memw();
  _DAT_3ffb0844 = 0xab01e8ab;
  memw();
  _DAT_3ffb0848 = 0x89efc689;
  memw();
  _DAT_3ffb084c = 0x67cda467;
  memw();
  _DAT_3ffb0850 = 0x45ab0245;
  memw();
  _DAT_3ffb0854 = 0x23892023;
  memw();
  _DAT_3ffb0858 = 0x1674e01;
  memw();
  _DAT_3ffb085c = 0xef458cef;
  memw();
  _DAT_3ffb0860 = 0xcdcd0acd;
  memw();
  _DAT_3ffb0864 = 0xabab08ab;
  memw();
  _DAT_3ffb0868 = 0x89892689;
  memw();
  _DAT_3ffb086c = 0x67233a67;
  memw();
  _DAT_3ffb0870 = 0x95011845;
  memw();
  _DAT_3ffb0874 = 0x73eff623;
  memw();
  _DAT_3ffb0878 = 0x50cdd401;
  memw();
  _DAT_3ffb087c = 0x30abb2ef;
  memw();
  _DAT_3ffb0880 = 0x108990cd;
  memw();
  _DAT_3ffb0884 = 0xf0677eab;
  memw();
  _DAT_3ffb0888 = 0xda455c89;
  memw();
  _DAT_3ffb088c = 0xb0233a67;
  memw();
  _DAT_3ffb0890 = 0x90011845;
  memw();
  _DAT_3ffb0894 = 0x74ef0023;
  memw();
  _DAT_3ffb0898 = 0x50cd6901;
  memw();
  _DAT_3ffb089c = 0x3eab2023;
  memw();
  _DAT_3ffb08a0 = 0x1c899501;
  memw();
  _DAT_3ffb08a4 = 0xfa671089;
  memw();
  _DAT_3ffb08a8 = 0xd845b023;
  memw();
  _DAT_3ffb08ac = 0xb6238cef;
  memw();
  _DAT_3ffb08b0 = 0x94017eab;
  memw();
  _DAT_3ffb08b4 = 0x72ef5c89;
  memw();
  _DAT_3ffb08b8 = 0x50cd3a67;
  memw();
  _DAT_3ffb08bc = 0x3eab78ef;
  memw();
  _DAT_3ffb08c0 = 0x1c8910ef;
  memw();
  _DAT_3ffb08c4 = 0xfa6701cd;
  memw();
  _DAT_3ffb08c8 = 0xd04512ab;
  memw();
  _DAT_3ffb08cc = 0xb223ab89;
  memw();
  _DAT_3ffb08d0 = 0x94016727;
  memw();
  _DAT_3ffb08d4 = 0x78ef45b2;
  memw();
  _DAT_3ffb08d8 = 0x20cd237e;
  memw();
  _DAT_3ffb08dc = 0xe0ab015c;
  memw();
  _DAT_3ffb08e0 = 0xc289d4f2;
  memw();
  _DAT_3ffb08e4 = 0xa367b2db;
  memw();
  _DAT_3ffb08e8 = 0x81459067;
  memw();
  _DAT_3ffb08ec = 0x6f237e45;
  memw();
  _DAT_3ffb08f0 = 0x4d015c23;
  memw();
  _DAT_3ffb08f4 = 0x2bef3a01;
  memw();
  _DAT_3ffb08f8 = 0x9cd18ef;
  memw();
  _DAT_3ffb08fc = 0xf1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_test_init(void)

{
  rw_bt_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  memw();
  _DAT_6003102c = 0;
  memw();
  _DAT_3ffb0000 = 0;
  memw();
  _DAT_3ffb0160 = 0;
  memw();
  _DAT_3ffb0164 = 0;
  memw();
  _DAT_3ffb0168 = 0;
  memw();
  _DAT_3ffb016c = 0;
  rw_init_tx_aclbuffer0();
  rw_init_tx_aclbuffer1();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_60031000 = _DAT_60031000 | 0x848000;
  memw();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_set_current_rxdecriptor(void)

{
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  return;
}



// WARNING: Unknown calling convention

void rw_fill_FHS_buf(u32 ptr,u32 parity_l,u32 parity_h,u32 lap,u32 eir,u32 sr,u32 uap,u32 nap,
                    u32 cod,u32 ltaddr)

{
  memw();
  *(u32 *)(&DAT_3ffb0000 + ptr) = parity_l;
  memw();
  *(u32 *)(&DAT_3ffb0004 + ptr) =
       (sr & 3) << 0x1c | 0x80000000 | (eir & 1) << 0x1a | parity_h & 3 | (lap & 0xffffff) << 2;
  memw();
  *(uint *)(&DAT_3ffb0008 + ptr) = (uint)CONCAT21((undefined2)nap,(undefined)uap) | cod << 0x18;
  memw();
  *(u32 *)(&DAT_3ffb000c + ptr) = (cod & 0xffffff) >> 8 | (ltaddr & 7) << 0x10;
  return;
}



// WARNING: Unknown calling convention

u32 rw_get_FHS_clkn(u32 ptr)

{
  memw();
  return *(u32 *)(&DAT_3ffb0000 + ptr);
}



// WARNING: Unknown calling convention

void rw_fill_eir_buf(u32 ptr)

{
  memw();
  *(u32 *)(&DAT_3ffb0000 + ptr) = eir_payload[0];
  return;
}



// WARNING: Unknown calling convention

void rw_bt_rxstat_unpack(u32 desc_addr,u32 *rxlinklbl,u32 *rxeirstat,u32 *rxguarderr,u32 *rxbadlt,
                        u32 *rxfecerr,u32 *rxseqerr,u32 *rxmicerr,u32 *rxcrcerr,u32 *rxhecerr,
                        u32 *rxsyncerr)

{
  uint uVar1;
  
  memw();
  uVar1 = *(uint *)desc_addr;
  *rxlinklbl = uVar1 >> 0x1b;
  *rxeirstat = uVar1 >> 0x18 & 1;
  *rxguarderr = uVar1 >> 0x17 & 1;
  *rxbadlt = uVar1 >> 0x16 & 1;
  *rxseqerr = uVar1 >> 0x14 & 1;
  *rxmicerr = uVar1 >> 0x13 & 1;
  *rxcrcerr = uVar1 >> 0x12 & 1;
  *rxhecerr = uVar1 >> 0x11 & 1;
  *rxfecerr = uVar1 >> 0x15 & 1;
  *rxsyncerr = uVar1 >> 0x10 & 1;
  return;
}



// WARNING: Unknown calling convention

u32 rw_bt_rxdone(u32 desc_addr)

{
  memw();
  return (*(uint *)desc_addr & 0x8000) >> 0xf;
}



// WARNING: Unknown calling convention

void rw_bt_rxundone(u32 desc_addr)

{
  memw();
  if ((*(uint *)desc_addr & 0x8000) != 0) {
    memw();
    memw();
    *(uint *)desc_addr = *(uint *)desc_addr & 0xffff7fff;
  }
  return;
}



// WARNING: Unknown calling convention

void rw_rx_status_print(u32 desc_addr)

{
  memw();
  memw();
  memw();
  if (((*(uint *)desc_addr & 0x8000) != 0) && ((*(uint *)desc_addr >> 0x10 & 1) == 0)) {
    phy_printf("\nrx%3x rssi%d\n",*(uint *)desc_addr >> 0x10 & 0x1ff,
               (int)(char)*(undefined4 *)(desc_addr + 8));
  }
  return;
}



// WARNING: Unknown calling convention

u32 rw_rx_status_print_(u32 desc_addr)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  return *(uint *)(desc_addr + 4) >> 3 & 0xf;
}



// WARNING: Unknown calling convention

void rw_rx_head_get(u32 desc_addr,u32 *ptype,u32 *len,u32 *llid,s8 *rssi)

{
  uint uVar1;
  uint uVar2;
  
  memw();
  *rssi = (s8)*(undefined4 *)(desc_addr + 8);
  memw();
  memw();
  uVar2 = *(uint *)(desc_addr + 4);
  memw();
  uVar1 = *(uint *)(desc_addr + 4);
  *llid = (*(uint *)(desc_addr + 4) & 0x30000) >> 0x10;
  *len = (uVar2 & 0x1ff80000) >> 0x13;
  *ptype = uVar1 >> 3 & 0xf;
  return;
}



// WARNING: Unknown calling convention

s8 rw_rx_rssi_get(u32 desc_addr)

{
  memw();
  return (s8)*(undefined4 *)(desc_addr + 8);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_rx_refresh(void)

{
  rw_rx_status_print(0x3ffb02c0);
  rw_rx_status_print(0x3ffb02d0);
  memw();
  if ((_DAT_3ffb02c0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    memw();
  }
  memw();
  if ((_DAT_3ffb02d0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bb_ac_refesh(void)

{
  memw();
  if ((_DAT_3ff51030 & 2) != 0) {
    memw();
    _DAT_3ff51038 = _DAT_3ff51038 | 2;
    memw();
    memw();
    if ((_DAT_3ff51030 & 4) != 0) {
      memw();
      phy_printf("AC%d \n",_DAT_3ff51050 >> 8 & 0x1ff);
      memw();
      _DAT_3ff51038 = _DAT_3ff51038 | 4;
      memw();
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bb_rx_refesh(void)

{
  memw();
  if ((_DAT_3ff51030 & 2) != 0) {
    rw_bb_rx_refesh();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bb_tx_refesh(void)

{
  memw();
  if ((_DAT_3ff51030 & 0x40) != 0) {
    rw_bb_tx_refesh();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_txpwr_regulate(void)

{
  memw();
  if ((_DAT_3ff51030 & 0x200) != 0) {
    rw_txpwr_regulate();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_frm_refresh(u32 txdesc_refresh)

{
  memw();
  if ((_DAT_60031014 & 0x4000) != 0) {
    rw_frm_refresh(txdesc_refresh);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_frm_refresh_pscan(u32 txdesc_refresh)

{
  memw();
  if ((_DAT_60031014 & 0x4000) != 0) {
    rw_frm_refresh_pscan(txdesc_refresh);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_frm_refresh_no_cmd(u32 txdesc_refresh)

{
  memw();
  if ((_DAT_60031014 & 0x4000) != 0) {
    memw();
    _DAT_60031018 = _DAT_60031018 | 0x4000;
    memw();
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    if (txdesc_refresh != 0) {
      memw();
      _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
      memw();
      memw();
      _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
      memw();
    }
    frm_refresh_ind = 1;
  }
  rw_rx_status_print(0x3ffb02c0);
  rw_rx_status_print(0x3ffb02d0);
  memw();
  if ((_DAT_3ffb02c0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    memw();
  }
  memw();
  if ((_DAT_3ffb02d0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_frm_refresh_check_rx(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  memw();
  if ((_DAT_60031014 & 0x4000) != 0) {
    memw();
    _DAT_60031018 = _DAT_60031018 | 0x4000;
    memw();
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    memw();
    _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
    memw();
    memw();
    if ((_DAT_3ffb02c0 & 0x8000) != 0) {
      memw();
      memw();
      memw();
      memw();
      memw();
      memw();
      uVar1 = _DAT_3ffb02c0 >> 0x10;
      uVar3 = _DAT_3ffb02c4 & 7;
      uVar2 = _DAT_3ffb02c0 >> 0x12;
      uVar4 = _DAT_3ffb02c4 >> 3 & 0xf;
      uVar5 = _DAT_3ffb02c4 >> 0x13 & 0x3ff;
      if ((_DAT_3ffb02c0 & 0x8000) != 0) {
        memw();
        _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
        memw();
      }
      if ((uVar1 & 0xff) == 0) {
        phy_printf("@%d %d %d",uVar3,uVar4,uVar5);
      }
      else {
        phy_printf(&DAT_00053514);
      }
      if ((uVar2 & 1) != 0) {
        phy_printf("%d %d %d",uVar3,uVar4,uVar5);
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_pcntl_fsm_print(void)

{
  u32 pcntl_fsm_data;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031050 = _DAT_60031050 & 0xffffffc0 | 0x82;
  memw();
  memw();
  uVar1 = _DAT_60031054 & 0x1f;
  if (pcntl_fsm_print_start == 0) {
    pcntl_fsm_print_start = 1;
  }
  else if (uVar1 == pcntl_fsm_data_last) {
    pcntl_fsm_data_last = uVar1;
    return;
  }
  switch(uVar1) {
  case 0:
    phy_printf("PCNTL_IDLE\n");
    break;
  case 1:
    phy_printf("PCNTL_BEFTX\n");
    break;
  case 2:
    phy_printf("PCNTL_TX_AC\n");
    break;
  case 3:
    phy_printf("PCNTL_TX_HD\n");
    break;
  case 4:
    phy_printf("PCNTL_TX_PLDH_BR\n");
    break;
  case 5:
    phy_printf("PCNTL_TX_PLD_BR\n");
    break;
  case 6:
    phy_printf("PCNTL_TX_CRC_BR\n");
    break;
  case 7:
    phy_printf("PCNTL_TX_PAD_BR\n");
    break;
  case 8:
    phy_printf("PCNTL_TX_GUARD\n");
    break;
  case 9:
    phy_printf("PCNTL_TX_SSEQ\n");
    break;
  case 10:
    phy_printf("PCNTL_TX_PLDH_EDR\n");
    break;
  case 0xb:
    phy_printf("PCNTL_TX_PLD_EDR\n");
    break;
  case 0xc:
    phy_printf("PCNTL_TX_CRC_EDR\n");
    break;
  case 0xd:
    phy_printf("PCNTL_TX_PLD_PAD\n");
    break;
  case 0xe:
    phy_printf("PCNTL_TX_STATUS\n");
    break;
  case 0xf:
    phy_printf("PCNTL_BEFRX\n");
    break;
  case 0x10:
    phy_printf("PCNTL_RX_SYNC\n");
    break;
  case 0x11:
    phy_printf("PCNTL_RX_HD\n");
    break;
  case 0x12:
    phy_printf("PCNTL_RX_PLDH_BR\n");
    break;
  case 0x13:
    phy_printf("PCNTL_RX_PLD_BR\n");
    break;
  case 0x14:
    phy_printf("PCNTL_RX_CRC\n");
    break;
  case 0x15:
    phy_printf("PCNTL_RX_GUARD\n");
    break;
  case 0x16:
    phy_printf("PCNTL_RX_PLDH_EDR\n");
    break;
  case 0x17:
    phy_printf("PCNTL_RX_PLD_EDR\n");
    break;
  case 0x18:
    phy_printf("PCNTL_RX_CRC_EDR\n");
    break;
  case 0x19:
    phy_printf("PCNTL_RX_RSSI\n");
    break;
  case 0x1a:
    phy_printf("PCNTL_RX_STATUS\n");
    break;
  case 0x1b:
    phy_printf("PCNTL_RADIO_BUSY\n");
  }
  pcntl_fsm_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_pcntl_fsm_tx_print(void)

{
  u32 pcntl_fsm_data;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031050 = _DAT_60031050 & 0xffffffc0 | 0x82;
  memw();
  memw();
  uVar1 = _DAT_60031054 & 0x1f;
  if (pcntl_fsm_print_start == 0) {
    pcntl_fsm_print_start = 1;
  }
  else if (uVar1 == pcntl_fsm_data_last) {
    pcntl_fsm_data_last = uVar1;
    return;
  }
  switch(uVar1) {
  case 1:
    phy_printf("PCNTL_BEFTX\n");
    break;
  case 2:
    phy_printf("PCNTL_TX_AC\n");
    break;
  case 3:
    phy_printf("PCNTL_TX_HD\n");
    break;
  case 4:
    phy_printf("PCNTL_TX_PLDH_BR\n");
    break;
  case 5:
    phy_printf("PCNTL_TX_PLD_BR\n");
    break;
  case 6:
    phy_printf("PCNTL_TX_CRC_BR\n");
    break;
  case 7:
    phy_printf("PCNTL_TX_PAD_BR\n");
    break;
  case 8:
    phy_printf("PCNTL_TX_GUARD\n");
    break;
  case 9:
    phy_printf("PCNTL_TX_SSEQ\n");
    break;
  case 10:
    phy_printf("PCNTL_TX_PLDH_EDR\n");
    break;
  case 0xb:
    phy_printf("PCNTL_TX_PLD_EDR\n");
    break;
  case 0xc:
    phy_printf("PCNTL_TX_CRC_EDR\n");
    break;
  case 0xd:
    phy_printf("PCNTL_TX_PLD_PAD\n");
    break;
  case 0xe:
    phy_printf("PCNTL_TX_STATUS\n");
  }
  pcntl_fsm_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_pcntl_fsm_tx_pld_print(void)

{
  u32 pcntl_fsm_data;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031050 = _DAT_60031050 & 0xffffffc0 | 0x82;
  memw();
  memw();
  uVar1 = _DAT_60031054 & 0x1f;
  if (pcntl_fsm_print_start == 0) {
    pcntl_fsm_print_start = 1;
  }
  else if (uVar1 == pcntl_fsm_data_last) {
    pcntl_fsm_data_last = uVar1;
    return;
  }
  switch(uVar1) {
  case 3:
    phy_printf("PCNTL_TX_HD\n");
    break;
  case 4:
    phy_printf("PCNTL_TX_PLDH_BR\n");
    break;
  case 5:
    phy_printf("PCNTL_TX_PLD_BR\n");
    break;
  case 6:
    phy_printf("PCNTL_TX_CRC_BR\n");
    break;
  case 7:
    phy_printf("PCNTL_TX_PAD_BR\n");
    break;
  case 8:
    phy_printf("PCNTL_TX_GUARD\n");
    break;
  case 9:
    phy_printf("PCNTL_TX_SSEQ\n");
    break;
  case 10:
    phy_printf("PCNTL_TX_PLDH_EDR\n");
    break;
  case 0xb:
    phy_printf("PCNTL_TX_PLD_EDR\n");
    break;
  case 0xc:
    phy_printf("PCNTL_TX_CRC_EDR\n");
    break;
  case 0xd:
    phy_printf("PCNTL_TX_PLD_PAD\n");
  }
  pcntl_fsm_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_fsm_print(void)

{
  u32 fsm_data;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031050 = _DAT_60031050 & 0xffffffc0 | 0x80;
  memw();
  memw();
  uVar1 = _DAT_60031054 & 0x1f;
  if (fsm_print_start == 0) {
    fsm_print_start = 1;
  }
  else if (uVar1 == fsm_data_last) {
    fsm_data_last = uVar1;
    return;
  }
  switch(uVar1) {
  case 0:
    phy_printf("FSM_IDLE\n");
    break;
  case 1:
    phy_printf("FSM_FETCH_MOD_ENTRY\n");
    break;
  case 2:
    phy_printf("FSM_FETCH_PTR_ENTRY\n");
    break;
  case 3:
    phy_printf("FSM_CHECK_ENTRY\n");
    break;
  case 4:
    phy_printf("FSM_UPDATE_ET\n");
    break;
  case 5:
    phy_printf("FSM_FETCH_CS_FORMAT\n");
    break;
  case 6:
    phy_printf("FSM_FETCH_CS_BITOFFSET\n");
    break;
  case 7:
    phy_printf("FSM_DEAD\n");
  }
  fsm_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_error_print(void)

{
  u32 error_data;
  uint uVar1;
  
  memw();
  uVar1 = _DAT_60031060 & 0x3fffff;
  if (error_print_start == 0) {
    error_print_start = 1;
  }
  else if (uVar1 == error_data_last) {
    error_data_last = uVar1;
    return;
  }
  phy_printf("error%x\n",uVar1);
  error_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_inq_tx_freq_print(u32 all)

{
  uint uVar1;
  
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_60031050 = _DAT_60031050 & 0xffffffc0 | 0xa2;
  memw();
  memw();
  uVar1 = _DAT_60031054 & 0x7f;
  if (uVar1 < 0x28) {
    uVar1 = uVar1 << 1;
  }
  else {
    uVar1 = (uVar1 + 0x7fffffd8) * 2 + 1;
  }
  if ((((_DAT_60031054 & 0x1f) == 2) && (uVar1 != inq_tx_freqlast)) &&
     ((inq_tx_freqlast = uVar1, all != 0 || (uVar1 < 0xd)))) {
    phy_printf(&DAT_000537d4);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void em_test(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  
  iVar1 = 0;
  do {
    uVar3 = (iVar1 + 0x812a) * 0x400 ^ 0xaaaa5555;
    memw();
    *(uint *)(&DAT_3ffb0000 + iVar1) = uVar3;
    memw();
    *(uint *)(iVar1 + 0x3ffb0100) = uVar3 + 0xaabb13 ^ 0xaaaa5555;
    memw();
    iVar2 = iVar1 + 4;
    if (uVar3 != *(uint *)(&DAT_3ffb0000 + iVar1)) {
      phy_printf("em check error, addr%x, data%x!\n",iVar1,uVar3);
    }
    iVar1 = iVar2;
  } while (iVar2 != 0x100);
  return;
}



// WARNING: Unknown calling convention

void rom_test(u32 base,u32 len,u32 repeat)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint *puVar5;
  uint *puVar6;
  
  iVar2 = repeat * 0x887;
  while (iVar2 = iVar2 + -0x887, iVar2 != -0x887) {
    if (len != 0) {
      puVar5 = (uint *)(base + 0x100);
      uVar3 = 0;
      do {
        uVar1 = (uVar3 + 0x812a) * 0x400 + iVar2 ^ 0xaaaa5555;
        puVar6 = puVar5 + -0x40;
        memw();
        *puVar6 = uVar1;
        memw();
        *puVar5 = uVar1 + 0xaabb13 ^ 0x55555555;
        memw();
        uVar4 = uVar3 + 4;
        if (uVar1 != *puVar6) {
          memw();
          phy_printf("rom check error, addr%x, wdata%x, rdata%x!\n",uVar3,uVar1,*puVar6);
        }
        puVar5 = puVar5 + 1;
        uVar3 = uVar4;
      } while (uVar4 < len);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void em_clean(void)

{
  memw();
  _DAT_3ffb0000 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_em_print(void)

{
  u32 uVar1;
  u32 em_data;
  
  uVar1 = _DAT_3ffb0004;
  memw();
  if (em_print_start == 0) {
    em_print_start = 1;
  }
  else if (_DAT_3ffb0004 == em_data_last) {
    em_data_last = _DAT_3ffb0004;
    return;
  }
  phy_printf("em%x\n",_DAT_3ffb0004);
  em_data_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_em_diag_print(void)

{
  u32 em_diag;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031050 = _DAT_60031050 & 0xffffffc0 | 0x8b;
  memw();
  memw();
  uVar1 = _DAT_60031054 & 0x1f;
  if (em_diag_print_start == 0) {
    em_diag_print_start = 1;
  }
  else if (uVar1 == em_diag_last) {
    em_diag_last = uVar1;
    return;
  }
  phy_printf("ed%x\n",uVar1);
  em_diag_last = uVar1;
  return;
}



// WARNING: Unknown calling convention

void rw_reg_diag_print(u32 addr,u32 *diag_last,u32 *diag_print_start,u32 label)

{
  u32 uVar1;
  
  memw();
  uVar1 = *(u32 *)addr;
  if (*diag_print_start == 0) {
    *diag_print_start = 1;
  }
  else if (uVar1 == *diag_last) goto LAB_0001bf41;
  phy_printf("diag%d %x\n",label,uVar1);
LAB_0001bf41:
  *diag_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_le_em_diag_print(void)

{
  u32 em_diag;
  uint uVar1;
  
  memw();
  memw();
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffffc0 | 0x8b;
  memw();
  memw();
  uVar1 = _DAT_60031254 & 0x1f;
  if (le_em_diag_print_start == 0) {
    le_em_diag_print_start = 1;
  }
  else if (uVar1 == le_em_diag_last) {
    le_em_diag_last = uVar1;
    return;
  }
  phy_printf("led%x\n",uVar1);
  le_em_diag_last = uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_debug_freq(u32 tx_freq,u32 rx_freq)

{
  memw();
  memw();
  _DAT_60031000 = _DAT_60031000 | 0x10000;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600310a4 = (rx_freq & 0x3f) << 8 | _DAT_600310a4 & 0xffffc0c0 | 0x10000 | tx_freq & 0x3f;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_inq_scan(void)

{
  u32 bchh;
  u32 bchl;
  
  phy_printf("\n\n\nRW BT INQ SCAN!\n");
  em_test();
  rw_bch_gen_test();
  rw_bt_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_et_init();
  memw();
  _DAT_3ffb0160 = 0;
  memw();
  _DAT_3ffb0164 = 0;
  memw();
  _DAT_3ffb0168 = 0;
  memw();
  _DAT_3ffb016c = 0;
  bchl = 0;
  bchh = 0;
  rw_bch_gen(0x9e8b33,&bchl,&bchh);
  rw_init_cs(9,0,0,0,0x9e8b33,0,bchl,bchh,0,1,0,1,1,0xff,0x3ffb02a0,100,1);
  memw();
  _DAT_3ffb02a0 = 0x1002b0;
  memw();
  _DAT_3ffb02a4 = 0x70000db;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0x1802a0;
  memw();
  _DAT_3ffb02b4 = 0x800008a;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x800;
  memw();
  memw();
  _DAT_3ffb0800 = eir_payload[0];
  memw();
  _DAT_3ffb0804 = eir_payload[1];
  memw();
  _DAT_3ffb0808 = eir_payload[2];
  memw();
  _DAT_3ffb080c = eir_payload[3];
  memw();
  _DAT_3ffb0810 = eir_payload[4];
  rw_bch_gen(0x33dead,&bchl,&bchh);
  memw();
  _DAT_3ffb0700 = bchl;
  _DAT_3ffb0704 = bchl & 3 | 0x84cf7ab4;
  memw();
  memw();
  _DAT_3ffb0708 = 0xc11ddbb;
  memw();
  _DAT_3ffb070c = 0x5a02;
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0x900;
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xa00;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  rw_bt_core_on();
  phy_printf("RW BT CORE ON\n");
  do {
    do {
      rw_pcntl_fsm_tx_print();
      rw_error_print();
      memw();
    } while ((_DAT_60031014 & 0x4000) == 0);
    rw_frm_refresh(0);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_inq_scan_cmd(u32 tx_freq,u32 rx_freq)

{
  u32 bchh;
  u32 bchl;
  
  phy_printf("\n\n\nRW BT INQ SCAN!\n");
  em_test();
  rw_bch_gen_test();
  rw_bt_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_et_init();
  memw();
  _DAT_3ffb0160 = 0;
  memw();
  _DAT_3ffb0164 = 0;
  memw();
  _DAT_3ffb0168 = 0;
  memw();
  _DAT_3ffb016c = 0;
  bchl = 0;
  bchh = 0;
  rw_bch_gen(0x9e8b33,&bchl,&bchh);
  rw_init_cs(9,0,0,0,0x9e8b33,0,bchl,bchh,0,1,0,1,1,0xff,0x3ffb02a0,100,1);
  memw();
  _DAT_3ffb02a0 = 0x1002b0;
  memw();
  _DAT_3ffb02a4 = 0x70000db;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0x1802a0;
  memw();
  _DAT_3ffb02b4 = 0x800008a;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x800;
  memw();
  memw();
  _DAT_3ffb0800 = eir_payload[0];
  memw();
  _DAT_3ffb0804 = eir_payload[1];
  memw();
  _DAT_3ffb0808 = eir_payload[2];
  memw();
  _DAT_3ffb080c = eir_payload[3];
  memw();
  _DAT_3ffb0810 = eir_payload[4];
  rw_bch_gen(0x33dead,&bchl,&bchh);
  memw();
  _DAT_3ffb0700 = bchl;
  _DAT_3ffb0704 = bchl & 3 | 0x84cf7ab4;
  memw();
  memw();
  _DAT_3ffb0708 = 0xc11ddbb;
  memw();
  _DAT_3ffb070c = 0x5a02;
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0x900;
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xa00;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_60031000 = _DAT_60031000 | 0x10000;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600310a4 = (rx_freq & 0x3f) << 8 | _DAT_600310a4 & 0xffffc0c0 | 0x10000 | tx_freq & 0x3f;
  memw();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  rw_bt_core_on();
  phy_printf("RW BT CORE ON\n");
  do {
    do {
      rw_pcntl_fsm_tx_print();
      rw_error_print();
      memw();
    } while ((_DAT_60031014 & 0x4000) == 0);
    rw_frm_refresh(0);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_page_scan_cmd(u32 debug_freq,u32 tx_freq,u32 rx_freq)

{
  u32 bchh;
  u32 bchl;
  
  phy_printf("\n\n\nRW BT PAGE SCAN!\n");
  em_test();
  rw_bch_gen_test();
  rw_bt_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_et_csb_init();
  memw();
  _DAT_3ffb0160 = 0;
  memw();
  _DAT_3ffb0164 = 0;
  memw();
  _DAT_3ffb0168 = 0;
  memw();
  _DAT_3ffb016c = 0;
  bchl = 0;
  bchh = 0;
  rw_bch_gen(0x9e8b33,&bchl,&bchh);
  rw_init_cs(5,0,0,0,0x9e8b33,0,bchl,bchh,0,1,0,1,1,0xff,0x3ffb02a0,100,1);
  memw();
  _DAT_3ffb02a0 = 0x1002b0;
  memw();
  _DAT_3ffb02a4 = 0x70000db;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0x1802a0;
  memw();
  _DAT_3ffb02b4 = 0x800008a;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x800;
  memw();
  memw();
  _DAT_3ffb0800 = eir_payload[0];
  memw();
  _DAT_3ffb0804 = eir_payload[1];
  memw();
  _DAT_3ffb0808 = eir_payload[2];
  memw();
  _DAT_3ffb080c = eir_payload[3];
  memw();
  _DAT_3ffb0810 = eir_payload[4];
  rw_bch_gen(0x33dead,&bchl,&bchh);
  memw();
  _DAT_3ffb0700 = bchl;
  _DAT_3ffb0704 = bchl & 3 | 0x84cf7ab4;
  memw();
  memw();
  _DAT_3ffb0708 = 0xc11ddbb;
  memw();
  _DAT_3ffb070c = 0x5a02;
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0x900;
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xa00;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  if (debug_freq != 0) {
    memw();
    _DAT_60031000 = _DAT_60031000 | 0x10000;
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_600310a4 = (rx_freq & 0x3f) << 8 | _DAT_600310a4 & 0xffffc0c0 | 0x10000 | tx_freq & 0x3f;
    memw();
  }
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  rw_bt_core_on();
  phy_printf("RW BT CORE ON\n");
  do {
    do {
      rw_pcntl_fsm_tx_print();
      rw_error_print();
      memw();
    } while ((_DAT_60031014 & 0x4000) == 0);
    rw_frm_refresh_pscan(1);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_mst_cmd(u32 debug_freq,u32 tx_freq,u32 rx_freq)

{
  u32 bchh;
  u32 bchl;
  
  phy_printf("\n\n\nRW BT MASTER!\n");
  em_test();
  rw_bch_gen_test();
  rw_bt_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_et_on();
  memw();
  _DAT_3ffb0160 = 0;
  memw();
  _DAT_3ffb0164 = 0;
  memw();
  _DAT_3ffb0168 = 0;
  memw();
  _DAT_3ffb016c = 0;
  bchl = 0;
  bchh = 0;
  rw_bch_gen(0x9e8b33,&bchl,&bchh);
  rw_init_cs(2,2,0,0,0x9e8b33,0,bchl,bchh,0,1,0,1,0,0x40,0x3ffb02b0,100,1);
  memw();
  _DAT_3ffb02a0 = 0x1002b0;
  memw();
  _DAT_3ffb02a4 = 0x70000db;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0x1a02a0;
  memw();
  _DAT_3ffb02b4 = 0x800008a;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x800;
  memw();
  memw();
  _DAT_3ffb0800 = eir_payload[0];
  memw();
  _DAT_3ffb0804 = eir_payload[1];
  memw();
  _DAT_3ffb0808 = eir_payload[2];
  memw();
  _DAT_3ffb080c = eir_payload[3];
  memw();
  _DAT_3ffb0810 = eir_payload[4];
  rw_bch_gen(0x33dead,&bchl,&bchh);
  memw();
  _DAT_3ffb0700 = bchl;
  _DAT_3ffb0704 = bchl & 3 | 0x84cf7ab4;
  memw();
  memw();
  _DAT_3ffb0708 = 0xc11ddbb;
  memw();
  _DAT_3ffb070c = 0x5a02;
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0x900;
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xa00;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  if (debug_freq != 0) {
    memw();
    _DAT_60031000 = _DAT_60031000 | 0x10000;
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_600310a4 = (rx_freq & 0x3f) << 8 | _DAT_600310a4 & 0xffffc0c0 | 0x10000 | tx_freq & 0x3f;
    memw();
  }
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  rw_bt_core_on();
  phy_printf("RW BT CORE ON\n");
  do {
    rw_error_print();
    memw();
    if ((_DAT_60031014 & 0x4000) != 0) {
      rw_frm_refresh(1);
    }
    rw_rx_refresh();
    rw_bb_ac_refesh();
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_set_inq_abtrain(void)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_60031024 = _DAT_60031024 & 0xfffff800 | 0x8002;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_inq(void)

{
  u32 bchh;
  u32 bchl;
  
  phy_printf("\n\n\nRW BT INQ!!!\n");
  memw();
  _DAT_3ffb0000 = 0;
  rw_bch_gen_test();
  rw_bt_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_et_init();
  memw();
  _DAT_3ffb0160 = 0;
  memw();
  _DAT_3ffb0164 = 0;
  memw();
  _DAT_3ffb0168 = 0;
  memw();
  _DAT_3ffb016c = 0;
  bchl = 0;
  bchh = 0;
  rw_bch_gen(0x9e8b33,&bchl,&bchh);
  rw_init_cs(8,0,0,0,0x9e8b33,0,bchl,bchh,4,1,0,1,0,0x30,0,100,1);
  memw();
  memw();
  memw();
  _DAT_60031024 = _DAT_60031024 & 0xfffff800 | 0x8002;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0x700;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xf000000;
  memw();
  memw();
  _DAT_3ffb02dc = 0x1300;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  rw_bt_core_on();
  phy_printf("RW BT CORE ON\n");
  do {
    rw_error_print();
    memw();
    if ((_DAT_60031014 & 0x4000) != 0) {
      rw_frm_refresh(0);
    }
    rw_rx_refresh();
    rw_bb_ac_refesh();
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_inq_cmd(u32 tx_freq,u32 rx_freq)

{
  u32 bchh;
  u32 bchl;
  
  phy_printf("\n\n\nRW BT INQ!!!\n");
  memw();
  _DAT_3ffb0000 = 0;
  rw_bch_gen_test();
  rw_bt_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_et_init();
  memw();
  _DAT_3ffb0160 = 0;
  memw();
  _DAT_3ffb0164 = 0;
  memw();
  _DAT_3ffb0168 = 0;
  memw();
  _DAT_3ffb016c = 0;
  bchl = 0;
  bchh = 0;
  rw_bch_gen(0x9e8b33,&bchl,&bchh);
  rw_init_cs(8,0,0,0,0x9e8b33,0,bchl,bchh,0,1,0,1,0,0x35,0,1000,1);
  memw();
  _DAT_3ffb02a0 = 0x1002b0;
  memw();
  _DAT_3ffb02a4 = 0x70000db;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0x1802a0;
  memw();
  _DAT_3ffb02b4 = 0x800008a;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x800;
  memw();
  memw();
  _DAT_3ffb0800 = eir_payload[0];
  memw();
  _DAT_3ffb0804 = eir_payload[1];
  memw();
  _DAT_3ffb0808 = eir_payload[2];
  memw();
  _DAT_3ffb080c = eir_payload[3];
  memw();
  _DAT_3ffb0810 = eir_payload[4];
  rw_bch_gen(0x33dead,&bchl,&bchh);
  memw();
  _DAT_3ffb0700 = bchl;
  _DAT_3ffb0704 = bchl & 3 | 0x84cf7ab4;
  memw();
  memw();
  _DAT_3ffb0708 = 0xc11ddbb;
  memw();
  _DAT_3ffb070c = 0x5a02;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0x700;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xf000000;
  memw();
  memw();
  _DAT_3ffb02dc = 0x1300;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_60031000 = _DAT_60031000 | 0x10000;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600310a4 = (rx_freq & 0x3f) << 8 | _DAT_600310a4 & 0xffffc0c0 | 0x10000 | tx_freq & 0x3f;
  memw();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  rw_bt_core_on();
  phy_printf("RW BT CORE ON\n");
  do {
    rw_error_print();
    memw();
    if ((_DAT_60031014 & 0x4000) != 0) {
      rw_frm_refresh(0);
    }
    rw_rx_refresh();
    rw_bb_ac_refesh();
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_page_cmd(u32 debug_freq,u32 tx_freq,u32 rx_freq)

{
  u32 bchh;
  u32 bchl;
  u32 uStack_30;
  
  phy_printf("\n\n\nRW BT PAGE!!!\n");
  memw();
  _DAT_3ffb0000 = 0;
  rw_bch_gen_test();
  rw_bt_core_off();
  rw_init_em_radio_table();
  rw_dm_activate();
  rw_et_csb_init();
  memw();
  _DAT_3ffb0160 = 0;
  memw();
  _DAT_3ffb0164 = 0;
  memw();
  _DAT_3ffb0168 = 0;
  memw();
  _DAT_3ffb016c = 0;
  bchl = 0;
  bchh = 0;
  uStack_30 = 0x9e8b33;
  rw_bch_gen(0x9e8b33,&bchl,&bchh);
  rw_init_cs(4,0,0,0,uStack_30,0,bchl,bchh,0,1,0,1,0,0x35,0x3ffb02a0,1000,1);
  memw();
  _DAT_3ffb02a0 = 0x1002b0;
  memw();
  _DAT_3ffb02a4 = 0x70000db;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0x1802a0;
  memw();
  _DAT_3ffb02b4 = 0x800008a;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x800;
  memw();
  memw();
  _DAT_3ffb0800 = eir_payload[0];
  memw();
  _DAT_3ffb0804 = eir_payload[1];
  memw();
  _DAT_3ffb0808 = eir_payload[2];
  memw();
  _DAT_3ffb080c = eir_payload[3];
  memw();
  _DAT_3ffb0810 = eir_payload[4];
  rw_bch_gen(0x33dead,&bchl,&bchh);
  memw();
  _DAT_3ffb0700 = bchl;
  _DAT_3ffb0704 = bchl & 3 | 0x84cf7ab4;
  memw();
  memw();
  _DAT_3ffb0708 = 0xc11ddbb;
  memw();
  _DAT_3ffb070c = 0x5a02;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0x700;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xf000000;
  memw();
  memw();
  _DAT_3ffb02dc = 0x1300;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  if (debug_freq != 0) {
    memw();
    _DAT_60031000 = _DAT_60031000 | 0x10000;
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_600310a4 = (rx_freq & 0x3f) << 8 | _DAT_600310a4 & 0xffffc0c0 | 0x10000 | tx_freq & 0x3f;
    memw();
  }
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  rw_bt_core_on();
  phy_printf("RW BT CORE ON\n");
  do {
    rw_pcntl_fsm_tx_pld_print();
    rw_error_print();
    memw();
    if ((_DAT_60031014 & 0x4000) != 0) {
      rw_frm_refresh(1);
    }
    rw_rx_refresh();
    rw_bb_ac_refesh();
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_tx_test(u32 txpwr,u32 hoppe,u32 freq,u32 edr,u32 type,u32 length,u32 et_mask,u32 data_type,
               u32 tx_num_in)

{
  int iVar1;
  undefined4 *puVar2;
  u32 bchh;
  u32 bchl;
  u32 uStack_30;
  u32 uStack_2c;
  u32 uStack_28;
  
  bchl = 0;
  bchh = 0;
  uStack_2c = 0;
  uStack_28 = length;
  phy_printf("RW TX TEST\n");
  prbs9_gen(PRBS9);
  memw();
  _DAT_3ff4609c = _DAT_3ff4609c | 0x80000000;
  memw();
  phy_bt_pll_track(true);
  rw_test_init();
  uStack_30 = 0x6bc6967e;
  rw_bch_gen(0x6bc6967e,&bchl,&bchh);
  rw_init_cs(2,2,edr,1,uStack_30,uStack_2c,bchl,bchh,txpwr,hoppe,freq,uStack_2c,uStack_2c,0x2a,
             0x3ffb02a0,0xff,1);
  if (data_type == 0) {
    memw();
    memw();
    _DAT_3ffb0700 = 0x55555555;
  }
  else if (data_type == 1) {
    memw();
    memw();
    _DAT_3ffb0700 = 0xf0f0f0f0;
  }
  else {
    _DAT_3ffb0700 = PRBS9[0];
    memw();
    memw();
  }
  _DAT_3ffb02b0 = (type & 0xf) << 0x13;
  _DAT_3ffb02a0 = _DAT_3ffb02b0 | 0x8202b0;
  memw();
  _DAT_3ffb02a4 = (uStack_28 & 0x3ff) << 3 | 0x3000006;
  memw();
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  _DAT_3ffb02b0 = _DAT_3ffb02b0 | 0x8202a0;
  memw();
  memw();
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0x900;
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xa00;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  _DAT_3ffb02b4 = _DAT_3ffb02a4;
  _DAT_3ffb0300 = _DAT_3ffb0700;
  rw_bt_core_on();
  memw();
  puVar2 = (undefined4 *)&DAT_3ffb0000;
  _DAT_6003102c = _DAT_6003102c & 0xffff;
  memw();
  iVar1 = 0x10;
  do {
    if ((et_mask & 1) == 0) {
      memw();
      *puVar2 = 0;
    }
    else {
      memw();
      *puVar2 = 0x2000301;
    }
    et_mask = et_mask >> 1;
    puVar2 = puVar2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  run_end = 0;
  bt_tx_num = 0;
  while( true ) {
    memw();
    if ((_DAT_3ff51030 & 0x200) != 0) {
      rw_txpwr_regulate();
    }
    memw();
    if ((_DAT_3ff51030 & 0x40) != 0) {
      rw_bb_tx_refesh();
    }
    memw();
    if ((_DAT_60031014 & 0x4000) != 0) {
      rw_frm_refresh(1);
    }
    if (run_end != 0) break;
    if (frm_refresh_ind != 0) {
      frm_refresh_ind = run_end;
    }
    if ((tx_num_in != 0) && (tx_num_in <= bt_tx_num)) {
      return;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_tx_test_init(u32 txpwr,u32 hoppe,u32 freq,u32 edr,u32 type,u32 length,u32 et_mask)

{
  u32 bchh;
  u32 bchl;
  u32 uStack_30;
  u32 uStack_2c;
  u32 uStack_28;
  
  bchl = 0;
  bchh = 0;
  uStack_2c = 0;
  uStack_28 = length;
  phy_printf("RW TX TEST INIT\n");
  prbs9_gen(PRBS9);
  memw();
  _DAT_3ff4609c = _DAT_3ff4609c | 0x80000000;
  memw();
  phy_bt_pll_track(true);
  phy_bt_power_track(true);
  rw_test_init();
  uStack_30 = 0x6bc6967e;
  rw_bch_gen(0x6bc6967e,&bchl,&bchh);
  rw_init_cs(2,2,edr,1,uStack_30,uStack_2c,bchl,bchh,txpwr,hoppe,freq,uStack_2c,uStack_2c,0x2a,
             0x3ffb02a0,0xff,1);
  memw();
  _DAT_3ffb0300 = PRBS9[0];
  memw();
  _DAT_3ffb0700 = PRBS9[0];
  _DAT_3ffb02b0 = (type & 0xf) << 0x13;
  _DAT_3ffb02a0 = _DAT_3ffb02b0 | 0x8202b0;
  _DAT_3ffb02a4 = (uStack_28 & 0x3ff) << 3 | 0x3000006;
  memw();
  memw();
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  _DAT_3ffb02b0 = _DAT_3ffb02b0 | 0x8202a0;
  memw();
  memw();
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0x900;
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xa00;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  _DAT_3ffb02b4 = _DAT_3ffb02a4;
  rw_bt_core_on();
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff;
  if ((et_mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000301;
  }
  run_end = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_inq_test_init(u32 txpwr,u32 hoppe,u32 freq,u32 edr,u32 type,u32 length,u32 et_mask)

{
  u32 bchh;
  u32 bchl;
  u32 uStack_30;
  u32 uStack_2c;
  u32 uStack_28;
  
  bchl = 0;
  bchh = 0;
  uStack_2c = 0;
  uStack_28 = length;
  phy_printf("RW INQ TEST INIT\n");
  prbs9_gen(PRBS9);
  memw();
  _DAT_3ff4609c = _DAT_3ff4609c | 0x80000000;
  memw();
  phy_bt_pll_track(true);
  phy_bt_power_track(true);
  rw_test_init();
  uStack_30 = 0x9e8b33;
  rw_bch_gen(0x9e8b33,&bchl,&bchh);
  rw_init_cs(8,uStack_2c,edr,uStack_2c,uStack_30,uStack_2c,bchl,bchh,txpwr,hoppe,freq,uStack_2c,
             uStack_2c,0x30,uStack_2c,0xff,1);
  memw();
  _DAT_3ffb0300 = PRBS9[0];
  memw();
  _DAT_3ffb0700 = PRBS9[0];
  _DAT_3ffb02b0 = (type & 0xf) << 0x13;
  _DAT_3ffb02a4 = (uStack_28 & 0x3ff) << 3 | 0x3000006;
  _DAT_3ffb02a0 = _DAT_3ffb02b0 | 0x8202b0;
  memw();
  memw();
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  _DAT_3ffb02b0 = _DAT_3ffb02b0 | 0x8202a0;
  memw();
  memw();
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0x900;
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xa00;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  memw();
  memw();
  _DAT_60031024 = _DAT_60031024 & 0xfffff800 | 0x8002;
  memw();
  _DAT_3ffb02b4 = _DAT_3ffb02a4;
  rw_bt_core_on();
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff;
  if ((et_mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000301;
  }
  run_end = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_tx_test_wifi_tx(u32 txpwr,u32 hoppe,u32 freq,u32 edr,u32 type,u32 length,u32 et_mask)

{
  bool bVar1;
  int iVar2;
  u32 bchh;
  u32 bchl;
  u32 uStack_30;
  u32 uStack_2c;
  u32 uStack_28;
  
  bchl = 0;
  bchh = 0;
  uStack_2c = 0;
  uStack_30 = txpwr;
  uStack_28 = length;
  phy_printf("RW TX TEST\n");
  prbs9_gen(PRBS9);
  memw();
  _DAT_3ff4609c = _DAT_3ff4609c | 0x80000000;
  memw();
  rw_test_init();
  rw_bch_gen(0x6bc6967e,&bchl,&bchh);
  rw_init_cs(2,2,edr,1,0x6bc6967e,uStack_2c,bchl,bchh,uStack_30,hoppe,freq,uStack_2c,uStack_2c,0x2a,
             0x3ffb02a0,0xff,1);
  memw();
  _DAT_3ffb0300 = PRBS9[0];
  memw();
  _DAT_3ffb0700 = PRBS9[0];
  _DAT_3ffb02b0 = (type & 0xf) << 0x13;
  _DAT_3ffb02a0 = _DAT_3ffb02b0 | 0x8202b0;
  _DAT_3ffb02a4 = (uStack_28 & 0x3ff) << 3 | 0x3000006;
  memw();
  memw();
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  _DAT_3ffb02b0 = _DAT_3ffb02b0 | 0x8202a0;
  memw();
  memw();
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2d0;
  memw();
  _DAT_3ffb02c4 = 0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0x900;
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  _DAT_3ffb02d4 = 0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0xa00;
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  _DAT_3ffb02b4 = _DAT_3ffb02a4;
  rw_bt_core_on();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff;
  memw();
  if ((et_mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    _DAT_3ffb0000 = 0x2000301;
  }
  bVar1 = false;
  run_end = 0;
  memw();
  iVar2 = _DAT_60033c00;
  while( true ) {
    rw_error_print();
    memw();
    if ((_DAT_3ff51030 & 0x40) != 0) {
      rw_bb_tx_refesh();
    }
    memw();
    if (bVar1) {
      bVar1 = true;
      if (1000 < (uint)(_DAT_60033c00 - iVar2)) {
        unforce_wifi_mode();
        iVar2 = _DAT_60033c00;
        memw();
        phy_printf(&DAT_000538f8);
        bVar1 = false;
      }
    }
    else if (1000 < (uint)(_DAT_60033c00 - iVar2)) {
      force_wifi_mode(1);
      iVar2 = _DAT_60033c00;
      memw();
      phy_printf(&DAT_000538fc);
      bVar1 = true;
    }
    memw();
    if ((_DAT_60031014 & 0x4000) != 0) {
      rw_frm_refresh(1);
    }
    if (run_end != 0) break;
    if (frm_refresh_ind != 0) {
      frm_refresh_ind = run_end;
    }
    WifiTxStart(0xa0017,1,100,0,0,1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void fe_force_tx_tone(u32 wifi_chan)

{
  RFChannelSel((int8)wifi_chan,'\0');
  memw();
  memw();
  memw();
  _DAT_600060a0 = _DAT_600060a0 & 0xfffff0ff | 0x30e00;
  memw();
  (*g_phyFuns->start_tx_tone_step_)(true,0,'(',false,0,'\0');
  return;
}



// WARNING: Unknown calling convention

void bt_force_tx_tone(u32 start,u32 bt_chan,u32 power)

{
  if (start != 0) {
    (*g_phyFuns->start_tx_tone_step_)(true,1,(uint8)power,false,0,'\0');
    phy_printf("BT TX TONE START!\n");
    return;
  }
  (*g_phyFuns->start_tx_tone_step_)(false,0,(uint8)power,false,0,'\0');
  phy_printf("BT TX TONE STOP!\n");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void wifi_tx_coex_init(void)

{
  mac_init();
  return;
}



// WARNING: Unknown calling convention

void force_wifi_toggle(u32 n)

{
  if (n != 0) {
    do {
      force_wifi_mode(1);
      n = n - 1;
      ets_delay_us(100);
      unforce_wifi_mode();
    } while (n != 0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void RW_stop_radiocntl(void)

{
  memw();
  memw();
  _DAT_60031300 = _DAT_60031300 | 0xf0;
  memw();
  memw();
  _DAT_60033d40 = _DAT_60033d40 & 0xfffffe3f | 0x100;
  memw();
  memw();
  _DAT_600041c8 = _DAT_600041c8 | 0x40;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void RW_resume_radiocntl(void)

{
  memw();
  memw();
  _DAT_60031300 = _DAT_60031300 & 0xffffff0f;
  memw();
  memw();
  _DAT_600041c8 = _DAT_600041c8 & 0xffffffbf;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t0_toggle_force_wifi(void)

{
  memw();
  _DAT_6001f000 = _DAT_6001f000 | 0x400;
  memw();
  memw();
  _DAT_6001f0a4 = _DAT_6001f0a4 | 1;
  memw();
  memw();
  _DAT_6001f010 = t_force_wifi;
  if (force_w_on != 0) {
    unforce_wifi_mode();
    memw();
    memw();
    memw();
    memw();
    force_w_on = 0;
    _DAT_600041c8 = _DAT_600041c8 & 0xffffffbf;
    _DAT_60031300 = _DAT_60031300 & 0xffffff0f;
    return;
  }
  memw();
  _DAT_60031300 = _DAT_60031300 | 0xf0;
  memw();
  memw();
  _DAT_60033d40 = _DAT_60033d40 & 0xfffffe3f | 0x100;
  memw();
  memw();
  _DAT_600041c8 = _DAT_600041c8 | 0x40;
  memw();
  force_wifi_mode(1);
  memw();
  memw();
  _DAT_60031300 = _DAT_60031300 | 0xf0;
  memw();
  memw();
  memw();
  memw();
  force_w_on = 1;
  _DAT_600041c8 = _DAT_600041c8 | 0x40;
  _DAT_60033d40 = _DAT_60033d40 & 0xfffffe3f | 0x100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t0_toggle_scan_check(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  memw();
  _DAT_6001f000 = _DAT_6001f000 | 0x400;
  memw();
  memw();
  _DAT_6001f0a4 = _DAT_6001f0a4 | 1;
  memw();
  phy_printf(&DAT_00053928);
  uVar1 = _DAT_60031254;
  if (last_scan_event_end != 0) {
    last_scan_event_end = 0;
    return;
  }
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffff00 | 0x82;
  memw();
  memw();
  phy_printf("rx%1d pktemfsm%1x pktfsm%1x\n",0,0,0);
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffff00 | 0x83;
  memw();
  memw();
  phy_printf("diag03 %x\n",_DAT_60031254 & 0xff);
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffff00 | 0x81;
  memw();
  memw();
  phy_printf("diag01 evt cnt fsm %x\n",_DAT_60031254 & 0xff);
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffff00 | 0x93;
  memw();
  memw();
  phy_printf("diag019 %x\n",_DAT_60031254 & 0xff);
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffff00 | 0xad;
  memw();
  memw();
  uVar3 = _DAT_60031254 & 0xff;
  phy_printf("diag045 %x\n",uVar3);
  uVar2 = _DAT_60031254;
  memw();
  _DAT_60031250 = _DAT_60031250 & 0xffffff00 | 0xa8;
  memw();
  memw();
  phy_printf("diag040 %x\n\n",uVar3);
  if (((uVar1 & 0x7f) == 0) && (((uVar2 & 0xf) - 3 & 0xfffffffd) == 0)) {
    phy_printf("git\n\n");
  }
  memw();
  memw();
  _DAT_60033d40 = _DAT_60033d40 & 0xffffffc7 | 0x20;
  memw();
  memw();
  _DAT_60031300 = _DAT_60031300 | 0xf0;
  rw_scan_abort = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t0_toggle_adv_check(void)

{
  memw();
  _DAT_6001f000 = _DAT_6001f000 | 0x400;
  memw();
  memw();
  _DAT_6001f0a4 = _DAT_6001f0a4 | 1;
  memw();
  phy_printf(&DAT_000539a0,le_rx_n);
  le_rx_n = 0;
  memw();
  if ((_DAT_60031200 & 0x100) == 0) {
    memw();
    _DAT_6001f000 = _DAT_6001f000 & 0xfffffbff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t1_toggle_refresh_rw(void)

{
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  memw();
  memw();
  _DAT_6001f0a4 = _DAT_6001f0a4 | 2;
  memw();
  rw_error_print();
  rw_frm_refresh_no_cmd(1);
  memw();
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t1_toggle_check_rx(void)

{
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  memw();
  memw();
  _DAT_6001f0a4 = _DAT_6001f0a4 | 2;
  memw();
  rw_error_print();
  rw_frm_refresh_check_rx();
  memw();
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t1_toggle_refresh_rw_le(void)

{
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  memw();
  memw();
  _DAT_6001f0a4 = _DAT_6001f0a4 | 2;
  memw();
  rw_le_error_print();
  rw_evt_refresh(1);
  memw();
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t1_toggle_refresh_rw_le_check_rx(void)

{
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  memw();
  memw();
  _DAT_6001f0a4 = _DAT_6001f0a4 | 2;
  memw();
  rw_le_error_print();
  rw_evt_refresh_check_rx(1);
  memw();
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t1_toggle_refresh_rw_le_advscan(void)

{
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  memw();
  memw();
  _DAT_6001f0a4 = _DAT_6001f0a4 | 2;
  memw();
  rw_le_error_print();
  rw_le_scan_print(0x3ffb02c0,0,0x345773);
  rw_le_scan_refresh(1,8000);
  memw();
  memw();
  _DAT_6001f024 = _DAT_6001f024 | 0x400;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void fcc_bt_en(void)

{
  phy_printf("FCC BT EN\n");
  (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\x02','\x05','\x04','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\0','\x03','\x02','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x02','\a','\a','\x01');
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x02','\x03','\0','\x04');
  return;
}



// WARNING: Unknown calling convention

void fcc_tx(u32 txpwr,u32 hoppe,u32 chan,u32 rate,u32 DH_type,u32 data_type,u32 tx_num_in)

{
  u32 edr;
  u32 type;
  u32 length;
  
  if (DH_type == 1) {
    if (rate == 1) {
      edr = 0;
      length = 0x1b;
      type = 4;
      goto LAB_0001eb4b;
    }
    edr = 1;
    if (rate == 2) {
      length = 0x36;
      type = 4;
      goto LAB_0001eb4b;
    }
    if (rate == 3) {
      length = 0x53;
      type = 8;
      goto LAB_0001eb4b;
    }
  }
  else if (DH_type == 3) {
    if (rate == 1) {
      edr = 0;
      length = 0xb7;
      type = 0xb;
      goto LAB_0001eb4b;
    }
    if (rate == 2) {
      edr = 1;
      length = 0x16f;
      type = 10;
      goto LAB_0001eb4b;
    }
    if (rate == 3) {
      edr = 1;
      length = 0x228;
      type = 0xb;
      goto LAB_0001eb4b;
    }
  }
  else {
    if (DH_type != 5) {
      phy_printf("DH_type error %d, should input 1/3/5\n",DH_type);
      edr = 0;
      length = 0x153;
      type = 0xf;
      goto LAB_0001eb4b;
    }
    if (rate == 1) {
      edr = 0;
      length = 0x153;
      type = 0xf;
      goto LAB_0001eb4b;
    }
    if (rate == 2) {
      edr = 1;
      length = 0x2a7;
      type = 0xe;
      goto LAB_0001eb4b;
    }
    if (rate == 3) {
      edr = 1;
      length = 0x3fd;
      type = 0xf;
      goto LAB_0001eb4b;
    }
  }
  phy_printf("rate error %d, should input 1/2/3\n",rate);
  edr = 0;
  length = 0x153;
  type = 0xf;
LAB_0001eb4b:
  rw_tx_test(txpwr,hoppe,(chan & 1) * 0x28 + (chan >> 1),edr,type,length,0xffff,data_type,tx_num_in)
  ;
  return;
}



// WARNING: Unknown calling convention

void fcc_tx_len(u32 txpwr,u32 hoppe,u32 chan,u32 rate,u32 length,u32 data_type,u32 tx_num_in)

{
  u32 uVar1;
  char *pcVar2;
  u32 edr;
  u32 type;
  
  if (rate == 1) {
    if (length < 0x1c) {
      edr = 0;
      type = 4;
      goto LAB_0001ec48;
    }
    if (length < 0xb8) {
      edr = 0;
      type = 0xb;
      goto LAB_0001ec48;
    }
    uVar1 = 0x153;
    edr = 0;
    type = 0xf;
    pcVar2 = "length %d error, it must be [0, 339]\n";
    if (length < 0x154) goto LAB_0001ec48;
  }
  else if (rate == 2) {
    if (length < 0x37) {
      edr = 1;
      type = 4;
      goto LAB_0001ec48;
    }
    if (length < 0x170) {
      edr = 1;
      type = 10;
      goto LAB_0001ec48;
    }
    uVar1 = 0x2a7;
    edr = 1;
    type = 0xe;
    pcVar2 = "length %d error, it must be [0, 679]\n";
    if (length < 0x2a8) goto LAB_0001ec48;
  }
  else {
    if (rate != 3) {
      phy_printf("rate error %d, should input 1/2/3\n",rate);
      edr = 0;
      type = 0xf;
      goto LAB_0001ec48;
    }
    if (length < 0x54) {
      edr = 1;
      type = 8;
      goto LAB_0001ec48;
    }
    if (length < 0x229) {
      edr = 1;
      type = 0xb;
      goto LAB_0001ec48;
    }
    uVar1 = 0x3fd;
    edr = 1;
    type = 0xf;
    if (length < 0x3fe) goto LAB_0001ec48;
    pcVar2 = "length %d error, it must be [0, 1021]\n";
  }
  phy_printf(pcVar2,uVar1);
  length = uVar1;
LAB_0001ec48:
  rw_tx_test(txpwr,hoppe,(chan & 1) * 0x28 + (chan >> 1),edr,type,length,0xffff,data_type,tx_num_in)
  ;
  return;
}



// WARNING: Removing unreachable block (ram,0x0001ef09)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_rx_per(u32 edr,u32 chan)

{
  STATUS SVar1;
  uint uVar2;
  u32 bchh;
  u32 bchl;
  u32 gain;
  u32 pwr_full_band;
  u32 pwr_in_band;
  int iStack_90;
  int iStack_8c;
  int iStack_88;
  int iStack_84;
  int iStack_80;
  int iStack_7c;
  int iStack_78;
  int iStack_74;
  int iStack_70;
  uint uStack_6c;
  uint uStack_68;
  uint uStack_64;
  int iStack_60;
  uint uStack_5c;
  uint uStack_58;
  uint uStack_54;
  uint uStack_50;
  int iStack_4c;
  u32 uStack_48;
  int iStack_44;
  int iStack_40;
  int iStack_3c;
  int iStack_38;
  uint uStack_34;
  uint uStack_30;
  
  memw();
  pwr_in_band = 0;
  pwr_full_band = 0;
  gain = 0;
  bchl = 0;
  bchh = 0;
  _DAT_3ff51098 = _DAT_3ff51098 | 0xc0000000;
  memw();
  rw_test_init();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  memw();
  if ((_DAT_3ffb02c0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    memw();
  }
  memw();
  if ((_DAT_3ffb02d0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
  }
  rw_bch_gen(0x6bc6967e,&bchl,&bchh);
  rw_init_cs(3,0,edr,1,0x6bc6967e,0,bchl,bchh,0,0,chan,0,1,0x14,0,5,1);
  memw();
  _DAT_3ffb02a0 = 0xda02b0;
  memw();
  _DAT_3ffb02a4 = 0x3000fa6;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0xda02a0;
  memw();
  _DAT_3ffb02b4 = 0x3000fa6;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x700;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0xb00;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0x7000000;
  memw();
  memw();
  _DAT_3ffb02dc = 0x700;
  memw();
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0x8000 | 0x2c0;
  memw();
  memw();
  _DAT_3ffb0000 = 0x2000301;
  rw_bt_core_on();
  phy_printf("RW RX PER\n");
  uVar2 = 0;
  uStack_6c = 0;
  uStack_68 = 0;
  uStack_5c = 0;
  uStack_58 = 0;
  uStack_64 = 0;
  uStack_54 = 0;
  uStack_50 = 0;
  iStack_70 = 0;
  iStack_74 = 0;
  iStack_78 = 0;
  iStack_7c = 0;
  iStack_80 = 0;
  iStack_84 = 0;
  iStack_88 = 0;
  iStack_8c = 0;
  iStack_38 = 0;
  iStack_3c = 0;
  iStack_40 = 0;
  iStack_44 = 0;
  iStack_4c = 0;
  uStack_48 = 0;
  iStack_60 = 0;
  iStack_90 = 0;
  do {
    memw();
    if ((_DAT_3ff51030 & 2) != 0) {
      rw_bb_rx_refesh();
    }
    ets_delay_us(0x14);
    do {
      memw();
    } while ((_DAT_60031014 & 0x4000) == 0);
    memw();
    _DAT_60031018 = _DAT_60031018 | 0x4000;
    memw();
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    memw();
    if ((_DAT_3ffb02c0 & 0x8000) != 0) {
      memw();
      memw();
      uStack_50 = _DAT_3ffb02c0 >> 0x17 & 1;
      uStack_54 = _DAT_3ffb02c0 >> 0x16 & 1;
      uStack_64 = _DAT_3ffb02c0 >> 0x15 & 1;
      uStack_58 = _DAT_3ffb02c0 >> 0x14 & 1;
      uStack_5c = _DAT_3ffb02c0 >> 0x13 & 1;
      uStack_68 = _DAT_3ffb02c0 >> 0x12 & 1;
      uStack_6c = _DAT_3ffb02c0 >> 0x11 & 1;
      uVar2 = _DAT_3ffb02c0 >> 0x10 & 1;
      if ((_DAT_3ffb02c0 & 0x8000) != 0) {
        memw();
        _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
        memw();
      }
    }
    if (uVar2 == 0) {
      if (uStack_6c == 0) {
        if (uStack_68 == 0) {
          if (uStack_64 == 0) {
            if (uStack_5c == 0) {
              if (uStack_58 == 0) {
                if (uStack_54 == 0) {
                  if (uStack_50 == 0) {
                    memw();
                    memw();
                    memw();
                    pwr_full_band = (pwr_full_band + 0x100) - (_DAT_3ff51078 >> 0x18);
                    gain = gain + (_DAT_3ff51078 >> 0x10 & 0xff);
                    pwr_in_band = (pwr_in_band + 0x100) - (_DAT_3ff51074 & 0xff);
                    uStack_48 = uStack_48 + 1;
                  }
                  else {
                    iStack_38 = iStack_38 + 1;
                  }
                }
                else {
                  iStack_40 = iStack_40 + 1;
                }
              }
              else {
                iStack_3c = iStack_3c + 1;
              }
            }
            else {
              iStack_44 = iStack_44 + 1;
            }
          }
        }
        else {
          iStack_4c = iStack_4c + 1;
        }
      }
      else {
        iStack_60 = iStack_60 + 1;
      }
      memw();
      uStack_34 = (uint)((_DAT_3ff51050 & 0x80) != 0);
      uStack_30 = _DAT_3ff51050 & 1;
      iStack_90 = iStack_90 + 1;
      iStack_8c = iStack_8c + uStack_34;
      iStack_88 = iStack_88 + (uint)((_DAT_3ff51050 & 0x40) != 0);
      iStack_84 = iStack_84 + (uint)((_DAT_3ff51050 & 0x20) != 0);
      iStack_78 = iStack_78 + (uint)((_DAT_3ff51050 & 0x10) != 0);
      iStack_80 = iStack_80 + (uint)((_DAT_3ff51050 & 8) != 0);
      iStack_74 = iStack_74 + (uint)((_DAT_3ff51050 & 4) != 0);
      iStack_7c = iStack_7c + (uint)((_DAT_3ff51050 & 2) != 0);
      iStack_70 = iStack_70 + uStack_30;
    }
    memw();
    memw();
    SVar1 = GetStopCmd();
  } while ((SVar1 != BUSY) && (SVar1 != OK && SVar1 != BUSY));
  get_bt_rx_rssi(&pwr_in_band,&gain,&pwr_full_band,uStack_48);
  phy_printf("%x %x %x %x %x %x %x %x w %x %x %x %x %x %x %x %x p %x %x %x\n",iStack_90,uStack_48,
             iStack_60,iStack_4c,iStack_44,iStack_3c,iStack_40,iStack_38,iStack_8c,iStack_88,
             iStack_7c,iStack_80,iStack_84,iStack_70,iStack_74,iStack_78,pwr_in_band,pwr_full_band,
             gain);
  return;
}



// WARNING: Unknown calling convention

void rw_rx_prbs9_status(u32 desc_addr,u32 *total_bits,u32 *err_bits)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  u32 last_mask;
  uint uVar4;
  uint uVar5;
  u32 uVar6;
  uint *puVar7;
  u32 *puVar8;
  
  memw();
  memw();
  uVar4 = *(uint *)(desc_addr + 8);
  uVar2 = *(uint *)(desc_addr + 4) & 0x1ff80000;
  uVar1 = uVar2 >> 0x13;
  uVar3 = uVar1 & 3;
  uVar2 = uVar2 >> 0x15;
  uVar5 = 0xffff;
  if (((uVar3 != 2) && (uVar5 = 0xffffff, uVar3 != 3)) && (uVar5 = 0, uVar3 == 1)) {
    uVar5 = 0xff;
  }
  uVar6 = 0;
  puVar8 = PRBS9;
  *err_bits = 0;
  puVar7 = (uint *)(&DAT_3ffb0000 + (uVar4 >> 0x10));
  uVar3 = 0;
  do {
    memw();
    uVar4 = *puVar7 ^ *puVar8;
    if (uVar3 == uVar2) {
      uVar4 = uVar5 & uVar4;
    }
    uVar6 = uVar6 + (uVar4 & 1);
    *err_bits = uVar6;
    uVar3 = uVar3 + 1;
    puVar7 = puVar7 + 1;
    puVar8 = puVar8 + 1;
  } while (uVar3 != uVar2 + 1);
  *total_bits = uVar1 << 3;
  return;
}



// WARNING: Unknown calling convention

bool esp_get_btrx_result(int32 *rx_result)

{
  bool bVar1;
  int32 iVar2;
  
  iVar2 = rx_result[2];
  *rx_result = btrx_result[0];
  if (iVar2 != 0) {
    iVar2 = (-btrx_result[3] - btrx_result[2]) / btrx_result[1];
  }
  rx_result[1] = iVar2;
  rx_result[2] = btrx_result[1];
  bVar1 = btrx_valid;
  rx_result[3] = btrx_result[4];
  rx_result[4] = btrx_result[5];
  return bVar1;
}



// WARNING: Removing unreachable block (ram,0x0001f5bd)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_rx_per_ulap(u32 edr,u32 chan,u32 ulap,u32 ltaddr)

{
  STATUS SVar1;
  u32 get_err_bits;
  u32 get_total_bits;
  u32 bchh;
  u32 bchl;
  u32 gain;
  u32 pwr_full_band;
  u32 pwr_in_band;
  u32 uStack_b0;
  uint uStack_ac;
  int32 iStack_a8;
  int32 iStack_a4;
  int32 iStack_a0;
  int iStack_9c;
  int iStack_98;
  int iStack_94;
  int iStack_90;
  int iStack_8c;
  int iStack_88;
  int iStack_84;
  int iStack_80;
  uint uStack_7c;
  uint uStack_78;
  int iStack_74;
  uint uStack_70;
  uint uStack_6c;
  uint uStack_68;
  int iStack_64;
  uint uStack_60;
  uint uStack_5c;
  int iStack_58;
  int iStack_54;
  int iStack_50;
  int iStack_4c;
  uint uStack_48;
  uint uStack_44;
  uint uStack_40;
  uint uStack_3c;
  uint uStack_38;
  uint uStack_34;
  uint uStack_30;
  int iStack_2c;
  
  btrx_valid = false;
  memw();
  pwr_in_band = 0;
  pwr_full_band = 0;
  gain = 0;
  bchl = 0;
  bchh = 0;
  _DAT_3ff51098 = _DAT_3ff51098 | 0xc0000000;
  memw();
  rw_test_init();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  memw();
  if ((_DAT_3ffb02c0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    memw();
  }
  memw();
  if ((_DAT_3ffb02d0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
  }
  rw_bch_gen(ulap,&bchl,&bchh);
  rw_init_cs(3,ltaddr,edr,1,ulap,0,bchl,bchh,0,0,chan,0,1,0x14,0,5,1);
  memw();
  _DAT_3ffb02a0 = 0xda02b0;
  memw();
  _DAT_3ffb02a4 = 0x3000fa6;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0xda02a0;
  memw();
  _DAT_3ffb02b4 = 0x3000fa6;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x700;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0xb00;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0x7000000;
  memw();
  memw();
  _DAT_3ffb02dc = 0x700;
  memw();
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0x8000 | 0x2c0;
  memw();
  memw();
  _DAT_3ffb0000 = 0x2000301;
  rw_bt_core_on();
  prbs9_gen(PRBS9);
  phy_printf("RW RX PER\n");
  uStack_ac = 0;
  get_total_bits = 0;
  get_err_bits = 0;
  uStack_78 = 0;
  uStack_68 = 0;
  uStack_5c = 0;
  uStack_44 = 0;
  uStack_60 = 0;
  uStack_48 = 0;
  uStack_40 = 0;
  iStack_a4 = 0;
  iStack_a8 = 0;
  iStack_80 = 0;
  iStack_84 = 0;
  iStack_88 = 0;
  iStack_8c = 0;
  iStack_90 = 0;
  iStack_94 = 0;
  iStack_98 = 0;
  iStack_9c = 0;
  iStack_4c = 0;
  iStack_50 = 0;
  iStack_54 = 0;
  iStack_58 = 0;
  iStack_64 = 0;
  iStack_a0 = 0;
  iStack_74 = 0;
  uStack_b0 = 0;
  do {
    do {
      do {
        memw();
        if ((_DAT_3ff51030 & 2) != 0) {
          rw_bb_rx_refesh();
        }
        memw();
      } while ((_DAT_60031014 & 0x4000) == 0);
      memw();
      _DAT_60031018 = _DAT_60031018 | 0x4000;
      memw();
      memw();
      _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
      memw();
      memw();
      if ((_DAT_3ffb02c0 & 0x8000) != 0) {
        memw();
        memw();
        uStack_40 = _DAT_3ffb02c0 >> 0x17 & 1;
        uStack_48 = _DAT_3ffb02c0 >> 0x16 & 1;
        uStack_60 = _DAT_3ffb02c0 >> 0x15 & 1;
        uStack_44 = _DAT_3ffb02c0 >> 0x14 & 1;
        uStack_5c = _DAT_3ffb02c0 >> 0x13 & 1;
        uStack_68 = _DAT_3ffb02c0 >> 0x12 & 1;
        uStack_78 = _DAT_3ffb02c0 >> 0x11 & 1;
        uStack_ac = _DAT_3ffb02c0 >> 0x10 & 1;
        if ((_DAT_3ffb02c0 & 0x8000) != 0) {
          memw();
          _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
          memw();
        }
      }
      if (uStack_ac == 0) {
        if (uStack_78 == 0) {
          if (uStack_68 == 0) {
            uStack_7c = uStack_68;
            if (uStack_60 == 0) {
              if (uStack_5c == 0) {
                if (uStack_44 == 0) {
                  if (uStack_48 == 0) {
                    if (uStack_40 == 0) {
                      iStack_a0 = iStack_a0 + 1;
                      uStack_7c = 1;
                    }
                    else {
                      iStack_4c = iStack_4c + 1;
                      uStack_7c = uStack_48;
                    }
                  }
                  else {
                    iStack_54 = iStack_54 + 1;
                    uStack_7c = uStack_44;
                  }
                }
                else {
                  iStack_50 = iStack_50 + 1;
                  uStack_7c = uStack_5c;
                }
              }
              else {
                uStack_7c = uStack_60;
                iStack_58 = iStack_58 + 1;
              }
            }
          }
          else {
            iStack_64 = iStack_64 + 1;
            uStack_7c = 1;
          }
        }
        else {
          uStack_7c = uStack_ac;
          iStack_74 = iStack_74 + 1;
        }
        memw();
        iStack_2c = pwr_full_band + 0x100;
        memw();
        memw();
        memw();
        uStack_34 = _DAT_3ff51050 & 0x10;
        uStack_38 = _DAT_3ff51050 & 0x20;
        uStack_3c = _DAT_3ff51050 & 0x40;
        pwr_full_band = iStack_2c - (_DAT_3ff51078 >> 0x18);
        uStack_30 = _DAT_3ff51074 & 0xff;
        gain = gain + (_DAT_3ff51078 >> 0x10 & 0xff);
        pwr_in_band = (pwr_in_band + 0x100) - uStack_30;
        uStack_6c = (uint)(uStack_38 != 0);
        uStack_70 = (uint)(uStack_34 != 0);
        uStack_b0 = uStack_b0 + 1;
        iStack_9c = iStack_9c + (uint)((_DAT_3ff51050 & 0x80) != 0);
        iStack_98 = iStack_98 + (uint)(uStack_3c != 0);
        iStack_94 = iStack_94 + uStack_6c;
        iStack_88 = iStack_88 + uStack_70;
        iStack_84 = iStack_84 + (uint)((_DAT_3ff51050 & 4) != 0);
        iStack_90 = iStack_90 + (uint)((_DAT_3ff51050 & 8) != 0);
        iStack_8c = iStack_8c + (uint)((_DAT_3ff51050 & 2) != 0);
        iStack_80 = iStack_80 + (_DAT_3ff51050 & 1);
        if (uStack_7c != 0) {
          rw_rx_prbs9_status(0x3ffb02c0,&get_total_bits,&get_err_bits);
          iStack_a8 = iStack_a8 + get_total_bits;
          iStack_a4 = iStack_a4 + get_err_bits;
        }
      }
      memw();
      _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
      memw();
      SVar1 = GetStopCmd();
      btrx_valid = true;
      btrx_result[0] = uStack_b0;
      btrx_result[1] = iStack_a0;
      btrx_result[2] = pwr_in_band;
      btrx_result[4] = iStack_a8;
      btrx_result[3] = gain;
      btrx_result[5] = iStack_a4;
    } while ((SVar1 != BUSY) && (SVar1 != OK && SVar1 != BUSY));
    get_bt_rx_rssi(&pwr_in_band,&gain,&pwr_full_band,uStack_b0);
    phy_printf("%x %x %x %x %x %x %x %x w %x %x %x %x %x %x %x %x p %x %x %x b %x %x\n",uStack_b0,
               iStack_a0,iStack_74,iStack_64,iStack_58,iStack_50,iStack_54,iStack_4c,iStack_9c,
               iStack_98,iStack_8c,iStack_90,iStack_94,iStack_80,iStack_84,iStack_88,pwr_in_band,
               pwr_full_band,gain,iStack_a8,iStack_a4);
  } while (SVar1 != OK);
  return;
}



// WARNING: Removing unreachable block (ram,0x0001fc68)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_rx_per_ulap_rssi(u32 edr,u32 chan,u32 ulap,u32 ltaddr)

{
  uint uVar1;
  STATUS SVar2;
  u32 *puVar3;
  uint uVar4;
  int iVar5;
  u32 rssi_array [100];
  u32 get_err_bits;
  u32 get_total_bits;
  u32 bchh;
  u32 bchl;
  u32 gain;
  u32 pwr_full_band;
  u32 pwr_in_band;
  uint uStack_c0;
  uint uStack_bc;
  u32 uStack_b8;
  int iStack_b4;
  int iStack_b0;
  int iStack_ac;
  int iStack_a8;
  int iStack_a4;
  int iStack_a0;
  int iStack_9c;
  int iStack_98;
  uint uStack_94;
  uint uStack_90;
  uint uStack_8c;
  uint uStack_88;
  int iStack_84;
  uint uStack_80;
  uint uStack_7c;
  uint uStack_78;
  uint uStack_74;
  uint uStack_70;
  int iStack_6c;
  int iStack_68;
  int iStack_64;
  uint uStack_60;
  uint uStack_5c;
  int iStack_58;
  uint uStack_54;
  uint uStack_50;
  int iStack_4c;
  int iStack_48;
  int iStack_44;
  int iStack_40;
  int iStack_3c;
  uint uStack_38;
  uint uStack_34;
  uint uStack_30;
  uint uStack_2c;
  uint uStack_28;
  uint uStack_24;
  
  memw();
  pwr_in_band = 0;
  pwr_full_band = 0;
  gain = 0;
  bchl = 0;
  bchh = 0;
  _DAT_3ff51098 = _DAT_3ff51098 | 0xc0000000;
  memw();
  rw_test_init();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  memw();
  if ((_DAT_3ffb02c0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    memw();
  }
  memw();
  if ((_DAT_3ffb02d0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
  }
  uStack_38 = 0x4000;
  rw_bch_gen(ulap,&bchl,&bchh);
  rw_init_cs(3,ltaddr,edr,1,ulap,0,bchl,bchh,0,0,chan,0,1,0x14,0,5,1);
  memw();
  _DAT_3ffb02a0 = 0xda02b0;
  memw();
  _DAT_3ffb02a4 = 0x3000fa6;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0xda02a0;
  memw();
  _DAT_3ffb02b4 = 0x3000fa6;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x700;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0xb00;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0x7000000;
  memw();
  memw();
  _DAT_3ffb02dc = 0x700;
  memw();
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0x8000 | 0x2c0;
  memw();
  memw();
  _DAT_3ffb0000 = 0x2000301;
  rw_bt_core_on();
  prbs9_gen(PRBS9);
  phy_printf("RW RX PER\n");
  uStack_c0 = 0;
  get_total_bits = 0;
  get_err_bits = 0;
  uStack_94 = 0;
  uStack_8c = 0;
  uStack_80 = 0;
  uStack_7c = 0;
  uStack_88 = 0;
  uStack_78 = 0;
  uStack_74 = 0;
  iStack_68 = 0;
  iStack_6c = 0;
  iStack_98 = 0;
  iStack_9c = 0;
  iStack_a0 = 0;
  iStack_a4 = 0;
  iStack_a8 = 0;
  iStack_ac = 0;
  iStack_b0 = 0;
  iStack_b4 = 0;
  iStack_3c = 0;
  iStack_40 = 0;
  iStack_44 = 0;
  iStack_48 = 0;
  iStack_64 = 0;
  iStack_4c = 0;
  iStack_84 = 0;
  uStack_b8 = 0;
  iStack_58 = 0;
  uStack_70 = 0;
  do {
    memw();
    if ((_DAT_3ff51030 & 2) != 0) {
      rw_bb_rx_refesh();
    }
    ets_delay_us(0x14);
    do {
      memw();
    } while ((_DAT_60031014 & uStack_38) == 0);
    memw();
    _DAT_60031018 = _DAT_60031018 | uStack_38;
    memw();
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    memw();
    if ((_DAT_3ffb02c0 & 0x8000) != 0) {
      memw();
      memw();
      uStack_74 = _DAT_3ffb02c0 >> 0x17 & 1;
      uStack_78 = _DAT_3ffb02c0 >> 0x16 & 1;
      uStack_88 = _DAT_3ffb02c0 >> 0x15 & 1;
      uStack_7c = _DAT_3ffb02c0 >> 0x14 & 1;
      uStack_80 = _DAT_3ffb02c0 >> 0x13 & 1;
      uStack_8c = _DAT_3ffb02c0 >> 0x12 & 1;
      uStack_94 = _DAT_3ffb02c0 >> 0x11 & 1;
      uStack_c0 = _DAT_3ffb02c0 >> 0x10 & 1;
      if ((_DAT_3ffb02c0 & 0x8000) != 0) {
        memw();
        _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
        memw();
      }
    }
    if (uStack_c0 == 0) {
      if (uStack_94 == 0) {
        if (uStack_8c == 0) {
          uStack_90 = uStack_8c;
          if (uStack_88 == 0) {
            if (uStack_80 == 0) {
              if (uStack_7c == 0) {
                if (uStack_78 == 0) {
                  if (uStack_74 == 0) {
                    iStack_4c = iStack_4c + 1;
                    uStack_90 = 1;
                  }
                  else {
                    iStack_3c = iStack_3c + 1;
                    uStack_90 = uStack_78;
                  }
                }
                else {
                  iStack_44 = iStack_44 + 1;
                  uStack_90 = uStack_7c;
                }
              }
              else {
                iStack_40 = iStack_40 + 1;
                uStack_90 = uStack_80;
              }
            }
            else {
              uStack_90 = uStack_88;
              iStack_48 = iStack_48 + 1;
            }
          }
        }
        else {
          iStack_64 = iStack_64 + 1;
          uStack_90 = 1;
        }
      }
      else {
        uStack_90 = uStack_c0;
        iStack_84 = iStack_84 + 1;
      }
      memw();
      memw();
      memw();
      memw();
      uStack_bc = _DAT_3ff51078 >> 0x10 & 0xff;
      uStack_24 = _DAT_3ff51050 & 8;
      iVar5 = 0x100 - (_DAT_3ff51074 & 0xff);
      uStack_2c = _DAT_3ff51050 & 0x20;
      uStack_28 = _DAT_3ff51050 & 0x10;
      pwr_in_band = pwr_in_band + iVar5;
      uStack_34 = (uint)((_DAT_3ff51050 & 0x80) != 0);
      pwr_full_band = (pwr_full_band + 0x100) - (_DAT_3ff51078 >> 0x18);
      gain = gain + uStack_bc;
      uStack_30 = (uint)(uStack_2c != 0);
      uStack_b8 = uStack_b8 + 1;
      iStack_b4 = iStack_b4 + uStack_34;
      iStack_b0 = iStack_b0 + (uint)((_DAT_3ff51050 & 0x40) != 0);
      iStack_ac = iStack_ac + uStack_30;
      iStack_a0 = iStack_a0 + (uint)(uStack_28 != 0);
      iStack_a8 = iStack_a8 + (uint)(uStack_24 != 0);
      iStack_9c = iStack_9c + (uint)((_DAT_3ff51050 & 4) != 0);
      iStack_a4 = iStack_a4 + (uint)((_DAT_3ff51050 & 2) != 0);
      iStack_98 = iStack_98 + (_DAT_3ff51050 & 1);
      if (uStack_90 != 0) {
        uVar1 = iVar5 + uStack_bc;
        rw_rx_prbs9_status(0x3ffb02c0,&get_total_bits,&get_err_bits);
        iStack_6c = iStack_6c + get_total_bits;
        iStack_68 = iStack_68 + get_err_bits;
        if (uStack_70 < 100) {
          puVar3 = rssi_array + uStack_70;
          uStack_70 = uStack_70 + 1;
          *puVar3 = uVar1;
        }
        if (iStack_58 == 0) {
          uStack_5c = uStack_bc;
          uStack_50 = uStack_bc;
          iStack_58 = 1;
          uStack_60 = uVar1;
          uStack_54 = uVar1;
        }
        else {
          uStack_50 = (uStack_50 < uStack_bc) * uStack_bc + (uStack_50 >= uStack_bc) * uStack_50;
          uStack_5c = (uStack_5c < uStack_bc) * uStack_5c + (uStack_5c >= uStack_bc) * uStack_bc;
          uStack_60 = (uStack_60 < uVar1) * uVar1 + (uStack_60 >= uVar1) * uStack_60;
          uStack_54 = (uStack_54 < uVar1) * uStack_54 + (uStack_54 >= uVar1) * uVar1;
        }
      }
    }
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    SVar2 = GetStopCmd();
    uVar1 = uStack_70;
  } while ((SVar2 != BUSY) && (SVar2 != OK && SVar2 != BUSY));
  get_bt_rx_rssi(&pwr_in_band,&gain,&pwr_full_band,uStack_b8);
  phy_printf("%x %x %x %x %x %x %x %x w %x %x %x %x %x %x %x %x p %x %x %x b %x %x %x %x %x %x ",
             uStack_b8,iStack_4c,iStack_84,iStack_64,iStack_48,iStack_40,iStack_44,iStack_3c,
             iStack_b4,iStack_b0,iStack_a4,iStack_a8,iStack_ac,iStack_98,iStack_9c,iStack_a0,
             pwr_in_band,pwr_full_band,gain,iStack_6c,iStack_68,uStack_50,uStack_5c,uStack_54,
             uStack_60);
  uVar4 = 0;
  puVar3 = rssi_array;
  if (uVar1 != 0) {
    do {
      uVar4 = uVar4 + 1;
      phy_printf(&DAT_00053b64,*puVar3);
      puVar3 = puVar3 + 1;
    } while (uVar1 != uVar4);
  }
  phy_printf(&DAT_00053b60);
  return;
}



// WARNING: Removing unreachable block (ram,0x00020360)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_rx_per_init(u32 edr,u32 chan)

{
  u32 bchh;
  u32 bchl;
  
  memw();
  bchl = 0;
  bchh = 0;
  _DAT_3ff51098 = _DAT_3ff51098 | 0xc0000000;
  memw();
  rw_test_init();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  memw();
  if ((_DAT_3ffb02c0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    memw();
  }
  memw();
  if ((_DAT_3ffb02d0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
  }
  rw_bch_gen(0x6bc6967e,&bchl,&bchh);
  rw_init_cs(3,2,edr,1,0x6bc6967e,0,bchl,bchh,0,0,chan,0,1,2,0,5,1);
  memw();
  _DAT_3ffb02a0 = 0xda02b0;
  memw();
  _DAT_3ffb02a4 = 0x3000fa6;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0xda02a0;
  memw();
  _DAT_3ffb02b4 = 0x3000fa6;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x700;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0xb00;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02d0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02d8 = 0x7000000;
  memw();
  memw();
  _DAT_3ffb02dc = 0x700;
  memw();
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0x8000 | 0x2c0;
  memw();
  memw();
  _DAT_3ffb0000 = 0x2000301;
  rw_bt_core_on();
  phy_printf("RW RX PER\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bt_bb_dump(u32 data_sel,u32 dump_len)

{
  mac_write(0x60033dc4,0x3020100);
  memw();
  memw();
  _DAT_3ff000a8 = _DAT_3ff000a8 | 0x60;
  memw();
  memw();
  if (data_sel == 0) {
    memw();
    _DAT_60033d90 = _DAT_60033d90 & 0x7ffe7fff;
    memw();
    memw();
    _DAT_3ff510f4 = _DAT_3ff510f4 & 0xfffffffe;
    memw();
    memw();
    _DAT_3ff5c0b8 = _DAT_3ff5c0b8 | 1;
    memw();
  }
  else {
    memw();
    _DAT_60033d90 = _DAT_60033d90 & 0x7ffe7fff | 0x10000;
    memw();
    memw();
    _DAT_3ff510f4 = _DAT_3ff510f4 | 1;
    memw();
    memw();
    _DAT_3ff5c0b8 = _DAT_3ff5c0b8 & 0xfffffffe;
    memw();
  }
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff510f4 = _DAT_3ff510f4 & 0xfffffff5;
  memw();
  memw();
  _DAT_60033d90 = _DAT_60033d90 & 0x8ffd8000 | 0x10000000 | dump_len & 0x7fff | 0x80000000;
  return;
}



// WARNING: Removing unreachable block (ram,0x00020781)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 rw_rx_dump(u32 edr,u32 chan,u32 ulap,u32 ltaddr,u32 data_sel,u32 dump_len,u32 status_sel)

{
  uint uVar1;
  uint *bdaddrl;
  uint uVar2;
  int iVar3;
  uint uVar4;
  u32 uVar5;
  u32 bchh;
  u32 bchl;
  u32 uStack_50;
  uint uStack_4c;
  uint uStack_48;
  uint uStack_44;
  uint uStack_40;
  uint uStack_3c;
  uint uStack_38;
  u32 uStack_34;
  u32 uStack_30;
  uint uStack_2c;
  uint *puStack_28;
  uint *puStack_24;
  
  bchl = 0;
  bchh = 0;
  uStack_34 = data_sel;
  uStack_30 = dump_len;
  puStack_28 = (uint *)ulap;
  prbs9_gen(PRBS9);
  memw();
  _DAT_3ff51098 = _DAT_3ff51098 | 0xc0000000;
  memw();
  rw_test_init();
  memw();
  _DAT_60031018 = _DAT_60031018 | 0x4000;
  memw();
  memw();
  if ((_DAT_3ffb02c0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
    memw();
  }
  memw();
  if ((_DAT_3ffb02d0 & 0x8000) != 0) {
    memw();
    _DAT_3ffb02d0 = _DAT_3ffb02d0 & 0xffff7fff;
    memw();
  }
  puStack_24 = (uint *)&DAT_3ffb02d0;
  rw_bch_gen((u32)puStack_28,&bchl,&bchh);
  bdaddrl = puStack_28;
  puStack_28 = (uint *)0x0;
  rw_init_cs(3,ltaddr,edr,1,(u32)bdaddrl,0,bchl,bchh,0,0,chan,0,1,2,0,5,1);
  memw();
  _DAT_3ffb02a0 = 0xda02b0;
  memw();
  _DAT_3ffb02a4 = 0x3000fa6;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x700;
  memw();
  memw();
  _DAT_3ffb02b0 = 0xda02a0;
  memw();
  _DAT_3ffb02b4 = 0x3000fa6;
  memw();
  _DAT_3ffb02b8 = _DAT_3ffb02b8 & 0xffff0000 | 0x700;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = (uint)puStack_28 & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_3ffb02c8 = (uint)puStack_28 & 0xffff | 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = (uint)puStack_28 & 0xffff0000 | 0xb00;
  memw();
  memw();
  *puStack_24 = (uint)puStack_28;
  memw();
  _DAT_3ffb02d8 = (uint)puStack_28;
  memw();
  _DAT_3ffb02dc = (uint)puStack_28;
  memw();
  memw();
  *puStack_24 = *puStack_24 & 0xffff8000 | 0x2c0;
  memw();
  _DAT_3ffb02d8 = _DAT_3ffb02d8 & 0xffff | 0x7000000;
  memw();
  memw();
  _DAT_3ffb02dc = _DAT_3ffb02dc & 0xffff0000 | 0x700;
  memw();
  memw();
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0x8000 | 0x2c0;
  memw();
  memw();
  _DAT_3ffb0000 = 0x2000301;
  rw_bt_core_on();
  uStack_2c = (uint)(status_sel == 9);
  puStack_28 = (uint *)&DAT_60031014;
  uStack_4c = 0;
  uVar2 = 0;
  uStack_38 = 0;
  uStack_3c = 0;
  uStack_40 = 0;
  uStack_44 = 0;
  uStack_48 = 0;
  uStack_50 = 0;
  iVar3 = 0;
  uVar4 = 0;
  do {
    bt_bb_dump(uStack_34,uStack_30);
    ets_delay_us(0x14);
    iVar3 = iVar3 + 1;
    do {
      memw();
    } while ((*puStack_28 & 0x4000) == 0);
    memw();
    _DAT_60031018 = _DAT_60031018 | 0x4000;
    memw();
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    memw();
    if ((_DAT_3ffb02c0 & 0x8000) != 0) {
      memw();
      memw();
      uStack_38 = _DAT_3ffb02c0 >> 0x17 & 1;
      uStack_3c = _DAT_3ffb02c0 >> 0x16 & 1;
      uStack_40 = _DAT_3ffb02c0 >> 0x15 & 1;
      uStack_44 = _DAT_3ffb02c0 >> 0x14 & 1;
      uStack_48 = _DAT_3ffb02c0 >> 0x13 & 1;
      uStack_4c = _DAT_3ffb02c0 >> 0x11 & 1;
      uVar4 = _DAT_3ffb02c0 >> 0x12 & 1;
      uVar2 = _DAT_3ffb02c0 >> 0x10 & 1;
      if ((_DAT_3ffb02c0 & 0x8000) != 0) {
        memw();
        _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
        memw();
      }
    }
    if (status_sel == 0) {
      uVar5 = status_sel;
      if (((((((uStack_48 == 0 && uStack_44 == 0) && uStack_40 == 0) && uStack_3c == 0) &&
            uStack_38 == 0) && uVar2 == 0) && uStack_4c == 0) && uVar4 == 0) {
LAB_0002090f:
        uStack_50 = 1;
        uVar5 = 1;
      }
    }
    else if (status_sel == 1) {
      uVar5 = 0;
      if (uVar2 != 0) {
        uStack_50 = 1;
        uVar5 = status_sel;
      }
    }
    else {
      uVar1 = uStack_4c;
      if (status_sel == 2) {
joined_r0x000208f8:
        uVar5 = 0;
        if (uVar1 != 0) {
LAB_00020919:
          uStack_50 = 1;
          uVar5 = 1;
        }
      }
      else {
        if (status_sel != 4) {
          uVar1 = uStack_48;
          if ((((status_sel == 5) || (uVar1 = uStack_44, status_sel == 6)) ||
              (uVar1 = uStack_40, status_sel == 7)) || (uVar1 = uStack_3c, status_sel == 8))
          goto joined_r0x000208f8;
          if ((uStack_2c == 0) || (uStack_38 == 0)) {
            uVar5 = 0;
            goto LAB_0002091e;
          }
          goto LAB_00020919;
        }
        uVar5 = 0;
        if (uVar4 != 0) goto LAB_0002090f;
      }
    }
LAB_0002091e:
    if ((iVar3 == 0x3e9) || (uVar5 == 1)) {
      do {
        memw();
      } while ((_DAT_60033d90 & 0x40000) == 0);
      ets_delay_us(10000);
      memw();
      _DAT_60033d90 = _DAT_60033d90 & 0x7fffffff;
      memw();
      phy_printf(&DAT_000537d4,iVar3);
      return uStack_50;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 rw_clkn(void)

{
  uint uVar1;
  
  uVar1 = _DAT_6003101c;
  memw();
  _DAT_6003101c = _DAT_6003101c | 0x80000000;
  memw();
  do {
    memw();
  } while ((int)_DAT_6003101c < 0);
  memw();
  return uVar1 & 0xfffffff;
}



// WARNING: Unknown calling convention

u32 rw_next_et_entry(u32 clkn)

{
  return 1 << 0x20 - (0x20 - (clkn >> 1 & 0xf));
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_tx_buf_init(void)

{
  int iVar1;
  u32 *puVar2;
  u32 uVar3;
  u32 *puVar4;
  
  prbs9_gen(PRBS9);
  puVar2 = (u32 *)&DAT_3ffb0700;
  puVar4 = PRBS9;
  iVar1 = 0x101;
  do {
    uVar3 = *puVar4;
    memw();
    puVar2[-0x100] = uVar3;
    memw();
    *puVar2 = uVar3;
    puVar4 = puVar4 + 1;
    puVar2 = puVar2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return;
}



// WARNING: Unknown calling convention

void rw_dut_timing_refresh(u32 *clknos,u32 *bitos,u32 rxbit)

{
  uint uVar1;
  int iVar2;
  u32 uVar3;
  
  iVar2 = (*bitos + 0x4e) - rxbit;
  if (0x12 < iVar2 + 9U) {
    return;
  }
  uVar3 = *bitos - iVar2;
  if ((int)uVar3 < 0x271) {
    if (-1 < (int)uVar3) {
      *bitos = uVar3;
      return;
    }
    if (-5 < (int)uVar3) {
      *bitos = 0;
      return;
    }
    if ((int)uVar3 < -7) {
      *bitos = uVar3 + 0x271;
      uVar1 = *clknos;
    }
    else {
      *bitos = 0x269;
      uVar1 = *clknos;
    }
    if ((uVar1 & 0x4000000) != 0) {
LAB_00020a44:
      *clknos = uVar1 + 1;
      return;
    }
  }
  else {
    *bitos = uVar3 - 0x271;
    uVar1 = *clknos;
    if ((uVar1 & 0x4000000) == 0) goto LAB_00020a44;
  }
  *clknos = uVar1 - 1;
  return;
}



// WARNING: Unknown calling convention

void rw_dut_timing_refresh_cs(u32 ptr,u32 *clknos,u32 *bitos,u32 rxbit,u32 refresh)

{
  if (refresh != 0) {
    rw_dut_timing_refresh(clknos,bitos,rxbit);
  }
  memw();
  *(u32 *)(&DAT_3ffb0004 + ptr) = *clknos;
  memw();
  memw();
  *(u32 *)(&DAT_3ffb0000 + ptr) =
       (*bitos & 0x3ff) << 0x10 | *(uint *)(&DAT_3ffb0000 + ptr) & 0xfc00ffff;
  return;
}



// WARNING: Removing unreachable block (ram,0x00020c8d)
// WARNING: Removing unreachable block (ram,0x00020c95)
// WARNING: Removing unreachable block (ram,0x00020ca5)
// WARNING: Removing unreachable block (ram,0x00020cdc)
// WARNING: Removing unreachable block (ram,0x00020d00)
// WARNING: Removing unreachable block (ram,0x00020d06)
// WARNING: Removing unreachable block (ram,0x00020d0d)
// WARNING: Removing unreachable block (ram,0x00020d10)
// WARNING: Removing unreachable block (ram,0x00020d1f)
// WARNING: Removing unreachable block (ram,0x00020d93)
// WARNING: Removing unreachable block (ram,0x00020d66)
// WARNING: Removing unreachable block (ram,0x00020d79)
// WARNING: Removing unreachable block (ram,0x00020d89)
// WARNING: Removing unreachable block (ram,0x00020d7f)
// WARNING: Removing unreachable block (ram,0x00020d71)
// WARNING: Removing unreachable block (ram,0x00020d9b)
// WARNING: Removing unreachable block (ram,0x00020bed)
// WARNING: Removing unreachable block (ram,0x00020d03)
// WARNING: Removing unreachable block (ram,0x00020dcc)
// WARNING: Removing unreachable block (ram,0x00020dd6)
// WARNING: Removing unreachable block (ram,0x00020ddf)
// WARNING: Removing unreachable block (ram,0x00020ddc)
// WARNING: Removing unreachable block (ram,0x00020dd3)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 rw_dut_try_con(u32 ulap,u32 nap,u32 bchl,u32 bchh,u32 freq,u32 freq1,u32 t,u32 *clknos,
                  u32 *bitos,u32 nmin,u32 nmax,u32 *mulap,u32 *mnap)

{
  u32 et_mask;
  u32 ptype;
  
  ifreq = ifreq + 1;
  if ((2 < ifreq) && (freq1 = freq, ifreq != 3)) {
    ifreq = 0;
  }
  rw_init_cs(3,2,1,1,ulap,nap,bchl,bchh,4,0,freq1,0,1,t,0,0,1);
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  do {
    memw();
    memw();
    do {
      memw();
    } while ((int)(_DAT_6003101c | 0x80000000) < 0);
    memw();
    if ((1 << 0x20 - (0x20 - ((_DAT_6003101c & 0xfffffff) + 4 >> 1 & 0xf)) & 1U) == 0) {
      memw();
    }
    else {
      memw();
      memw();
      memw();
    }
    do {
      memw();
    } while ((_DAT_60031014 & 0x4000) == 0);
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_6003101c = _DAT_6003101c | 0x80000000;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_dut_con(u32 ulap,u32 nap,u32 bchl,u32 bchh,u32 hoppe,u32 freq,u32 whdsb,u32 edr,u32 type,
               u32 len,u32 et_mask,u32 *nfrm,u32 *nduttx,u32 *ndutrx,u32 *ntesttx,u32 *ntestrx,u32 n
               ,u32 nfrmmax,u32 *clknos,u32 *bitos,u32 txpwr)

{
  undefined4 uVar1;
  u32 uVar2;
  u32 uVar3;
  undefined4 *puVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  
  rw_init_cs(3,2,edr,whdsb,ulap,nap,bchl,bchh,txpwr,hoppe,freq,0,0,0x32,0x3ffb02a0,0,1);
  _DAT_3ffb0204 = *clknos;
  memw();
  memw();
  _DAT_3ffb0200 = (*bitos & 0x3ff) << 0x10 | _DAT_3ffb0200 & 0xfc00ffff;
  memw();
  _DAT_3ffb02a0 = (type & 0xf) << 0x13 | 0x8202a0;
  _DAT_3ffb02a4 = (len & 0x3ff) << 3 | 0x7000006;
  memw();
  memw();
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x300;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0xb00;
  memw();
  memw();
  _DAT_6003102c = _DAT_6003102c & 0xffff8000 | 0x2c0;
  memw();
  memw();
  _DAT_3ffb0700 = 0;
  memw();
  _DAT_3ffb0704 = 0;
  memw();
  _DAT_3ffb0708 = 0;
  if ((et_mask & 1) == 0) {
    memw();
    _DAT_3ffb0000 = 0;
  }
  else {
    memw();
    memw();
    _DAT_3ffb0000 = 0x2000301;
    memw();
  }
  uVar8 = *nfrm;
  do {
    do {
      memw();
    } while ((_DAT_60031014 & 0x4000) == 0);
    memw();
    uVar8 = uVar8 + 1;
    _DAT_60031018 = _DAT_60031018 | 0x4000;
    memw();
    memw();
    _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
    memw();
    *nfrm = uVar8;
    uVar2 = _DAT_3ffb0b00;
    uVar1 = _DAT_3ffb02c8;
    memw();
    _DAT_3ffb0000 = _DAT_3ffb0000 & 0xffffffcf;
    memw();
    memw();
    _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
    memw();
    memw();
    if ((_DAT_3ffb02c0 & 0x8000) != 0) {
      memw();
      if ((_DAT_3ffb02c0 & 0x8000) != 0) {
        memw();
        _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
        memw();
      }
      memw();
      memw();
      uVar7 = _DAT_3ffb02c0 >> 0x12 & 1;
      uVar6 = _DAT_3ffb02c0 >> 0x11 & 1;
      if ((((((((_DAT_3ffb02c0 >> 0x17 & 1) == 0 && (_DAT_3ffb02c0 >> 0x16 & 1) == 0) &&
              (_DAT_3ffb02c0 >> 0x10 & 1) == 0) && (_DAT_3ffb02c0 >> 0x15 & 1) == 0) &&
            (_DAT_3ffb02c0 >> 0x14 & 1) == 0) && (_DAT_3ffb02c0 >> 0x13 & 1) == 0) && uVar7 == 0) &&
          uVar6 == 0) {
        memw();
        memw();
        memw();
        memw();
        memw();
        if (type == (_DAT_3ffb02c4 >> 3 & 0xf)) {
          memw();
          *ndutrx = *ndutrx + 1;
          uVar3 = _DAT_3ffb0b04;
          _DAT_3ffb0708 = (int)(char)uVar1;
          memw();
          *ntestrx = uVar2;
          *ntesttx = uVar3;
          _DAT_3ffb0700 = *ndutrx;
          memw();
          memw();
        }
        memw();
        rw_dut_timing_refresh(clknos,bitos,_DAT_3ffb0254 >> 0x10 & 0x3ff);
        _DAT_3ffb0204 = *clknos;
        memw();
        memw();
        _DAT_3ffb0200 = (*bitos & 0x3ff) << 0x10 | _DAT_3ffb0200 & 0xfc00ffff;
        memw();
      }
      else if ((uVar7 & (uVar6 ^ 1)) == 0) goto LAB_00021195;
      _DAT_3ffb0704 = *nduttx + 1;
      *nduttx = _DAT_3ffb0704;
      uVar8 = *nfrm;
      memw();
    }
LAB_00021195:
    if ((nfrmmax <= uVar8) || (n <= *ntesttx)) {
      puVar4 = (undefined4 *)&DAT_3ffb0000;
      memw();
      _DAT_6003102c = 0;
      iVar5 = 0x10;
      do {
        memw();
        *puVar4 = 0;
        puVar4 = puVar4 + 1;
        iVar5 = iVar5 + -1;
      } while (iVar5 != 0);
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 rw_tester_try_con(u32 ulap,u32 nap,u32 mulap,u32 mnap,u32 bchl,u32 bchh,u32 freq,u32 n,u32 nmin,
                     s8 *rssi)

{
  int iVar1;
  undefined4 *puVar2;
  u32 uVar3;
  uint uVar4;
  uint uVar5;
  
  rw_init_cs(2,2,1,1,ulap,nap,bchl,bchh,4,0,freq,0,0,200,0x3ffb02a0,0,1);
  memw();
  _DAT_3ffb02a0 = 0xa202a0;
  memw();
  _DAT_3ffb02a4 = 0x7000086;
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x300;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0xb00;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  do {
    memw();
  } while ((int)(_DAT_6003101c | 0x80000000) < 0);
  memw();
  memw();
  if ((1 << 0x20 - (0x20 - ((_DAT_6003101c & 0xffffffe) + (_DAT_6003101c & 2) + 4 >> 1 & 0xf)) & 1U)
      == 0) {
    memw();
  }
  else {
    memw();
    memw();
    memw();
  }
  uVar4 = 0;
  uVar3 = 0;
  _DAT_3ffb0704 = mulap;
  _DAT_3ffb0708 = mnap;
  _DAT_6003101c = _DAT_6003101c | 0x80000000;
  do {
    do {
      memw();
    } while ((_DAT_60031014 & 0x4000) == 0);
    memw();
    _DAT_60031018 = _DAT_60031018 | 0x4000;
    memw();
    memw();
    uVar5 = _DAT_6003101c | 0x80000000;
    memw();
    do {
      memw();
    } while ((int)uVar5 < 0);
    memw();
    _DAT_3ffb0700 = (_DAT_6003101c & 0xffffffe) + (_DAT_6003101c & 2) + 4;
    memw();
    if ((1 << 0x20 - (0x20 - (_DAT_3ffb0700 >> 1 & 0xf)) & 1U) == 0) {
      memw();
      _DAT_3ffb0000 = 0;
    }
    else {
      memw();
      memw();
      _DAT_3ffb0000 = 0x2000301;
      memw();
    }
    memw();
    _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
    memw();
    memw();
    _DAT_6003101c = uVar5;
    if ((_DAT_3ffb02c0 & 0x8000) == 0) {
LAB_000214d9:
      if (nmin <= uVar4) {
LAB_000214c7:
        memw();
        _DAT_6003102c = 0;
        puVar2 = (undefined4 *)&DAT_3ffb0000;
        iVar1 = 0x10;
        do {
          memw();
          *puVar2 = 0;
          puVar2 = puVar2 + 1;
          iVar1 = iVar1 + -1;
        } while (iVar1 != 0);
        return 0;
      }
      uVar4 = uVar4 + (uVar4 != 0);
    }
    else {
      memw();
      if ((_DAT_3ffb02c0 & 0x8000) != 0) {
        memw();
        _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
        memw();
      }
      memw();
      if ((((((((_DAT_3ffb02c0 >> 0x17 & 1) != 0 || (_DAT_3ffb02c0 >> 0x16 & 1) != 0) ||
              (_DAT_3ffb02c0 >> 0x10 & 1) != 0) || (_DAT_3ffb02c0 >> 0x15 & 1) != 0) ||
            (_DAT_3ffb02c0 >> 0x14 & 1) != 0) || (_DAT_3ffb02c0 >> 0x13 & 1) != 0) ||
          (_DAT_3ffb02c0 >> 0x12 & 1) != 0) || (_DAT_3ffb02c0 >> 0x11 & 1) != 0) goto LAB_000214d9;
      memw();
      *rssi = (s8)_DAT_3ffb02c8;
      if (nmin < 2) goto LAB_000214c7;
      uVar4 = 2;
    }
    uVar3 = uVar3 + 1;
    if (uVar3 == n) {
      puVar2 = (undefined4 *)&DAT_3ffb0000;
      memw();
      _DAT_6003102c = 0;
      iVar1 = 0x10;
      do {
        memw();
        *puVar2 = 0;
        puVar2 = puVar2 + 1;
        iVar1 = iVar1 + -1;
      } while (iVar1 != 0);
      return 1;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rw_tester_con(u32 ulap,u32 nap,u32 bchl,u32 bchh,u32 hoppe,u32 freq,u32 n,u32 whdsb,u32 edr,
                  u32 type,u32 len,u32 et_mask,u32 *nduttx,u32 *ndutrx,u32 *ntesttx,u32 *ntestrx,
                  u32 *testrxac,u32 *testrxa,u32 nfrmmax,s8 *rssi_max,s8 *rssi_min,s8 *rssi_avg,
                  s8 *rssi_max_tester,s8 *rssi_min_tester,s8 *rssi_avg_tester,u32 txpwr)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  char cVar7;
  bool bVar8;
  bool bVar9;
  uint uVar10;
  undefined4 uVar11;
  u32 uVar12;
  u32 uVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  undefined4 uStack_4c;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  
  rw_init_cs(2,2,edr,whdsb,ulap,nap,bchl,bchh,txpwr,hoppe,freq,0,0,200,0x3ffb02a0,0,1);
  _DAT_3ffb02a0 = (type & 0xf) << 0x13 | 0x8202a0;
  memw();
  _DAT_3ffb02a4 = (len & 0x3ff) << 3 | 0x7000006;
  memw();
  memw();
  _DAT_3ffb02a8 = _DAT_3ffb02a8 & 0xffff0000 | 0x300;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ffb02c0 = 0x2c0;
  memw();
  memw();
  _DAT_3ffb02c8 = 0xb000000;
  memw();
  memw();
  _DAT_3ffb02cc = 0xb00;
  memw();
  memw();
  memw();
  if ((et_mask & 1) == 0) {
    memw();
  }
  else {
    memw();
    memw();
    memw();
  }
  uVar16 = *ntesttx;
  bVar9 = false;
  uStack_3c = 0;
  uStack_40 = 0;
  bVar8 = false;
  uStack_4c = 0;
  do {
    do {
      memw();
    } while ((_DAT_60031014 & 0x4000) == 0);
    memw();
    uVar16 = uVar16 + 1;
    _DAT_60031018 = _DAT_60031018 | 0x4000;
    memw();
    *ntesttx = uVar16;
    memw();
    memw();
    memw();
    memw();
    _DAT_3ffb02a0 = _DAT_3ffb02a0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb02b0 = _DAT_3ffb02b0 & 0xffff7fff;
    memw();
    memw();
    _DAT_3ffb0704 = uVar16;
    if ((_DAT_3ffb02c0 & 0x8000) != 0) {
      memw();
      if ((_DAT_3ffb02c0 & 0x8000) != 0) {
        memw();
        _DAT_3ffb02c0 = _DAT_3ffb02c0 & 0xffff7fff;
        memw();
      }
      memw();
      uVar16 = _DAT_3ffb02c0 >> 0x17;
      uVar1 = _DAT_3ffb02c0 >> 0x16;
      uVar14 = _DAT_3ffb02c0 >> 0x10 & 1;
      uVar2 = _DAT_3ffb02c0 >> 0x15;
      uVar3 = _DAT_3ffb02c0 >> 0x14;
      uVar4 = _DAT_3ffb02c0 >> 0x13;
      uVar5 = _DAT_3ffb02c0 >> 0x12;
      uVar6 = _DAT_3ffb02c0 >> 0x11;
      if (uVar14 == 0) {
        *testrxa = *testrxa + 1;
      }
      uVar11 = _DAT_3ffb02c8;
      uVar10 = _DAT_3ffb02c4;
      if ((((((((uVar16 & 1) == 0 && (uVar1 & 1) == 0) && uVar14 == 0) && (uVar2 & 1) == 0) &&
            (uVar3 & 1) == 0) && (uVar4 & 1) == 0) && (uVar5 & 1) == 0) && (uVar6 & 1) == 0) {
        memw();
        memw();
        memw();
        memw();
        memw();
        memw();
        *testrxac = *testrxac + 1;
        uVar12 = _DAT_3ffb0b00;
        cVar7 = (char)uVar11;
        iVar15 = (int)cVar7;
        if (type == (uVar10 >> 3 & 0xf)) {
          memw();
          *ntestrx = *ntestrx + 1;
          uVar13 = _DAT_3ffb0b04;
          memw();
          *ndutrx = uVar12;
          *nduttx = uVar13;
          uVar16 = _DAT_3ffb0b08;
          _DAT_3ffb0700 = *ntestrx;
          memw();
          if (bVar9) {
            memw();
            uStack_40 = uStack_40 + _DAT_3ffb0b08;
            uStack_3c = uStack_3c + 1;
            if ((int)*rssi_max_tester < (int)_DAT_3ffb0b08) {
              *rssi_max_tester = (s8)_DAT_3ffb0b08;
            }
            if ((int)uVar16 < (int)*rssi_min_tester) {
LAB_00021894:
              *rssi_min_tester = (s8)uVar16;
            }
          }
          else if (*ndutrx != 0) {
            bVar9 = true;
            memw();
            uStack_3c = 1;
            uStack_40 = _DAT_3ffb0b08;
            uVar16 = _DAT_3ffb0b08 & 0xff;
            *rssi_max_tester = (s8)_DAT_3ffb0b08;
            goto LAB_00021894;
          }
        }
        if (!bVar8) {
          *rssi_max = cVar7;
          *rssi_min = cVar7;
          uVar16 = *ntesttx;
          bVar8 = true;
          uStack_4c = iVar15;
          goto LAB_000218e1;
        }
        uStack_4c = uStack_4c + iVar15;
        if (*rssi_max < iVar15) {
          *rssi_max = cVar7;
        }
        if (iVar15 < *rssi_min) {
          *rssi_min = cVar7;
        }
      }
      uVar16 = *ntesttx;
    }
LAB_000218e1:
    if (n + 5 < uVar16) {
      memw();
      _DAT_6003102c = 0;
      memw();
      _DAT_3ffb0000 = 0;
      if (*testrxac != 0) {
        *rssi_avg = (s8)(uStack_4c / (int)*testrxac);
      }
      if (bVar9) {
        *rssi_avg_tester = (s8)((int)uStack_40 / uStack_3c);
      }
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bt_func_tester(void)

{
  u32 uVar1;
  int iVar2;
  u32 ntestrxac;
  u32 ntestrxa;
  u32 ntestrx;
  u32 ntesttx;
  u32 ndutrx;
  u32 nduttx;
  u32 mbchh;
  u32 mbchl;
  u32 bchh;
  u32 bchl;
  s8 tester_rssi_avg;
  s8 tester_rssi_min;
  s8 tester_rssi_max;
  s8 con_rssi_avg;
  s8 con_rssi_min;
  s8 con_rssi_max;
  s8 try_rssi;
  
  nduttx = 0;
  ndutrx = 0;
  ntesttx = 0;
  ntestrx = 0;
  ntestrxa = 0;
  ntestrxac = 0;
  phy_printf("RW BT FUNC TESTER\n");
  rw_test_init();
  rw_tx_buf_init();
  rw_bt_core_on();
  rw_bch_gen(0xaabbccdd,&bchl,&bchh);
  iVar2 = 0;
  do {
    while( true ) {
      uVar1 = rw_tester_try_con(0xaabbccdd,0xeeff,0xdeadbeef,0xbeef,bchl,bchh,0x27,100,3,&try_rssi);
      if (uVar1 == 0) break;
      phy_printf(&DAT_00053514);
    }
    phy_printf(&DAT_00053b7c);
    rw_bch_gen(0xdeadbeef,&mbchl,&mbchh);
    rw_tester_con(0xdeadbeef,0xbeef,mbchl,mbchh,1,0,100,0,1,8,0x53,0xaaaa,&nduttx,&ndutrx,&ntesttx,
                  &ntestrx,&ntestrxac,&ntestrxa,0x6e,&con_rssi_max,&con_rssi_min,&con_rssi_avg,
                  &tester_rssi_max,&tester_rssi_min,&tester_rssi_avg,4);
    phy_printf("nduttx %d, ndutrx %d, ntesttx %d, ntestrx %d, ntestrxac %d, ntestrxa %d\n",nduttx,
               ndutrx,ntesttx,ntestrx,ntestrxac,ntestrxa);
    iVar2 = iVar2 + 1;
    if (0x6d < ntesttx) {
      phy_printf("\nGet timeout after %d!\n",iVar2);
    }
    nduttx = 0;
    ndutrx = 0;
    ntesttx = 0;
    ntestrx = 0;
    ntestrxac = 0;
    ntestrxa = 0;
  } while( true );
}



// WARNING: Unknown calling convention

u32 rw_bt_func_test_dut(u32 ulap,u32 nap,u32 freq,u32 n,u32 *nslvtx,u32 *nslvrx,u32 *ntx,u32 *nrx,
                       u32 *nrxac,u32 *nrxall,s8 *con_rssi_max,s8 *con_rssi_min,s8 *con_rssi_avg,
                       s8 *tester_rssi_max,s8 *tester_rssi_min,s8 *tester_rssi_avg)

{
  u32 uVar1;
  u32 mbchh;
  u32 mbchl;
  u32 bchh;
  u32 bchl;
  s8 try_rssi;
  u32 *puStack_30;
  
  puStack_30 = nslvrx;
  rw_bch_gen(0xaabbccdd,&bchl,&bchh);
  uVar1 = rw_tester_try_con(0xaabbccdd,0xeeff,ulap,nap,bchl,bchh,freq,n,5,&try_rssi);
  if (uVar1 == 0) {
    rw_bch_gen(ulap,&mbchl,&mbchh);
    rw_tester_con(ulap,nap,mbchl,mbchh,1,0,n,0,(uint)bt_dut_param[0],(uint)bt_dut_param[1],
                  (uint)bt_dut_param[2],0xaaaa,nslvtx,puStack_30,ntx,nrx,nrxac,nrxall,n + 10,
                  con_rssi_max,con_rssi_min,con_rssi_avg,tester_rssi_max,tester_rssi_min,
                  tester_rssi_avg,(uint)bt_dut_param[3]);
  }
  return (uint)(uVar1 != 0);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bt_func_dut(void)

{
  u32 uVar1;
  int iVar2;
  u32 ntestrx;
  u32 ntesttx;
  u32 ndutrx;
  u32 nduttx;
  u32 nfrm;
  u32 mnap;
  u32 mulap;
  u32 bitos;
  u32 clknos;
  u32 mbchh;
  u32 mbchl;
  u32 bchh;
  u32 bchl;
  u32 uStack_30;
  
  mulap = 0;
  mnap = 0;
  nfrm = 0;
  nduttx = 0;
  ndutrx = 0;
  ntesttx = 0;
  ntestrx = 0;
  phy_printf("RW BT FUNC DUT\n");
  rw_test_init();
  rw_tx_buf_init();
  rw_bt_core_on();
  rw_bch_gen(0xaabbccdd,&bchl,&bchh);
  iVar2 = 0;
  do {
    while( true ) {
      uVar1 = rw_dut_try_con(0xaabbccdd,0xeeff,bchl,bchh,0,0x27,4000,&clknos,&bitos,1,1,&mulap,&mnap
                            );
      if (uVar1 == 0) break;
      phy_printf(&DAT_00053514);
    }
    uStack_30 = uVar1;
    phy_printf(&DAT_00053b7c);
    rw_bch_gen(mulap,&mbchl,&mbchh);
    rw_dut_con(mulap,mnap,mbchl,mbchh,1,uStack_30,uStack_30,1,8,0x53,0xffff,&nfrm,&nduttx,&ndutrx,
               &ntesttx,&ntestrx,100,200,&clknos,&bitos,4);
    iVar2 = iVar2 + 1;
    phy_printf("nduttx %d, ndutrx %d, ntesttx %d, ntestrx %d\n",nduttx,ndutrx,ntesttx,ntestrx);
    if (199 < nfrm) {
      phy_printf("\nGet timeout after %d!\n",iVar2);
    }
    nfrm = 0;
    nduttx = 0;
    ndutrx = 0;
    ntesttx = 0;
    ntestrx = 0;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_bt_func_test_init(void)

{
  rwip_rf_api api;
  
  force_bt_mode();
  rf_rw_init(&api);
  rw_test_init();
  rw_tx_buf_init();
  rw_bt_core_on();
  return;
}



// WARNING: Unknown calling convention

void rw_bt_func_test_tester(u32 freq0,u32 freq1,u32 n)

{
  bool bVar1;
  u32 uVar2;
  STATUS SVar3;
  u32 nrx;
  u32 ntx;
  u32 ndutrx;
  u32 nduttx;
  u32 nfrm;
  u32 mnap;
  u32 mulap;
  u32 bitos;
  u32 clknos;
  u32 mbchh;
  u32 mbchl;
  u32 bchh;
  u32 bchl;
  u32 uStack_30;
  u32 uStack_2c;
  uint uStack_28;
  u32 uStack_24;
  
  clknos = 0;
  bitos = 0;
  nfrm = 0;
  nduttx = 0;
  ndutrx = 0;
  ntx = 0;
  nrx = 0;
  uStack_30 = freq0;
  uStack_2c = freq1;
  uStack_28 = n;
  rw_bch_gen(0xaabbccdd,&bchl,&bchh);
  uStack_24 = (uStack_28 >> 1) + uStack_28;
LAB_00021dd8:
  do {
    uVar2 = rw_dut_try_con(0xaabbccdd,0xeeff,bchl,bchh,uStack_30,uStack_2c,5,&clknos,&bitos,1,1,
                           &mulap,&mnap);
    bVar1 = false;
    if (uVar2 != 0) {
      SVar3 = GetStopCmd();
      if (SVar3 != OK) goto LAB_00021dd8;
      bVar1 = true;
    }
    rw_bch_gen(mulap,&mbchl,&mbchh);
    rw_dut_con(mulap,mnap,mbchl,mbchh,1,0,0,(uint)bt_tester_param[0],(uint)bt_tester_param[1],
               (uint)bt_tester_param[2],0xffff,&nfrm,&ntx,&nrx,&nduttx,&ndutrx,uStack_28,uStack_24,
               &clknos,&bitos,(uint)bt_tester_param[3]);
    nfrm = 0;
    nduttx = 0;
    ndutrx = 0;
    ntx = 0;
    nrx = 0;
    clknos = 0;
    bitos = 0;
    SVar3 = GetStopCmd();
    if ((SVar3 == OK) || (bVar1)) {
      return;
    }
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x00022060)
// WARNING: Removing unreachable block (ram,0x00022086)
// WARNING: Removing unreachable block (ram,0x00022094)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_slp_test(void)

{
  int iVar1;
  
  phy_printf("rw sleep test!\n");
  ets_delay_us(4000);
  rtc_init_lite(0x28);
  memw();
  _DAT_3ff000d4 = _DAT_3ff000d4 & 0xfffff000;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff000d8 = _DAT_3ff000d8 & 0xfdffffff | 0x1000000;
  memw();
  ets_delay_us(100);
  memw();
  _DAT_60031034 = 30000;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_6003103c = _DAT_6003103c & 0xffe00000 | 0x802;
  memw();
  memw();
  _DAT_60031030 = _DAT_60031030 | 7;
  memw();
  phy_printf("slp!\n");
  iVar1 = 5;
  do {
    iVar1 = iVar1 + -1;
    ets_delay_us(1000);
  } while (iVar1 != 0);
  pm_close_rf();
  rtc_slp_prep(0,1,1,0,0,0,0,0,0,0,0,0,4,4,4,4);
  iVar1 = rtc_sleep(0,1000,0x400,0);
  if (iVar1 == 0) {
    phy_printf("wak!\n");
  }
  else {
    phy_printf("rej!\n");
  }
  rtc_set_cpu_freq(1);
  rtc_uart_div_modify(0);
  memw();
  memw();
  do {
    memw();
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void cmd_polling_test(void)

{
  arga[0] = 8;
  arga[1] = 9;
  argb[0] = 6;
  argb[1] = 7;
  my_samp.phase = 0x25;
  my_samp.power = 0x62;
  cmd_polling_start(1000000);
  cmd_polling_attach(true,0,cmd_polling_test0,(void *)0x3);
  cmd_polling_attach(false,0,cmd_polling_test1,(void *)0x0);
  cmd_polling_attach(false,0,cmd_polling_test2,&my_samp);
  cmd_polling_attach(true,1,cmd_polling_test0,(void *)0x9);
  cmd_polling_attach(false,0,cmd_polling_test3,(void *)0x0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_autotest(void)

{
  uint8 uVar1;
  u16 uVar2;
  int iVar3;
  u32 uVar4;
  int iVar5;
  uint uVar6;
  undefined4 *puVar7;
  uint in_a14;
  uint in_a15;
  int in_stack_fffffe70;
  int in_stack_fffffe74;
  int in_stack_fffffe78;
  u8 initdata [256];
  rwip_rf_api api;
  
  ets_isr_unmask(0x20);
  wifi_init_bt();
  coex_bt_high_prio();
  phy_printf("\n\n\nCOEX BT HP\n");
  rf_rw_init(&api);
  phy_printf("\nRW autotest! %s, %s\n","Dec 14 2023","20:22:51");
  memw();
  phy_printf("wait %d\n",_DAT_60033d38 >> 0x10);
  memw();
  phy_printf("max gain BT %d\n",_DAT_3ff5c0a4 >> 0xf & 0x7f);
  while( true ) {
    while( true ) {
      while( true ) {
        while( true ) {
          while( true ) {
            while( true ) {
              while( true ) {
                while( true ) {
                  while( true ) {
                    while( true ) {
                      while( true ) {
                        while( true ) {
                          while( true ) {
                            while( true ) {
                              while( true ) {
                                while( true ) {
                                  while( true ) {
                                    while( true ) {
                                      while( true ) {
                                        while( true ) {
                                          while( true ) {
                                            while( true ) {
                                              while( true ) {
                                                while( true ) {
                                                  while( true ) {
                                                    while( true ) {
                                                      do {
                                                        iVar3 = UartGetCmdLn(pString);
                                                      } while (iVar3 != 0);
                                                      iVar3 = cmd_parse(pString,command,&para_num,
                                                                        para_array);
                                                      if (iVar3 != 1) break;
                                                      phy_printf(" cmd syntax error!\n");
                                                    }
                                                    iVar3 = strcmp(command,"WifiTxStart");
                                                    if (iVar3 != 0) break;
                                                    if (para_array[1] < 1) {
                                                      in_stack_fffffe70 = para_array[5];
                                                      phy_printf(
                                                  "wifi tx out: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
                                                  para_array[0],para_array[1],para_array[2],
                                                  para_array[3],para_array[4]);
                                                  }
                                                  in_a14 = para_array[4];
                                                  in_a15 = para_array[5];
                                                  WifiTxStart(para_array[0],para_array[1],
                                                              para_array[2],para_array[3],
                                                              para_array[4],para_array[5]);
                                                  memw();
                                                  phy_printf(" Tx Over, tx_state:0x%x!\n",
                                                             _DAT_60033c68 & 0xff);
                                                  }
                                                  iVar3 = strcmp(command,"force_wifi");
                                                  if (iVar3 != 0) break;
                                                  force_wifi_mode(1);
                                                  phy_printf("Force WIFI\n");
                                                }
                                                iVar3 = strcmp(command,"force_wifi_toggle");
                                                if (iVar3 != 0) break;
                                                force_wifi_toggle(para_array[0]);
                                                phy_printf("Force WIFI toggle end\n");
                                              }
                                              iVar3 = strcmp(command,"unforce_wifi");
                                              if (iVar3 != 0) break;
                                              unforce_wifi_mode();
                                              phy_printf("Unforce WIFI\n");
                                            }
                                            iVar3 = strcmp(command,"force_bt");
                                            if (iVar3 != 0) break;
                                            force_bt_mode();
                                            phy_printf("Force BT MODE\n");
                                          }
                                          iVar3 = strcmp(command,"coex_bt_hp");
                                          if (iVar3 != 0) break;
                                          coex_bt_high_prio();
                                          phy_printf("Coex BT high prio\n");
                                        }
                                        iVar3 = strcmp(command,"t_force_wifi");
                                        if (iVar3 != 0) break;
                                        t_force_wifi = para_array[0];
                                        phy_printf("Time force wifi %d\n",para_array[0]);
                                      }
                                      iVar3 = strcmp(command,"adctrig");
                                      if (iVar3 != 0) break;
                                      adctrig(para_array[0],para_array[1],para_array[2],
                                              para_array[3],in_a14,in_a15,in_stack_fffffe70,
                                              in_stack_fffffe74,in_stack_fffffe78);
                                    }
                                    iVar3 = strcmp(command,"rw_tx_test");
                                    if (iVar3 != 0) break;
                                    in_a14 = para_array[4];
                                    in_a15 = para_array[5];
                                    in_stack_fffffe70 = para_array[6];
                                    in_stack_fffffe74 = para_array[7];
                                    rw_tx_test(para_array[0],para_array[1],para_array[2],
                                               para_array[3],para_array[4],para_array[5],
                                               para_array[6],para_array[7],0);
                                    in_stack_fffffe78 = iVar3;
                                  }
                                  iVar3 = strcmp(command,"fe_force_tx_tone");
                                  if (iVar3 != 0) break;
                                  fe_force_tx_tone(para_array[0]);
                                  phy_printf("Force TX TONE!\n");
                                }
                                iVar3 = strcmp(command,"bt_tx_tone");
                                if (iVar3 != 0) break;
                                bt_force_tx_tone(para_array[0],para_array[1],para_array[2]);
                              }
                              iVar3 = strcmp(command,"fcc_bt_tx");
                              if (iVar3 != 0) break;
                              phy_printf("fcc_bt_tx: txpwr=%d, hoppe=%d, chan=%d, rate=%d, DH_type=%d, data_type=%d\n"
                                         ,para_array[0],para_array[1],para_array[2],para_array[3],
                                         para_array[4],para_array[5]);
                              in_a14 = para_array[4];
                              in_a15 = para_array[5];
                              in_stack_fffffe70 = para_array[6];
                              fcc_tx(para_array[0],para_array[1],para_array[2],para_array[3],
                                     para_array[4],para_array[5],para_array[6]);
                            }
                            iVar3 = strcmp(command,"fcc_le_tx");
                            if (iVar3 != 0) break;
                            in_a14 = para_array[4];
                            fcc_le_tx(para_array[0],para_array[1],para_array[2],para_array[3],
                                      para_array[4]);
                          }
                          iVar3 = strcmp(command,"fcc_le_tx_syncw");
                          if (iVar3 != 0) break;
                          in_a14 = para_array[4];
                          in_a15 = para_array[5];
                          fcc_le_tx_syncw(para_array[0],para_array[1],para_array[2],para_array[3],
                                          para_array[4],para_array[5]);
                        }
                        iVar3 = strcmp(command,"fcc_le_tx_syncw_hoppe");
                        if (iVar3 != 0) break;
                        in_a14 = para_array[3];
                        rw_le_tx_hoppe_syncw
                                  (para_array[0],0xffff,para_array[1],para_array[2],para_array[3]);
                      }
                      iVar3 = strcmp(command,"fcc_bt_en");
                      if (iVar3 != 0) break;
                      fcc_bt_en();
                    }
                    iVar3 = strcmp(command,"rw_le_tx");
                    if (iVar3 != 0) break;
                    in_a14 = para_array[4];
                    rw_le_tx(para_array[0],para_array[1],para_array[2],para_array[3],para_array[4]);
                  }
                  iVar3 = strcmp(command,"rw_le_tx_nohoppe");
                  if (iVar3 != 0) break;
                  in_a14 = para_array[4];
                  in_a15 = para_array[5];
                  rw_le_tx_nohoppe(para_array[0],para_array[1],para_array[2],para_array[3],
                                   para_array[4],para_array[5]);
                }
                iVar3 = strcmp(command,"rw_rx_per");
                if (iVar3 != 0) break;
                rw_rx_per(para_array[0],para_array[1]);
              }
              iVar3 = strcmp(command,"rw_rx_per_ulap");
              if (iVar3 != 0) break;
              rw_rx_per_ulap(para_array[0],para_array[1],para_array[2],para_array[3]);
            }
            iVar3 = strcmp(command,"rw_rx_per_ulap_rssi");
            if (iVar3 != 0) break;
            rw_rx_per_ulap_rssi(para_array[0],para_array[1],para_array[2],para_array[3]);
          }
          iVar3 = strcmp(command,"rw_le_rx_per");
          if ((iVar3 != 0) && (iVar3 = strcmp(command,"rw_le_rx_per_syncw"), iVar3 != 0)) break;
          rw_le_rx_per_syncw(para_array[0],para_array[1]);
        }
        iVar3 = strcmp(command,"rw_le_rx_per_rssi");
        if (iVar3 != 0) break;
        rw_le_rx_per_syncw_rssi(para_array[0],para_array[1]);
      }
      iVar3 = strcmp(command,"rw_rx_dump");
      if (iVar3 != 0) break;
      in_a14 = para_array[4];
      in_a15 = para_array[5];
      in_stack_fffffe70 = para_array[6];
      uVar4 = rw_rx_dump(para_array[0],para_array[1],para_array[2],para_array[3],para_array[4],
                         para_array[5],para_array[6]);
      phy_printf("rw rx dump done! %d\n",uVar4);
    }
    iVar3 = strcmp(command,"rw_inq");
    if (iVar3 == 0) {
                    // WARNING: Subroutine does not return
      rw_inq_cmd(para_array[0],para_array[1]);
    }
    iVar3 = strcmp(command,"rw_inq_scan");
    if (iVar3 == 0) {
                    // WARNING: Subroutine does not return
      rw_inq_scan_cmd(para_array[0],para_array[1]);
    }
    iVar3 = strcmp(command,"rw_page_scan");
    if (iVar3 == 0) break;
    iVar3 = strcmp(command,"rw_page");
    if (iVar3 == 0) {
                    // WARNING: Subroutine does not return
      rw_page_cmd(para_array[0],para_array[1],para_array[2]);
    }
    iVar3 = strcmp(command,"rw_mst");
    if (iVar3 == 0) {
                    // WARNING: Subroutine does not return
      rw_mst_cmd(para_array[0],para_array[1],para_array[2]);
    }
    iVar3 = strcmp(command,"cmd_polling_test");
    if (iVar3 == 0) {
      cmd_polling_test();
      phy_printf("start polling\n");
    }
    else {
      iVar3 = strcmp(command,"cmd_polling_start");
      if (iVar3 == 0) {
        cmd_polling_start(100);
        phy_printf("start polling\n");
      }
      else {
        iVar3 = strcmp(command,"rw_le_rx_per_polling");
        if (iVar3 == 0) {
          rw_le_rx_per_syncw_polling(para_array[0]);
        }
        else {
          iVar3 = strcmp(command,"rw_le_rx_per_polling_stop");
          if (iVar3 == 0) {
            rw_le_rx_per_syncw_polling_stop();
          }
          else {
            iVar3 = strcmp(command,"read_flash");
            if (iVar3 == 0) {
              READ_SPI_INIT_PARAM(para_array[0],initdata);
            }
            else {
              iVar3 = strcmp(command,"gpio_output_set");
              if (iVar3 == 0) {
                if (para_array[0] < 0x20) {
                  gpio_output_set(para_array[1] << 0x20 - (0x20 - (para_array[0] & 0x1fU)),
                                  (uint)(para_array[1] == 0) <<
                                  0x20 - (0x20 - (para_array[0] & 0x1fU)),
                                  1 << 0x20 - (0x20 - (para_array[0] & 0x1fU)));
                }
                else {
                  uVar6 = para_array[0] - 0x20;
                  gpio_output_set_high
                            (para_array[1] << 0x20 - (0x20 - (uVar6 & 0x1f)),
                             (uint)(para_array[1] == 0) << 0x20 - (0x20 - (uVar6 & 0x1f)),
                             1 << 0x20 - (0x20 - (uVar6 & 0x1f)));
                }
                phy_printf("gpio_output_set: gpio_no=%d, out_set=%d\n",para_array[0],para_array[1]);
              }
              else {
                iVar3 = strcmp(command,"gpio_dis_output");
                if (iVar3 == 0) {
                  if (para_array[0] < 0x20) {
                    gpio_output_set(0,0,0,1 << 0x20 - (0x20 - (para_array[0] & 0x1fU)));
                  }
                  else {
                    gpio_output_set_high();
                  }
                  phy_printf("gpio_dis_output: gpio_no=%d\n",para_array[0]);
                }
                else {
                  iVar3 = strcmp(command,"gpio_input_get");
                  if (iVar3 == 0) {
                    if (para_array[0] < 0x20) {
                      uVar6 = gpio_input_get();
                      uVar6 = uVar6 >> (para_array[0] & 0x1fU);
                    }
                    else {
                      uVar6 = gpio_input_get_high();
                      uVar6 = uVar6 >> (para_array[0] & 0x1fU);
                    }
                    phy_printf("gpio_input_get: gpio_no=%d, get_value=%d\n",para_array[0],uVar6 & 1)
                    ;
                  }
                  else {
                    iVar3 = strcmp(command,"txtone");
                    if (iVar3 == 0) {
                      phy_printf(" wifi single carrier out\n");
                      in_a14 = para_array[4];
                      in_a15 = para_array[5];
                      (*g_phyFuns->start_tx_tone_)
                                (para_array[0],para_array[1],para_array[2],para_array[3],
                                 para_array[4],para_array[5]);
                    }
                    else {
                      iVar3 = strcmp(command,"stoptone");
                      if (iVar3 == 0) {
                        (*g_phyFuns->stop_tx_tone_)(para_array[0]);
                        phy_printf(" Wifi Tx Tone Over!\n");
                      }
                      else {
                        iVar3 = strcmp(command,"RFChannelSel");
                        if (iVar3 == 0) {
                          RFChannelSel((int8)para_array[0],(int8)para_array[1]);
                          phy_printf(" RF channel select as %d %d\n",para_array[0],para_array[1]);
                        }
                        else {
                          iVar3 = strcmp(command,"WifiRxStart");
                          if (iVar3 == 0) {
                            phy_printf("wifi rx in\n");
                            WifiRxStart(para_array[0]);
                          }
                          else {
                            iVar3 = strcmp(command,"FillTxPacket");
                            if (iVar3 == 0) {
                              in_a14 = para_array[4];
                              in_a15 = para_array[5];
                              in_stack_fffffe70 = para_array[6];
                              in_stack_fffffe74 = para_array[7];
                              in_stack_fffffe78 = para_array[8];
                              FillTxPacket(para_array[0],para_array[1],para_array[2],para_array[3],
                                           para_array[4],para_array[5],para_array[6],para_array[7],
                                           para_array[8],para_array[9],para_array[10],
                                           para_array[0xb]);
                              phy_printf("Fill Tx Packet OK!\n");
                            }
                            else {
                              iVar3 = strcmp(command,"mac_init");
                              if (iVar3 == 0) {
                                mac_init();
                                phy_printf("mac_init done\n");
                              }
                              else {
                                iVar3 = strcmp(command,"pbus_debugmode");
                                if (iVar3 == 0) {
                                  (*g_phyFuns->pbus_debugmode_)();
                                  phy_printf("pbus set debugmode ok!\n");
                                }
                                else {
                                  iVar3 = strcmp(command,"pbus_workmode");
                                  if (iVar3 == 0) {
                                    (*g_phyFuns->pbus_workmode_)();
                                    phy_printf("pbus set workmode ok!\n");
                                  }
                                  else {
                                    iVar3 = strcmp(command,"pbus");
                                    if (iVar3 == 0) {
                                      (*g_phyFuns->pbus_force_test_)
                                                ((u8)para_array[0],(u8)para_array[1],
                                                 (u16)para_array[2]);
                                      phy_printf("pbus set ok!\n");
                                    }
                                    else {
                                      iVar3 = strcmp(command,"pbus_rd");
                                      if (iVar3 == 0) {
                                        uVar2 = (*g_phyFuns->pbus_rd_)
                                                          ((u8)para_array[0],(u8)para_array[1]);
                                        phy_printf("0x%x\n",uVar2);
                                      }
                                      else {
                                        iVar3 = strcmp(command,"tx_pwr_print");
                                        if (iVar3 == 0) {
                                          phy_init_pwr_print();
                                        }
                                        else {
                                          iVar3 = strcmp(command,"bt_track_tx_power");
                                          if (iVar3 == 0) {
                                            uVar6 = para_array[0] & 0xff;
                                            iVar3 = (int)(char)(u8)para_array[1];
                                            bt_track_tx_power((u8)para_array[0],(u8)para_array[1]);
                                            phy_printf("bt_track_tx_power: %d, %d\n",uVar6,iVar3);
                                          }
                                          else {
                                            iVar3 = strcmp(command,"rd");
                                            if (iVar3 == 0) {
                                              memw();
                                              phy_printf("0x%x\n",*(undefined4 *)para_array[0]);
                                            }
                                            else {
                                              iVar5 = strcmp(command,"wr");
                                              iVar3 = para_array[0];
                                              if (iVar5 == 0) {
                                                memw();
                                                *(int *)para_array[0] = para_array[1];
                                                memw();
                                                phy_printf("0x%x\n",*(undefined4 *)iVar3);
                                              }
                                              else {
                                                iVar5 = strcmp(command,"sm");
                                                iVar3 = para_array[0];
                                                if (iVar5 == 0) {
                                                  memw();
                                                  memw();
                                                  *(uint *)para_array[0] =
                                                       *(uint *)para_array[0] | para_array[1];
                                                  memw();
                                                  phy_printf("reg 0x%x readback is 0x%x\n",iVar3,
                                                             *(undefined4 *)iVar3);
                                                }
                                                else {
                                                  iVar5 = strcmp(command,"cm");
                                                  iVar3 = para_array[0];
                                                  if (iVar5 == 0) {
                                                    memw();
                                                    memw();
                                                    *(uint *)para_array[0] =
                                                         (para_array[1] ^ 0xffffffffU) &
                                                         *(uint *)para_array[0];
                                                    memw();
                                                    phy_printf("reg 0x%x readback is 0x%x\n",iVar3,
                                                               *(undefined4 *)iVar3);
                                                  }
                                                  else {
                                                    iVar3 = strcmp(command,"gb");
                                                    if (iVar3 == 0) {
                                                      memw();
                                                      phy_printf("0x%x\n",(1 << 0x20 - (0x20 - ((
                                                  para_array[1] - para_array[2]) + 1U & 0x1f))) - 1U
                                                  & *(uint *)para_array[0] >>
                                                    (para_array[2] & 0x1fU));
                                                  }
                                                  else {
                                                    iVar3 = strcmp(command,"RdMem");
                                                    if (iVar3 == 0) {
                                                      _xtos_ints_off(0x1000);
                                                      puVar7 = (undefined4 *)para_array[0];
                                                      if ((uint)para_array[0] <
                                                          (uint)(para_array[0] + para_array[1])) {
                                                        do {
                                                          memw();
                                                          phy_printf("0x%x ",*puVar7);
                                                          puVar7 = puVar7 + 1;
                                                        } while (puVar7 < (undefined4 *)
                                                                          (para_array[0] +
                                                                          para_array[1]));
                                                      }
                                                      phy_printf(&DAT_00053b60);
                                                      _xtos_ints_on(0x1000);
                                                    }
                                                    else {
                                                      iVar3 = strcmp(command,"ri");
                                                      if (iVar3 == 0) {
                                                        uVar1 = (*g_phyFuns->i2c_readReg_)
                                                                          ((u8)para_array[0],
                                                                           (u8)para_array[1],
                                                                           (uint8)para_array[2]);
                                                        phy_printf("0x%x\n",uVar1);
                                                      }
                                                      else {
                                                        iVar3 = strcmp(command,"wi");
                                                        if (iVar3 == 0) {
                                                          (*g_phyFuns->i2c_writeReg_)
                                                                    ((u8)para_array[0],
                                                                     (u8)para_array[1],
                                                                     (uint8)para_array[2],
                                                                     (uint8)para_array[3]);
                                                          phy_printf("write ok!\n");
                                                        }
                                                        else {
                                                          iVar3 = strcmp(command,"wim");
                                                          if (iVar3 == 0) {
                                                            in_a15 = para_array[5] & 0xff;
                                                            in_a14 = para_array[4] & 0xff;
                                                            (*g_phyFuns->i2c_writeReg_Mask_)
                                                                      ((u8)para_array[0],
                                                                       (u8)para_array[1],
                                                                       (uint8)para_array[2],
                                                                       (uint8)para_array[3],
                                                                       (uint8)para_array[4],
                                                                       (uint8)para_array[5]);
                                                            phy_printf("write ok!\n");
                                                          }
                                                          else {
                                                            iVar3 = strcmp(command,"rim");
                                                            if (iVar3 == 0) {
                                                              in_a14 = para_array[4] & 0xff;
                                                              uVar1 = (*g_phyFuns->i2c_readReg_Mask_
                                                                      )((u8)para_array[0],
                                                                        (u8)para_array[1],
                                                                        (uint8)para_array[2],
                                                                        (uint8)para_array[3],
                                                                        (uint8)para_array[4]);
                                                              phy_printf("0x%x\n",uVar1);
                                                            }
                                                            else {
                                                              iVar3 = strcmp(command,"inquiry");
                                                              if (iVar3 == 0) {
                                                                inquiry();
                                                                phy_printf("inquiry ok \n");
                                                              }
                                                              else {
                                                                iVar3 = strcmp(command,
                                                  "inquiry_scan");
                                                  if (iVar3 == 0) {
                                                    inquiry_scan();
                                                    phy_printf("inquiry_scan ok \n");
                                                  }
                                                  else {
                                                    iVar3 = strcmp(command,"page");
                                                    if (iVar3 == 0) {
                                                      page();
                                                      phy_printf("page ok \n");
                                                    }
                                                    else {
                                                      iVar3 = strcmp(command,"page_scan");
                                                      if (iVar3 == 0) {
                                                        page_scan();
                                                        phy_printf("page_scan ok \n");
                                                      }
                                                      else {
                                                        iVar3 = strcmp(command,"le_adv");
                                                        if (iVar3 == 0) {
                                                          le_adv();
                                                          phy_printf("adv ok \n");
                                                        }
                                                        else {
                                                          iVar3 = strcmp(command,"le_advscan");
                                                          if (iVar3 == 0) {
                                                            le_advscan();
                                                            phy_printf("advscan ok \n");
                                                          }
                                                          else {
                                                            iVar3 = strcmp(command,"le_adv_test");
                                                            if (iVar3 == 0) {
                                                              in_a14 = para_array[4];
                                                              in_a15 = para_array[5];
                                                              in_stack_fffffe70 = para_array[6];
                                                              in_stack_fffffe74 = para_array[7];
                                                              le_adv_test(para_array[0],
                                                                          para_array[1],
                                                                          para_array[2],
                                                                          para_array[3]);
                                                              phy_printf("adv_test ok \n");
                                                            }
                                                            else {
                                                              iVar3 = strcmp(command,
                                                  "le_advscan_test");
                                                  if (iVar3 == 0) {
                                                    in_a14 = para_array[4];
                                                    in_a15 = para_array[5];
                                                    in_stack_fffffe70 = para_array[6];
                                                    in_stack_fffffe74 = para_array[7];
                                                    in_stack_fffffe78 = para_array[8];
                                                    le_advscan_test(para_array[0],para_array[1],
                                                                    para_array[2],para_array[3]);
                                                    phy_printf("advscan_test ok \n");
                                                  }
                                                  else {
                                                    iVar3 = strcmp(command,"adv_scan_test");
                                                    if (iVar3 == 0) {
                                                      adv_scan_test(para_array[0],para_array[1],
                                                                    para_array[2],para_array[3]);
                                                      phy_printf("adv_scan_test ok \n");
                                                    }
                                                    else {
                                                      iVar3 = strcmp(command,"encrypt");
                                                      if (iVar3 == 0) {
                                                        in_a14 = para_array[4];
                                                        in_a15 = para_array[5];
                                                        in_stack_fffffe70 = para_array[6];
                                                        in_stack_fffffe74 = para_array[7];
                                                        encrypt((char *)para_array[0],para_array[1])
                                                        ;
                                                        phy_printf("encrypt ok \n");
                                                      }
                                                      else {
                                                        phy_printf("cmd not exist!\n");
                                                      }
                                                    }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
                    // WARNING: Subroutine does not return
  rw_page_scan_cmd(para_array[0],para_array[1],para_array[2]);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_wait4tx_end_(void)

{
  do {
    memw();
    if ((_DAT_60032104 & 1) != 0) break;
    memw();
  } while ((_DAT_60032100 & 0x200) == 0);
  memw();
  memw();
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x201;
  memw();
  wait4tx_en_valid = 0;
  return _DAT_600320ac & 0xff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BT_test_mode_fill_tx_payload_
               (u32 lpayload,u32 data_type,u32 loopback,u32 device_sel,u32 tx_addr_base)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320bc =
       (_DAT_3ffc9008 & 0xffff) << 10 | _DAT_3ffc9008 >> 0x16 | _DAT_600320bc & 0xfc000000;
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x9010;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_NALL_packet_struct(void)

{
  packet_NULL.type_code = 0;
  packet_NULL.link_type = 1;
  packet_NULL.payload_header_length = 0;
  packet_NULL.payload_length = 0;
  packet_NULL.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_POLL_packet_struct(void)

{
  packet_POLL.type_code = 1;
  packet_POLL.link_type = 1;
  packet_POLL.payload_header_length = 0;
  packet_POLL.payload_length = 0;
  packet_POLL.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_FHS_packet_struct(void)

{
  packet_FHS.type_code = 2;
  packet_FHS.link_type = 1;
  packet_FHS.payload_header_length = 0;
  packet_FHS.payload_length = 0x12;
  packet_FHS.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_DM1_packet_struct(void)

{
  packet_DM1.link_type = 1;
  packet_DM1.payload_header_length = 1;
  packet_DM1.payload_length = 0x11;
  packet_DM1.type_code = 3;
  packet_DM1.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_DH1_packet_struct(void)

{
  packet_DH1.type_code = 4;
  packet_DH1.link_type = 4;
  packet_DH1.payload_header_length = 1;
  packet_DH1.payload_length = 0x1b;
  packet_DH1.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_2DH1_packet_struct(void)

{
  packet_2DH1.type_code = 4;
  packet_2DH1.link_type = 5;
  packet_2DH1.payload_header_length = 2;
  packet_2DH1.payload_length = 0x36;
  packet_2DH1.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_HV1_packet_struct(void)

{
  packet_HV1.type_code = 5;
  packet_HV1.link_type = 1;
  packet_HV1.payload_header_length = 0;
  packet_HV1.payload_length = 10;
  packet_HV1.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_HV2_packet_struct(void)

{
  packet_HV2.type_code = 6;
  packet_HV2.link_type = 1;
  packet_HV2.payload_header_length = 0;
  packet_HV2.payload_length = 0x14;
  packet_HV2.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_HV3_packet_struct(void)

{
  packet_HV3.type_code = 7;
  packet_HV3.link_type = 1;
  packet_HV3.payload_header_length = 0;
  packet_HV3.payload_length = 0x1e;
  packet_HV3.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_DV_packet_struct(void)

{
  packet_DV.type_code = 8;
  packet_DV.payload_header_length = 0;
  packet_DV.link_type = 1;
  packet_DV.payload_length = 0x14;
  packet_DV.payload1_header_length = 1;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_EV3_packet_struct(void)

{
  packet_EV3.type_code = 7;
  packet_EV3.link_type = 2;
  packet_EV3.payload_header_length = 0;
  packet_EV3.payload_length = 0x1e;
  packet_EV3.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_EV4_packet_struct(void)

{
  packet_EV4.type_code = 0xc;
  packet_EV4.link_type = 2;
  packet_EV4.payload_header_length = 0;
  packet_EV4.payload_length = 0x1e;
  packet_EV4.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_EV5_packet_struct(void)

{
  packet_EV5.type_code = 0xd;
  packet_EV5.link_type = 2;
  packet_EV5.payload_header_length = 0;
  packet_EV5.payload_length = 0x1e;
  packet_EV5.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_2EV3_packet_struct(void)

{
  packet_2EV3.type_code = 6;
  packet_2EV3.link_type = 3;
  packet_2EV3.payload_header_length = 0;
  packet_2EV3.payload_length = 0x1e;
  packet_2EV3.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_3EV3_packet_struct(void)

{
  packet_3EV3.type_code = 7;
  packet_3EV3.link_type = 3;
  packet_3EV3.payload_header_length = 0;
  packet_3EV3.payload_length = 0x1e;
  packet_3EV3.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_2EV5_packet_struct(void)

{
  packet_2EV5.type_code = 0xc;
  packet_2EV5.link_type = 3;
  packet_2EV5.payload_header_length = 0;
  packet_2EV5.payload_length = 0x1e;
  packet_2EV5.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_3EV5_packet_struct(void)

{
  packet_3EV5.type_code = 0xd;
  packet_3EV5.link_type = 3;
  packet_3EV5.payload_header_length = 0;
  packet_3EV5.payload_length = 0x1e;
  packet_3EV5.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_AUX1_packet_struct(void)

{
  packet_AUX1.type_code = 9;
  packet_AUX1.link_type = 4;
  packet_AUX1.payload_header_length = 1;
  packet_AUX1.payload_length = 0x1d;
  packet_AUX1.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_DM3_packet_struct(void)

{
  packet_DM3.type_code = 10;
  packet_DM3.link_type = 4;
  packet_DM3.payload_header_length = 2;
  packet_DM3.payload_length = 0x79;
  packet_DM3.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_DH3_packet_struct(void)

{
  packet_DH3.type_code = 0xb;
  packet_DH3.link_type = 4;
  packet_DH3.payload_header_length = 2;
  packet_DH3.payload_length = 0xb7;
  packet_DH3.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_DM5_packet_struct(void)

{
  packet_DM5.type_code = 0xe;
  packet_DM5.link_type = 4;
  packet_DM5.payload_header_length = 2;
  packet_DM5.payload_length = 0xe0;
  packet_DM5.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_DH5_packet_struct(void)

{
  packet_DH5.type_code = 0xf;
  packet_DH5.link_type = 4;
  packet_DH5.payload_header_length = 2;
  packet_DH5.payload_length = 0x153;
  packet_DH5.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_3DH1_packet_struct(void)

{
  packet_3DH1.type_code = 8;
  packet_3DH1.link_type = 5;
  packet_3DH1.payload_header_length = 2;
  packet_3DH1.payload_length = 0x53;
  packet_3DH1.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_2DH3_packet_struct(void)

{
  packet_2DH3.type_code = 10;
  packet_2DH3.link_type = 5;
  packet_2DH3.payload_header_length = 2;
  packet_2DH3.payload_length = 0x16f;
  packet_2DH3.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_3DH3_packet_struct(void)

{
  packet_3DH3.type_code = 0xb;
  packet_3DH3.link_type = 5;
  packet_3DH3.payload_header_length = 2;
  packet_3DH3.payload_length = 0x228;
  packet_3DH3.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_2DH5_packet_struct(void)

{
  packet_2DH5.type_code = 0xe;
  packet_2DH5.link_type = 5;
  packet_2DH5.payload_header_length = 2;
  packet_2DH5.payload_length = 0x2a7;
  packet_2DH5.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void init_3DH5_packet_struct(void)

{
  packet_3DH5.type_code = 0xf;
  packet_3DH5.link_type = 5;
  packet_3DH5.payload_header_length = 2;
  packet_3DH5.payload_length = 0x3fd;
  packet_3DH5.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_init_packet_struct(void)

{
  packet_POLL.type_code = 1;
  packet_POLL.link_type = 1;
  packet_POLL.payload_header_length = 0;
  packet_POLL.payload_length = 0;
  packet_POLL.payload1_header_length = 0;
  packet_FHS.link_type = 1;
  packet_FHS.payload_length = 0x12;
  packet_FHS.type_code = 2;
  packet_FHS.payload_header_length = 0;
  packet_FHS.payload1_header_length = 0;
  packet_DM1.type_code = 3;
  packet_DM1.link_type = 1;
  packet_DM1.payload_header_length = 1;
  packet_DM1.payload_length = 0x11;
  packet_DM1.payload1_header_length = 0;
  packet_NULL.link_type = 1;
  packet_DH1.type_code = 4;
  packet_DH1.link_type = 4;
  packet_DH1.payload_header_length = 1;
  packet_DH1.payload_length = 0x1b;
  packet_2DH1.type_code = 4;
  packet_NULL.type_code = 0;
  packet_NULL.payload_header_length = 0;
  packet_NULL.payload_length = 0;
  packet_NULL.payload1_header_length = 0;
  packet_DH1.payload1_header_length = 0;
  packet_2DH1.link_type = 5;
  packet_2DH1.payload_length = 0x36;
  packet_HV1.type_code = 5;
  packet_HV1.payload_length = 10;
  packet_HV1.link_type = 1;
  packet_HV3.type_code = 7;
  packet_HV3.link_type = 1;
  packet_HV3.payload_length = 0x1e;
  packet_HV1.payload_header_length = 0;
  packet_HV1.payload1_header_length = 0;
  packet_HV3.payload_header_length = 0;
  packet_HV3.payload1_header_length = 0;
  packet_HV2.type_code = 6;
  packet_HV2.link_type = 1;
  packet_HV2.payload_length = 0x14;
  packet_DV.type_code = 8;
  packet_DV.link_type = 1;
  packet_DV.payload_length = 0x14;
  packet_DV.payload1_header_length = 1;
  packet_EV3.type_code = 7;
  packet_EV3.payload_length = 0x1e;
  packet_2DH1.payload_header_length = 2;
  packet_2DH1.payload1_header_length = 0;
  packet_HV2.payload_header_length = 0;
  packet_HV2.payload1_header_length = 0;
  packet_DV.payload_header_length = 0;
  packet_EV3.link_type = 2;
  packet_EV3.payload_header_length = 0;
  packet_EV3.payload1_header_length = 0;
  packet_EV5.type_code = 0xd;
  packet_EV5.payload_length = 0x1e;
  packet_EV5.link_type = 2;
  packet_EV5.payload_header_length = 0;
  packet_EV5.payload1_header_length = 0;
  packet_2EV3.type_code = 6;
  packet_2EV3.link_type = 3;
  packet_2EV3.payload_length = 0x1e;
  packet_2EV3.payload_header_length = 0;
  packet_2EV3.payload1_header_length = 0;
  packet_EV4.type_code = 0xc;
  packet_EV4.payload_length = 0x1e;
  packet_3EV3.type_code = 7;
  packet_3EV3.link_type = 3;
  packet_3EV3.payload_length = 0x1e;
  packet_2EV5.type_code = 0xc;
  packet_2EV5.link_type = 3;
  packet_2EV5.payload_length = 0x1e;
  packet_3EV5.type_code = 0xd;
  packet_EV4.link_type = 2;
  packet_EV4.payload_header_length = 0;
  packet_EV4.payload1_header_length = 0;
  packet_3EV3.payload_header_length = 0;
  packet_3EV3.payload1_header_length = 0;
  packet_2EV5.payload_header_length = 0;
  packet_2EV5.payload1_header_length = 0;
  packet_3EV5.link_type = 3;
  packet_3EV5.payload_length = 0x1e;
  packet_3EV5.payload_header_length = 0;
  packet_3EV5.payload1_header_length = 0;
  packet_AUX1.type_code = 9;
  packet_AUX1.link_type = 4;
  packet_AUX1.payload_header_length = 1;
  packet_AUX1.payload_length = 0x1d;
  packet_AUX1.payload1_header_length = 0;
  packet_DM3.type_code = 10;
  packet_DM3.link_type = 4;
  packet_DM3.payload_length = 0x79;
  packet_DM3.payload_header_length = 2;
  packet_DM3.payload1_header_length = 0;
  packet_DH3.payload_length = 0xb7;
  packet_DM5.payload_length = 0xe0;
  packet_DM5.link_type = 4;
  packet_DH3.type_code = 0xb;
  packet_DH3.link_type = 4;
  packet_DM5.type_code = 0xe;
  packet_DM5.payload_header_length = 2;
  packet_DM5.payload1_header_length = 0;
  packet_DH5.link_type = 4;
  packet_DH5.payload_length = 0x153;
  packet_DH3.payload_header_length = 2;
  packet_DH3.payload1_header_length = 0;
  packet_DH5.type_code = 0xf;
  packet_DH5.payload_header_length = 2;
  packet_DH5.payload1_header_length = 0;
  packet_3DH1.type_code = 8;
  packet_3DH3.type_code = 0xb;
  packet_3DH1.link_type = 5;
  packet_3DH1.payload_header_length = 2;
  packet_3DH1.payload_length = 0x53;
  packet_3DH1.payload1_header_length = 0;
  packet_3DH3.link_type = 5;
  packet_3DH3.payload_header_length = 2;
  packet_3DH3.payload_length = 0x228;
  packet_3DH3.payload1_header_length = 0;
  packet_2DH3.type_code = 10;
  packet_2DH5.type_code = 0xe;
  packet_2DH5.link_type = 5;
  packet_2DH5.payload_header_length = 2;
  packet_2DH5.payload_length = 0x2a7;
  packet_2DH5.payload1_header_length = 0;
  packet_2DH3.link_type = 5;
  packet_2DH3.payload_header_length = 2;
  packet_2DH3.payload_length = 0x16f;
  packet_2DH3.payload1_header_length = 0;
  packet_3DH5.type_code = 0xf;
  packet_3DH5.link_type = 5;
  packet_3DH5.payload_header_length = 2;
  packet_3DH5.payload_length = 0x3fd;
  packet_3DH5.payload1_header_length = 0;
  return;
}



// WARNING: Unknown calling convention

u32 TX_CONF0(u32 sel)

{
  return 0x600320b4;
}



// WARNING: Unknown calling convention

u32 TX_CONF1(u32 sel)

{
  return 0x600320b8;
}



// WARNING: Unknown calling convention

u32 TX_HEAD(u32 sel)

{
  return 0x600320bc;
}



// WARNING: Unknown calling convention

u32 RX_CONF(u32 sel)

{
  return 0x600320c0;
}



// WARNING: Unknown calling convention

void prbs9_gen(u32 *pattern)

{
  u32 *puVar1;
  uint uVar2;
  uint uVar3;
  uint unaff_a9;
  uint uVar4;
  int iVar5;
  
  puVar1 = pattern + 0x101;
  uVar2 = 0xffff;
  do {
    uVar4 = 0;
    iVar5 = 0x20;
    do {
      uVar3 = uVar2 << 1;
      uVar2 = uVar3 | (uVar2 << 4 ^ uVar2) >> 8 & 1;
      unaff_a9 = (uVar3 >> 9 & 1) << 0x20 - (0x20 - (uVar4 & 0x1f)) |
                 (1 << 0x20 - (0x20 - (uVar4 & 0x1f)) ^ 0xffffffffU) & unaff_a9;
      uVar4 = uVar4 + 1;
      iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    *pattern = unaff_a9;
    pattern = pattern + 1;
  } while (puVar1 != pattern);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void prbs9_test(void)

{
  u32 pattern [257];
  
  prbs9_gen(pattern);
  phy_printf("0x%x, 0x%x, 0x%x, 0x%x\n",pattern[0],pattern[1],pattern[2],pattern[3]);
  return;
}



// WARNING: Unknown calling convention

u32 BT_test_mode_get_rx_payload_byte(u32 byte_position)

{
  memw();
  return *(uint *)(((byte_position >> 2) + 0xfff2404) * 4) >> ((byte_position & 3) << 3) & 0xff;
}



// WARNING: Unknown calling convention

u32 BT_test_mode_get_rx_payload_4byte(u32 byte_position)

{
  memw();
  return *(u32 *)(&DAT_3ffc9010 + byte_position);
}



// WARNING: Unknown calling convention

u32 BT_test_mode_get_tx_payload_byte
              (u32 data_type,u32 loopback,u32 byte_offset,u32 word_offset,u32 byte_cnt,
              u32 rx_addr_base)

{
  u32 unaff_a8;
  
  if (loopback == 1) {
    memw();
    unaff_a8 = *(u32 *)((word_offset + 4) * 4 + rx_addr_base);
  }
  else {
    switch(data_type) {
    case 1:
      unaff_a8 = 0;
      break;
    case 2:
      unaff_a8 = 0xffffffff;
      break;
    case 3:
      unaff_a8 = 0xaaaaaaaa;
      break;
    case 4:
      unaff_a8 = PRBS9[byte_cnt];
      break;
    case 9:
      unaff_a8 = 0xf0f0f0f0;
    }
  }
  return unaff_a8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_test_mode_fill_tx_payload
               (u32 lheader,u32 lpayload,u32 data_type,u32 loopback,u32 device_sel)

{
  u32 unaff_a10;
  u32 unaff_a11;
  u32 in_a12;
  u32 in_a13;
  u32 in_a14;
  
  if (loopback == 0) {
    switch(data_type) {
    case 1:
      unaff_a11 = 0;
      break;
    case 2:
      unaff_a11 = 0xffffffff;
      break;
    case 3:
      unaff_a11 = 0xaaaaaaaa;
      break;
    case 4:
      unaff_a11 = PRBS9[0];
      break;
    case 9:
      unaff_a11 = 0xf0f0f0f0;
    }
    memw();
    _DAT_3ffc8000 = unaff_a11;
    return;
  }
  if (loopback == 1) {
    BT_test_mode_fill_tx_payload_(unaff_a10,unaff_a11,in_a12,in_a13,in_a14);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int BT_tx_sim_debug(void)

{
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 1;
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_600321bc = _DAT_600321bc | 0x40000000;
  do {
    memw();
  } while ((_DAT_60032104 & 1) == 0);
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 1;
  memw();
  return (uint)((_DAT_600320ac & 0xff) != 0);
}



// WARNING: Removing unreachable block (ram,0x00023964)
// WARNING: Removing unreachable block (ram,0x00023967)
// WARNING: Removing unreachable block (ram,0x00023981)
// WARNING: Removing unreachable block (ram,0x00023984)
// WARNING: Removing unreachable block (ram,0x0002398c)
// WARNING: Unknown calling convention

int BT_tx_sim(u32 next_valid,u32 slave_sel)

{
  memw();
  memw();
  memw();
  memw();
  do {
    memw();
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x00023a14)
// WARNING: Removing unreachable block (ram,0x00023a17)
// WARNING: Removing unreachable block (ram,0x00023a31)
// WARNING: Removing unreachable block (ram,0x00023a44)
// WARNING: Removing unreachable block (ram,0x00023a4c)
// WARNING: Unknown calling convention

int BT_tx_sim_rx_prepare(u32 next_valid,u32 slave_sel)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  do {
    memw();
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x00023b03)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int BT_rx_sim_debug(void)

{
  memw();
  _DAT_3ffc9000 = 0;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 2;
  memw();
  memw();
  _DAT_600321bc = _DAT_600321bc | 0x80000000;
  memw();
  while (memw(), (_DAT_60032104 & 2) == 0) {
    memw();
  }
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 3;
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  return (uint)((_DAT_60032120 & 0xff) != 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int BT_rx_sim(u32 slave_sel)

{
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 | 0x80000000;
  do {
    memw();
  } while ((_DAT_60032100 & 2) == 0);
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  return _DAT_60032120 & 0xff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int BT_rx_sim_tx_prepare(u32 slave_sel)

{
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  memw();
  _DAT_600320c0 = _DAT_600320c0 | 0x80000000;
  memw();
  do {
    memw();
  } while ((int)_DAT_600320c0 < 0);
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 | 0x80000000;
  do {
    memw();
  } while ((_DAT_60032104 & 2) == 0);
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  return _DAT_60032120 & 0xff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_rx_en(u32 slave_sel)

{
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_tx_en(u32 slave_sel)

{
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_wait4tx_start(u32 slave_sel)

{
  do {
    memw();
  } while (_DAT_600320b4 < 0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_wait4rx_start(u32 slave_sel)

{
  do {
    memw();
  } while (_DAT_600320c0 < 0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_wait4rx_end(void)

{
  memw();
  new_phy_db1 = _DAT_60033c00;
  while (memw(), (_DAT_60032104 & 2) == 0) {
    memw();
    if (((_DAT_60032100 & 2) != 0) && (new_phy_db0 == 0)) {
      phy_printf(&DAT_000543dc);
      new_phy_db0 = 1;
    }
    memw();
    new_phy_db2 = _DAT_60033c00 - new_phy_db1;
    if ((1000000 < new_phy_db2) && (new_phy_db3 == 0)) {
      memw();
      memw();
      phy_printf("\nhaha! %x\n%x\n",_DAT_3ff000cc,_DAT_600321e0 & 0xf);
      new_phy_db3 = 1;
    }
  }
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  return _DAT_60032120 & 0xff;
}



// WARNING: Unknown calling convention

u32 BT_wait4tx_end_(void)

{
  u32 uVar1;
  
  uVar1 = 0;
  if (wait4tx_en_valid == 1) {
    uVar1 = BT_wait4tx_end_();
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_set_cmd_timer(u32 clksel,u32 time,u32 time_delay_us)

{
  uint uVar1;
  
  if (clksel == 0) {
    memw();
    memw();
    memw();
    _DAT_600320dc = 0;
    uVar1 = _DAT_60032000;
  }
  else {
    memw();
    memw();
    memw();
    _DAT_600320dc = 0x10000000;
    uVar1 = _DAT_60032024;
  }
  memw();
  memw();
  _DAT_600320dc = (uVar1 & 0xfffffff) + time & 0xfffffff | _DAT_600320dc;
  memw();
  memw();
  _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00 | time_delay_us & 0x3ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_mac_set_tx_bytelength
               (uint tx_buf_addr,int pheader_length,int pheader1_length,int payloadlength,
               u32 device_sel)

{
  memw();
  memw();
  _DAT_600320b8 = _DAT_600320b8 & 0xfffff800 | payloadlength & 0x7ffU;
  if (pheader_length == 0) {
    memw();
    memw();
    memw();
    _DAT_600320b0 =
         (payloadlength & 0x3ffU) << 0xc | _DAT_600320b0 & 0xffc00c00 | payloadlength & 0x3ffU;
    memw();
  }
  else if (pheader_length == 1) {
    memw();
    _DAT_600320bc = (payloadlength & 0x1fU) << 0xd | _DAT_600320bc & 0xfffc1fff;
    memw();
  }
  else if (pheader_length == 2) {
    memw();
    _DAT_600320bc = (payloadlength & 0x3ffU) << 0xd | _DAT_600320bc & 0xff801fff;
    memw();
  }
  if (pheader1_length != 0) {
    memw();
    _DAT_600320bc = (payloadlength - 10U & 0x1f) << 0xd | _DAT_600320bc & 0xfffc1fff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_mac_set_tx_type_code(uint tx_buf_addr,uint type_code,u32 device_sel)

{
  memw();
  memw();
  _DAT_600320bc = (type_code & 0xf) << 3 | _DAT_600320bc & 0xffffff87;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_mac_set_tx_link_type(uint link_type,u32 device_sel)

{
  memw();
  memw();
  _DAT_600320b4 = (link_type & 7) << 0x1c | _DAT_600320b4 & 0x8fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_mac_set_rx_link_type(uint link_type,u32 device_sel)

{
  memw();
  memw();
  _DAT_600320c0 = (link_type & 7) << 0x1c | _DAT_600320c0 & 0x8fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_eir_set_tx_bytelength(int pheader_length,int payloadlength)

{
  memw();
  memw();
  _DAT_600320d0 = _DAT_600320d0 & 0xfffff800 | payloadlength & 0x7ffU;
  if (pheader_length == 1) {
    memw();
    memw();
    _DAT_600320d4 = (payloadlength & 0x1fU) << 0xd | _DAT_600320d4 & 0xfffc1fff;
    return;
  }
  if (pheader_length == 2) {
    memw();
    _DAT_600320d4 = (payloadlength & 0x3ffU) << 0xd | _DAT_600320d4 & 0xff801fff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_eir_set_tx_type_code(uint type_code)

{
  memw();
  memw();
  _DAT_600320d4 = (type_code & 0xf) << 3 | _DAT_600320d4 & 0xffffff87;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_eir_packetheader(u32 LT_ADDR,u32 TYPE,u32 FLOW,u32 SEQN,u32 ARQN)

{
  memw();
  memw();
  _DAT_600320d4 =
       (SEQN << 9 | ARQN << 8 | LT_ADDR | FLOW << 7) & 0x3ff | (TYPE & 0xf) << 3 |
       _DAT_600320d4 & 0xfffffc00;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_eir_LLID(u32 LLID)

{
  memw();
  memw();
  _DAT_600320d4 = (LLID & 3 | 4) << 10 | _DAT_600320d4 & 0xffffe3ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_fill_eir_sample_pac(u32 type,u32 pheader_len,u32 len,u32 payload_addr)

{
  memw();
  _DAT_600320cc = _DAT_600320cc & 0xfffc0000 | payload_addr & 0x3ffff;
  memw();
  BT_eir_set_tx_bytelength(pheader_len,len);
  memw();
  memw();
  memw();
  memw();
  _DAT_600320d4 = _DAT_600320d4 & 0xffffe000 | 0x280 | (type & 0xf) << 3 | 0x1800;
  memw();
  memw();
  _DAT_600320e0 = _DAT_600320e0 | 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int BT_mac_loopback_df(u32 device_sel)

{
  bool bVar1;
  uint uVar2;
  uint *extraout_a3;
  uint *extraout_a3_00;
  u32 tx_length;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  uint *puVar6;
  
  uVar2 = _DAT_600320b8;
  memw();
  memw();
  memw();
  uVar5 = _DAT_600320b4 >> 0x1c & 7;
  memw();
  uVar3 = _DAT_3ffc8000 >> 3 & 0xf;
  if (_DAT_600320b8 != (_DAT_3ffc9000 & 0x7ff)) {
    phy_printf("type code=%d, link type=%d, \ntx rx length unequal! tx_length=%d,  rx_length=%d\n",
               uVar3,uVar5,_DAT_600320b8);
    return 1;
  }
  phy_printf("type code=%d, link type=%d, \nlength match! length=%d\n",uVar3,uVar5,_DAT_600320b8);
  bVar1 = false;
  uVar3 = 0;
  puVar4 = extraout_a3;
  if (uVar2 != 0) {
    do {
      puVar4 = (uint *)((((int)uVar3 >> 2) + 0xfff2000) * 4);
      puVar6 = puVar4 + 0x402;
      uVar5 = 0xff << 0x20 - ((uVar3 & 3) * -8 + 0x20);
      if (uVar3 != 1) {
        memw();
        memw();
        puVar4 = (uint *)(*puVar4 & uVar5);
        if (puVar4 != (uint *)(uVar5 & *puVar6)) {
          phy_printf("tx rx data mismatch! tx_data=0x%x,  rx_data=0x%x\n");
          bVar1 = true;
          puVar4 = extraout_a3_00;
        }
      }
      uVar3 = uVar3 + 1;
    } while (uVar2 != uVar3);
    if (bVar1) {
      return 1;
    }
  }
  phy_printf("TX RX header & payload all match\n",puVar4);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BT_mac_loopback_master_debug(packet_struct packet,u32 loopback)

{
  int iVar1;
  uint in_a3;
  int in_a4;
  int in_a5;
  int in_a6;
  int in_a7;
  uint uVar2;
  
  memw();
  _DAT_3ffc8000 = 0xf0f0f0f0;
  BT_mac_set_tx_bytelength(0x3ffc8000,in_a4,in_a6,in_a5,0);
  memw();
  _DAT_600320bc = (loopback & 0xf) << 3 | _DAT_600320bc & 0xffffff87;
  memw();
  memw();
  uVar2 = (in_a3 & 7) << 0x1c;
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar2;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar2;
  memw();
  iVar1 = BT_tx_sim_debug();
  if (iVar1 == 0) {
    phy_printf("tx success!\n");
  }
  else {
    phy_printf("tx fail!\n");
  }
  ets_delay_us(10);
  if (in_a7 == 1) {
    iVar1 = BT_rx_sim_debug();
    if (iVar1 == 0) {
      phy_printf("rx success!\n");
      BT_mac_loopback_df(0);
      return;
    }
    phy_printf("rx fail!\n");
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BT_mac_loopback_master(packet_struct packet,u32 loopback)

{
  int iVar1;
  uint in_a3;
  uint uVar2;
  int in_a4;
  int in_a5;
  int in_a6;
  int in_a7;
  
  memw();
  _DAT_3ffc8000 = 0xf0f0f0f0;
  BT_mac_set_tx_bytelength(0x3ffc8000,in_a4,in_a6,in_a5,0);
  memw();
  _DAT_600320bc = (loopback & 0xf) << 3 | _DAT_600320bc & 0xffffff87;
  memw();
  memw();
  uVar2 = (in_a3 & 7) << 0x1c;
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar2;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar2;
  memw();
  iVar1 = BT_tx_sim((uint)(in_a7 == 0),0);
  if (iVar1 != 0) {
    phy_printf("tx fail!\n");
    return;
  }
  phy_printf("tx success!\n");
  if (in_a7 == 1) {
    memw();
    _DAT_60032110 = &DAT_3ffc9000;
    memw();
    _DAT_600320c0 = _DAT_600320c0 | 0x80000000;
    memw();
    do {
      memw();
    } while ((_DAT_60032100 & 2) == 0);
    memw();
    _DAT_60032108 = _DAT_60032108 | 2;
    memw();
    memw();
    if ((_DAT_60032120 & 0xff) != 0) {
      iVar1 = 10;
      phy_printf(&DAT_00054508);
      while( true ) {
        memw();
        _DAT_60032110 = &DAT_3ffc9000;
        memw();
        _DAT_600320c0 = _DAT_600320c0 | 0x80000000;
        memw();
        do {
          memw();
        } while ((_DAT_60032100 & 2) == 0);
        memw();
        _DAT_60032108 = _DAT_60032108 | 2;
        memw();
        memw();
        if ((_DAT_60032120 & 0xff) == 0) break;
        iVar1 = iVar1 + -1;
        phy_printf(&DAT_00054508);
        if (iVar1 == 0) {
          phy_printf("\nrx fail!\n");
          return;
        }
      }
    }
    _DAT_60032110 = &DAT_3ffc9000;
    phy_printf("\nrx success!\n");
    BT_mac_loopback_df(0);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_mac_loopback_slave(u32 loopback,u32 link_type,u32 slave_sel)

{
  int iVar1;
  uint uVar2;
  u32 in_a13;
  u32 in_a14;
  undefined8 uVar3;
  u32 uStack_28;
  
  memw();
  uVar2 = (link_type & 7) << 0x1c;
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar2;
  memw();
  memw();
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar2 | 0x80000000;
  memw();
  do {
    memw();
    uStack_28 = 2;
  } while ((_DAT_60032100 & 2) == 0);
  memw();
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  memw();
  if ((_DAT_60032120 & 0xff) != 0) {
    uStack_28 = 2;
    phy_printf(&DAT_0005452c);
    iVar1 = 10;
    while( true ) {
      memw();
      _DAT_60032110 = &DAT_3ffc9000;
      memw();
      _DAT_600320c0 = _DAT_600320c0 | 0x80000000;
      memw();
      do {
        memw();
      } while ((_DAT_60032100 & 2) == 0);
      memw();
      _DAT_60032108 = _DAT_60032108 | 2;
      memw();
      memw();
      if ((_DAT_60032120 & 0xff) == 0) break;
      iVar1 = iVar1 + -1;
      phy_printf(&DAT_0005452c);
      if (iVar1 == 0) {
        phy_printf("rx fail!\n");
        return;
      }
    }
  }
  _DAT_60032110 = &DAT_3ffc9000;
  uVar3 = phy_printf("rx success!\n");
  if (loopback == 1) {
    memw();
    _DAT_600320b8 = _DAT_3ffc9000 & 0x7ff;
    memw();
    memw();
    _DAT_600320b0 = (_DAT_600320b8 - 2 & 0x3ff) << 0xc | _DAT_600320b0 & 0xffc00fff;
    memw();
    BT_test_mode_fill_tx_payload_
              ((u32)uVar3,(u32)((ulonglong)uVar3 >> 0x20),uStack_28,in_a13,in_a14);
    iVar1 = BT_tx_sim(0,slave_sel);
    if (iVar1 != 0) {
      phy_printf("tx fail!\n");
      return;
    }
    phy_printf("tx success!\n");
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_testmode_init(uint16 freq_offset_500k,uint16 freq,u32 nowhite)

{
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  BT_tx_8m_enable((uint)freq_offset_500k);
  BT_tx_if_init(0x14a,500,200,1);
  BT_init_rx_filters(freq_offset_500k);
  BT_mac_iqview_debug(nowhite);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_set_packet_attributes
               (u32 type_code,u32 link_type,u32 payload_header_len,u32 payload1_header_len,
               u32 payload_len,u32 device_sel)

{
  uint uVar1;
  
  BT_mac_set_tx_bytelength(0x3ffc8000,payload_header_len,payload1_header_len,payload_len,device_sel)
  ;
  memw();
  memw();
  _DAT_600320bc = (type_code & 0xf) << 3 | _DAT_600320bc & 0xffffff87;
  memw();
  uVar1 = (link_type & 7) << 0x1c;
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar1;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_s_set_nulap(u32 m_ulap,u32 m_nap,u32 s_ulap,u32 s_nap)

{
  memw();
  memw();
  _DAT_60032098 = s_ulap;
  memw();
  memw();
  _DAT_6003209c = _DAT_6003209c & 0xffff0000 | s_nap & 0xffff;
  memw();
  memw();
  _DAT_600320a0 = m_ulap;
  memw();
  memw();
  _DAT_600320a4 = _DAT_600320a4 & 0xffff0000 | m_nap & 0xffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_m_set_nulap(u32 m_ulap,u32 m_nap,u32 s_ulap,u32 s_nap)

{
  memw();
  memw();
  _DAT_60032098 = m_ulap;
  memw();
  memw();
  _DAT_6003209c = _DAT_6003209c & 0xffff0000 | m_nap & 0xffff;
  memw();
  memw();
  _DAT_60032090 = s_ulap;
  memw();
  memw();
  _DAT_60032094 = _DAT_60032094 & 0xffff0000 | s_nap & 0xffff;
  memw();
  memw();
  _DAT_600320a0 = s_ulap;
  memw();
  memw();
  _DAT_600320a4 = _DAT_600320a4 & 0xffff0000 | s_nap & 0xffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_get_fhs_lap(void)

{
  u32 byte;
  
  memw();
  return (_DAT_3ffc9014 & 0x3fffffc) >> 2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_get_fhs_uap(void)

{
  memw();
  return _DAT_3ffc9018 & 0xff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_get_fhs_nap(void)

{
  memw();
  memw();
  return (_DAT_3ffc9018 >> 0x10 & 0xff) << 8 | _DAT_3ffc9018 >> 8 & 0xff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_get_fhs_lt_addr(void)

{
  memw();
  return _DAT_3ffc901c >> 0x10 & 7;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_get_fhs_clk(void)

{
  memw();
  memw();
  return _DAT_3ffc901c >> 0x13 | (_DAT_3ffc9020 & 0x1fff) << 0xd;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_get_fhs_eir(void)

{
  u32 byte;
  
  memw();
  return (_DAT_3ffc9014 & 0x4000000) >> 0x1a;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_get_fhs_cod(void)

{
  memw();
  memw();
  return (_DAT_3ffc901c & 0xffff) << 8 | _DAT_3ffc9018 >> 0x18;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_get_LLID(void)

{
  memw();
  return _DAT_3ffc9008 & 3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_s_page_set_master_nulap(u32 slave_sel)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320a0 = _DAT_3ffc9018 << 0x18 | (_DAT_3ffc9014 & 0x3fffffc) >> 2;
  memw();
  memw();
  _DAT_600320a4 =
       _DAT_3ffc9018 >> 8 & 0xff | _DAT_600320a4 & 0xffff0000 | (_DAT_3ffc9018 >> 0x10 & 0xff) << 8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_s_page(u32 hoppe_en,u32 clk_debug,u32 slave_sel,u32 fast)

{
  STATUS SVar1;
  u32 uVar2;
  int in_a6;
  uint uVar3;
  
  memw();
  uVar3 = _DAT_60032000 | 0x80000000;
  memw();
  memw();
  _DAT_60032024 = _DAT_60032024 | 0x80000000;
  memw();
  memw();
  _DAT_60032040 = _DAT_60032040 | 0x80000000;
  memw();
  memw();
  _DAT_60032054 = _DAT_60032054 | 0x80000000;
  memw();
  memw();
  _DAT_60032068 = _DAT_60032068 | 0x80000000;
  memw();
  memw();
  _DAT_6003207c = _DAT_6003207c | 0x80000000;
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x400;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 0x400;
  memw();
  if (hoppe_en == 0) {
    memw();
    _DAT_600321bc = _DAT_600321bc | 0x10000000;
    memw();
    memw();
    _DAT_600321b8 = _DAT_600321b8 & 0xf0000000 | clk_debug & 0xfffffff;
    memw();
  }
  memw();
  memw();
  memw();
  memw();
  _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0x1ff & 0xfffffff;
  memw();
  memw();
  _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 4;
  memw();
  _DAT_60032000 = uVar3;
  if (fast == 1) {
    memw();
    in_a6 = _DAT_60032018;
  }
LAB_00024c75:
  memw();
  if ((_DAT_60032104 & 0x400) == 0) {
    SVar1 = GetStopCmd();
    memw();
    if (((uint)(_DAT_60032018 - in_a6) < 0xc351) && (SVar1 != OK)) {
      if (SVar1 == BUSY) {
        phy_printf("Busy!\n");
      }
      goto LAB_00024c75;
    }
    memw();
    _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0;
    memw();
    do {
      memw();
    } while ((_DAT_60032104 & 0x400) == 0);
    memw();
    _DAT_60032108 = _DAT_60032108 | 0x400;
    memw();
  }
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x400;
  memw();
  memw();
  tstart_debug = _DAT_60033c00;
  memw();
  uVar2 = 1;
  if ((_DAT_600320c4 & 0xf) == 0) {
    BT_s_page_set_master_nulap(slave_sel);
    memw();
    _DAT_600320c8 = _DAT_600320c8 | 0x10;
    memw();
    memw();
    memw();
    memw();
    memw();
    do {
      memw();
    } while ((_DAT_60032104 & 1) != 0);
    memw();
    _DAT_600320fc = _DAT_600320fc | 3;
    memw();
    memw();
    _DAT_60032108 = _DAT_60032108 | 3;
    memw();
    do {
      memw();
      uVar2 = _DAT_60032104 & 2;
    } while (uVar2 != 0);
  }
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_m_page(u32 hoppe_en,u32 clk_debug,u32 lt_addr)

{
  STATUS SVar1;
  
  memw();
  _DAT_600320e0 = (lt_addr & 7) << 4 | _DAT_600320e0 & 0xffffff8f;
  memw();
  memw();
  memw();
  memw();
  _DAT_60032024 = _DAT_60032024 | 0x80000000;
  memw();
  memw();
  _DAT_6003207c = _DAT_6003207c | 0x80000000;
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x400;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 0x400;
  memw();
  if (hoppe_en == 0) {
    memw();
    _DAT_600321bc = _DAT_600321bc | 0x10000000;
    memw();
    memw();
    _DAT_600321b8 = _DAT_600321b8 & 0xf0000000 | clk_debug & 0xfffffff;
    memw();
  }
  memw();
  memw();
  memw();
  memw();
  _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0x8ff & 0xfffffff;
  memw();
  memw();
  _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 3;
  memw();
  _DAT_60032000 = _DAT_60032000 | 0x80000000;
  while (memw(), (_DAT_60032104 & 0x400) == 0) {
    SVar1 = GetStopCmd();
    if (SVar1 == OK) {
      memw();
      memw();
      do {
        memw();
      } while ((_DAT_60032104 & 0x400) == 0);
      goto LAB_00024fe8;
    }
    if (SVar1 == BUSY) {
      phy_printf("Busy!\n");
    }
  }
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x400;
  memw();
  memw();
  if ((_DAT_600320c4 & 0xf) != 0) {
    memw();
    if ((_DAT_600320cc & 0x20000000) == 0) {
      memw();
      _DAT_600320cc = _DAT_600320cc | 0x20000000;
      memw();
    }
    else {
      memw();
      _DAT_600320cc = _DAT_600320cc & 0xdfffffff;
      memw();
    }
    memw();
    memw();
    memw();
    memw();
    _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0x8ff & 0xfffffff;
    memw();
    memw();
    _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
    memw();
    memw();
    _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 3;
    memw();
    while (memw(), (_DAT_60032104 & 0x400) == 0) {
      SVar1 = GetStopCmd();
      if (SVar1 == OK) {
        memw();
        memw();
        do {
          memw();
        } while ((_DAT_60032104 & 0x400) == 0);
LAB_00024fe8:
        _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0;
        memw();
        _DAT_60032108 = _DAT_60032108 | 0x400;
        memw();
        phy_printf("Busy!\n");
        return 1;
      }
      if (SVar1 == BUSY) {
        phy_printf("Busy!\n");
      }
    }
  }
  memw();
  tstart_debug = _DAT_60033c00;
  memw();
  memw();
  clk_debug1 = _DAT_60032000 & 0xfffffff;
  if ((_DAT_600320c4 & 0xf) == 0) {
    memw();
    memw();
    _DAT_600320c8 = _DAT_600320c8 | 0x100;
    memw();
    memw();
    memw();
    memw();
    do {
      memw();
    } while ((_DAT_60032104 & 1) != 0);
    memw();
    memw();
    _DAT_600320fc = _DAT_600320fc | 3;
    memw();
    memw();
    _DAT_60032108 = _DAT_60032108 | 3;
    do {
      memw();
    } while ((_DAT_60032104 & 2) != 0);
    return 0;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_rx_prbs9_status(u32 *total_bits,u32 *err_bits)

{
  u32 word_len;
  uint uVar1;
  uint uVar2;
  u32 last_mask;
  uint uVar3;
  uint uVar4;
  u32 uVar5;
  uint uVar6;
  uint *puVar7;
  u32 *puVar8;
  
  puVar7 = _DAT_60032110;
  uVar3 = 0xffff;
  memw();
  memw();
  uVar4 = *_DAT_60032110 & 0x7ff;
  uVar2 = *_DAT_60032110 & 3;
  uVar1 = uVar4 >> 2;
  if (((uVar2 != 2) && (uVar3 = 0xffffff, uVar2 != 3)) && (uVar3 = 0, uVar2 == 1)) {
    uVar3 = 0xff;
  }
  uVar5 = 0;
  puVar8 = PRBS9;
  *err_bits = 0;
  puVar7 = puVar7 + 4;
  uVar2 = 0;
  do {
    memw();
    uVar6 = *puVar7 ^ *puVar8;
    if (uVar2 == uVar1) {
      uVar6 = uVar3 & uVar6;
    }
    uVar5 = uVar5 + (uVar6 & 1);
    *err_bits = uVar5;
    uVar2 = uVar2 + 1;
    puVar7 = puVar7 + 1;
    puVar8 = puVar8 + 1;
  } while (uVar2 != uVar1 + 1);
  *total_bits = uVar4 << 3;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_rx_prbs9_err_bits(void)

{
  u32 total_bits;
  u32 err_bits;
  
  BT_rx_prbs9_status(&total_bits,&err_bits);
  phy_printf("%x %x\n",total_bits,err_bits);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_rx_content_status(u32 *total_bits,u32 *err_bits,u32 data_type)

{
  uint uVar1;
  uint in_a5;
  uint uVar2;
  uint uVar3;
  u32 uVar4;
  uint uVar5;
  uint *puVar6;
  u32 *puVar7;
  u32 last_mask;
  uint uStack_3c;
  
  puVar6 = _DAT_60032110;
  memw();
  last_mask = 0xffff;
  memw();
  uVar2 = *_DAT_60032110 & 0x7ff;
  uVar3 = *_DAT_60032110 & 3;
  uVar1 = uVar2 >> 2;
  if (((uVar3 != 2) && (last_mask = 0xffffff, uVar3 != 3)) && (last_mask = 0xff, uVar3 != 1)) {
    last_mask = 0;
  }
  uVar4 = 0;
  puVar7 = PRBS9;
  *err_bits = 0;
  puVar6 = puVar6 + 4;
  uVar3 = 0;
  do {
    memw();
    if (uVar3 == uVar1) {
      switch(data_type) {
      case 1:
        uStack_3c = 0;
        break;
      case 2:
        uStack_3c = 0xffffffff;
        break;
      case 3:
        uStack_3c = 0;
        break;
      case 4:
        uStack_3c = *puVar7;
        break;
      case 9:
        uStack_3c = 0;
      }
      uVar5 = last_mask & (*puVar6 ^ uStack_3c);
    }
    else {
      switch(data_type) {
      case 1:
        in_a5 = 0;
        break;
      case 2:
        in_a5 = 0xffffffff;
        break;
      case 3:
        in_a5 = 0;
        break;
      case 4:
        in_a5 = *puVar7;
        break;
      case 9:
        in_a5 = 0;
      }
      uVar5 = *puVar6 ^ in_a5;
    }
    uVar4 = uVar4 + (uVar5 & 1);
    *err_bits = uVar4;
    uVar3 = uVar3 + 1;
    puVar6 = puVar6 + 1;
    puVar7 = puVar7 + 1;
  } while (uVar3 != uVar1 + 1);
  *total_bits = uVar2 << 3;
  return;
}



// WARNING: Unknown calling convention

sint16 noise_init_bt(void)

{
  sint16 sVar1;
  
  sVar1 = (*g_phyFuns->check_noise_floor_)();
  return sVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_loopback_master(u32 loopback,uint16 freq_offset_500k,uint16 freq,u32 link_type,u32 nowhite)

{
  STATUS SVar1;
  packet_struct *ppVar2;
  uint8 in_a12;
  packet_struct in_stack_ffffffe0;
  
  set_chan_freq_sw_start('\0',freq,in_a12);
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  BT_tx_8m_enable(0x3b);
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  BT_mac_iqview_debug(nowhite);
  BT_init_packet_struct();
  do {
    if (link_type == 1) {
      ets_delay_us(100);
      BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_NULL.type_code);
      ets_delay_us(100);
      BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_POLL.type_code);
      ets_delay_us(100);
      BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_FHS.type_code);
      ets_delay_us(100);
      BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_DM1.type_code);
      ets_delay_us(100);
      BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_HV1.type_code);
      ets_delay_us(100);
      BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_HV2.type_code);
      ets_delay_us(100);
      BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_HV3.type_code);
      ets_delay_us(100);
      ppVar2 = &packet_DV;
LAB_0002573c:
      BT_mac_loopback_master_debug(in_stack_ffffffe0,ppVar2->type_code);
    }
    else {
      if (link_type == 2) {
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_EV3.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_EV4.type_code);
        ets_delay_us(100);
        ppVar2 = &packet_EV5;
        goto LAB_0002573c;
      }
      if (link_type == 3) {
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_2EV3.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_2EV5.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_3EV3.type_code);
        ets_delay_us(100);
        ppVar2 = &packet_3EV5;
        goto LAB_0002573c;
      }
      if (link_type == 4) {
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_NULL.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_POLL.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_FHS.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_DM1.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_DH1.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_DH3.type_code);
        ets_delay_us(100);
        ppVar2 = &packet_DH5;
LAB_0002571c:
        BT_mac_loopback_master_debug(in_stack_ffffffe0,ppVar2->type_code);
        ets_delay_us(100);
        ppVar2 = &packet_AUX1;
        goto LAB_0002573c;
      }
      if (link_type == 5) {
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_NULL.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_POLL.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_FHS.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_DM1.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_2DH1.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_3DH1.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_2DH3.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_3DH3.type_code);
        ets_delay_us(100);
        BT_mac_loopback_master_debug(in_stack_ffffffe0,packet_2DH5.type_code);
        ets_delay_us(100);
        ppVar2 = &packet_3DH5;
        goto LAB_0002571c;
      }
    }
    SVar1 = GetStopCmd();
    if (SVar1 == OK) {
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_loopback_slave(u32 link_type,u32 loopback,u32 rx_payload_length,uint16 freq_offset_500k,
                      uint16 freq,u32 nowhite)

{
  uint uVar1;
  int iVar2;
  STATUS SVar3;
  uint8 in_a12;
  u32 loopback_00;
  u32 device_sel;
  u32 in_a14;
  undefined8 uVar4;
  
  set_chan_freq_sw_start('\0',freq,in_a12);
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  BT_tx_8m_enable(0x3b);
  device_sel = 1;
  loopback_00 = 200;
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  uVar1 = (link_type & 7) << 0x1c;
  BT_mac_iqview_debug(nowhite);
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar1;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar1;
  memw();
  memw();
  _DAT_600320b0 = _DAT_600320b0 & 0xfffffc00 | 0x1e;
  memw();
  ets_delay_us(200);
  if (loopback != 0) {
    do {
      iVar2 = BT_rx_sim_debug();
      if (iVar2 == 0) {
        uVar4 = phy_printf("rx success!\n");
        memw();
        _DAT_600320b8 = _DAT_3ffc9000 & 0x7ff;
        memw();
        memw();
        _DAT_600320b0 = (_DAT_600320b8 - 2 & 0x3ff) << 0xc | _DAT_600320b0 & 0xffc00fff;
        memw();
        BT_test_mode_fill_tx_payload_
                  ((u32)uVar4,(u32)((ulonglong)uVar4 >> 0x20),loopback_00,device_sel,in_a14);
        ets_delay_us(100);
        iVar2 = BT_tx_sim_debug();
        if (iVar2 == 0) {
          phy_printf("tx success!\n");
        }
        else {
          phy_printf("tx fail!\n");
        }
        ets_delay_us(10);
      }
      else {
        phy_printf("rx fail!\n");
      }
      SVar3 = GetStopCmd();
    } while (SVar3 != OK);
    return;
  }
  iVar2 = BT_rx_sim_debug();
  if (iVar2 != 0) {
    phy_printf("rx fail!\n");
    return;
  }
  phy_printf("rx success!\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_inquiry_test(u32 hoppe_en,u32 chan)

{
  STATUS SVar1;
  uint uVar2;
  uint8 in_a12;
  
  memw();
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffff0000 | 0x9696;
  memw();
  if (hoppe_en == 1) {
    memw();
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
    memw();
    memw();
    _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
    memw();
    memw();
    _DAT_60032110 = &DAT_3ffc9000;
    BT_tx_8m_enable(0x3f);
  }
  else {
    set_chan_freq_sw_start('\0',(sint16)chan,in_a12);
    memw();
    _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
    memw();
    memw();
    _DAT_60032110 = &DAT_3ffc9000;
    if (hoppe_en == 0) {
      uVar2 = 0x3b;
    }
    else {
      uVar2 = 0x3f;
    }
    BT_tx_8m_enable(uVar2);
  }
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0xfff & 0xfffffff;
  memw();
  memw();
  _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
  memw();
  memw();
  _DAT_600320f4 = _DAT_600320f4 & 0xffffffc0 | 0x1e;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 3;
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x403;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 0x403;
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 1;
  memw();
  do {
    memw();
    if ((_DAT_60032104 & 0x400) != 0) {
      memw();
      _DAT_60032108 = _DAT_60032108 | 0x400;
      memw();
      memw();
      if ((_DAT_600320cc & 0x20000000) == 0) {
        memw();
        _DAT_600320cc = _DAT_600320cc | 0x20000000;
        memw();
      }
      else {
        memw();
        _DAT_600320cc = _DAT_600320cc & 0xdfffffff;
        memw();
      }
      memw();
      _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 1;
      memw();
    }
    do {
      memw();
    } while ((_DAT_60032104 & 2) == 0);
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_60032108 = _DAT_60032108 | 3;
    memw();
    memw();
    uVar2 = _DAT_3ff51038 | 2;
    if ((_DAT_3ff51030 & 1) != 0) {
      memw();
      memw();
      uVar2 = _DAT_3ff51038 | 3;
    }
    _DAT_3ff51038 = uVar2;
    memw();
    if ((_DAT_60032120 & 0xff) != 0x43) {
      memw();
      if ((_DAT_60032120 & 0xff) == 0) {
        memw();
        if ((_DAT_3ffc9010 >> 3 & 0xf) == 2) goto LAB_00025c9b;
LAB_00025cc1:
        phy_printf("GET NO FHS!%x\n");
      }
      else {
        memw();
        if ((_DAT_60032120 & 0xff) == 0x41) {
          memw();
          if ((_DAT_3ffc9010 >> 3 & 0xf) != 2) goto LAB_00025cc1;
          phy_printf(&DAT_00054508,0x41);
LAB_00025c9b:
          phy_printf("GET FHS!\n");
          memw();
          phy_printf("LAP: 0x%x\n",(_DAT_3ffc9014 & 0x3fffffc) >> 2);
        }
      }
    }
    SVar1 = GetStopCmd();
    if (SVar1 == OK) {
      memw();
      _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0;
      memw();
      do {
        memw();
      } while ((_DAT_60032104 & 0x400) == 0);
      memw();
      _DAT_60032108 = _DAT_60032108 | 0x400;
      memw();
      phy_printf(&DAT_00054568);
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_inquiry_scan_test(u32 hoppe_en,u32 chan)

{
  STATUS SVar1;
  int iVar2;
  uint uVar3;
  uint8 in_a12;
  
  BT_init_packet_struct();
  memw();
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffff0000 | 0x9696;
  memw();
  if (hoppe_en == 1) {
    memw();
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
    memw();
    memw();
    _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
    memw();
    memw();
    _DAT_60032110 = &DAT_3ffc9000;
    BT_tx_8m_enable(0x3f);
  }
  else {
    set_chan_freq_sw_start('\0',(sint16)chan,in_a12);
    memw();
    _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
    memw();
    memw();
    _DAT_60032110 = &DAT_3ffc9000;
    if (hoppe_en == 0) {
      uVar3 = 0x3b;
    }
    else {
      uVar3 = 0x3f;
    }
    BT_tx_8m_enable(uVar3);
  }
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  memw();
  memw();
  memw();
  _DAT_3ff51038 = _DAT_3ff51038 | 3;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0xffff & 0xfffffff;
  memw();
  memw();
  _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 0x41f;
  memw();
  memw();
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 2;
  memw();
  uVar3 = _DAT_60032108 | 0x41f;
  do {
    _DAT_60032108 = uVar3;
    memw();
    if ((_DAT_60032104 & 0x400) != 0) {
      memw();
      _DAT_60032108 = _DAT_60032108 | 0x400;
      memw();
      memw();
      _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 2;
      memw();
    }
    memw();
    iVar2 = _DAT_60033c00;
    while (memw(), (_DAT_60032104 & 2) == 0) {
      memw();
      if ((_DAT_60032104 & 0x400) != 0) {
        memw();
        _DAT_60032108 = _DAT_60032108 | 0x400;
        memw();
        memw();
        _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 2;
        memw();
      }
      memw();
      if ((4999 < (uint)(_DAT_60033c00 - iVar2)) && (memw(), (_DAT_3ff51030 & 1) == 0)) {
        memw();
        memw();
        memw();
        _DAT_3ff5c02c = _DAT_3ff5c02c & 0x7fffff | 0x41000000;
        memw();
        memw();
        iVar2 = _DAT_60033c00;
      }
      SVar1 = GetStopCmd();
      if (SVar1 == OK) {
        memw();
        _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0;
        memw();
        do {
          memw();
        } while ((_DAT_60032104 & 0x400) == 0);
        memw();
        _DAT_60032108 = _DAT_60032108 | 0x400;
        memw();
        phy_printf(&DAT_00054568);
        memw();
        memw();
        memw();
        memw();
        _DAT_60032108 = _DAT_60032108 | 3;
        memw();
        memw();
        memw();
        memw();
        _DAT_3ff51038 = _DAT_3ff51038 | 3;
        return;
      }
    }
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_3ff51038 = _DAT_3ff51038 | 3;
    memw();
    memw();
    uVar3 = _DAT_60032108 | 3;
    if ((_DAT_60032104 & 0x10) != 0) {
      memw();
      _DAT_60032108 = _DAT_60032108 | 0x13;
      memw();
      ets_delay_us(100);
      uVar3 = _DAT_60032108;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_page_test(u32 link_type,u32 hoppe_en,u32 loopback)

{
  packet_struct packet;
  int iVar1;
  u32 uVar2;
  STATUS SVar3;
  uint hoppe_n500k;
  uint8 in_a12;
  undefined in_stack_ffffffd4 [16];
  
  BT_init_packet_struct();
  memw();
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffff0000 | 0x9696;
  memw();
  if (hoppe_en == 1) {
    memw();
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
    memw();
    BT_tx_8m_enable(0x3f);
    memw();
    memw();
    memw();
  }
  else {
    set_chan_freq_sw_start('\0',0x4a,in_a12);
    if (hoppe_en == 0) {
      hoppe_n500k = 0x3b;
    }
    else {
      hoppe_n500k = 0x3f;
    }
    BT_tx_8m_enable(hoppe_n500k);
    memw();
    memw();
    memw();
  }
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  _DAT_60032110 = &DAT_3ffc9000;
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  memw();
  _DAT_600320fc = _DAT_600320fc | 2;
  memw();
  memw();
  _DAT_600320f4 = _DAT_600320f4 & 0xffffffc0 | 0x14;
  memw();
  memw();
  memw();
  memw();
  _DAT_600320f0 = _DAT_600320f0 & 0xfe00fe00 | 0xf000f0;
  memw();
  memw();
  memw();
  _DAT_60032098 = 0x3fff7890;
  memw();
  _DAT_6003209c = _DAT_6003209c & 0xffff0000;
  memw();
  memw();
  memw();
  _DAT_60032090 = 0x11122233;
  memw();
  _DAT_60032094 = _DAT_60032094 & 0xffff0000;
  memw();
  memw();
  memw();
  _DAT_600320a0 = 0x11122233;
  memw();
  iVar1 = 0xb;
  _DAT_600320a4 = _DAT_600320a4 & 0xffff0000;
  memw();
  do {
    uVar2 = BT_m_page(hoppe_en,0xffffeeee,0);
    iVar1 = iVar1 + -1;
    if (uVar2 == 0) {
      phy_printf("page success!\n");
      do {
        packet.link_type = in_stack_ffffffd4._0_4_;
        packet.payload_header_length = in_stack_ffffffd4._4_4_;
        packet.payload_length = in_stack_ffffffd4._8_4_;
        packet.payload1_header_length = in_stack_ffffffd4._12_4_;
        packet.type_code = loopback;
        BT_mac_loopback_master(packet,packet_DH3.type_code);
        SVar3 = GetStopCmd();
      } while (SVar3 != OK);
      memw();
      memw();
      _DAT_600320c8 = _DAT_600320c8 & 0xfffffeff;
      return;
    }
    memw();
    memw();
    phy_printf("page failed!   state=0x%x, rx_end_state=0x%x       ",_DAT_600320c4 & 0xf,
               _DAT_60032120 & 0xff);
  } while (iVar1 != 0);
  memw();
  phy_printf("page failed!    state=0x%x\n",_DAT_600320c4 & 0xf);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_page_scan_test(u32 link_type,u32 hoppe_en,u32 loopback)

{
  int iVar1;
  u32 uVar2;
  STATUS SVar3;
  uint hoppe_n500k;
  uint8 in_a12;
  
  memw();
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffff0000 | 0x9696;
  memw();
  if (hoppe_en == 1) {
    memw();
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
    memw();
    BT_tx_8m_enable(0x3f);
    memw();
    memw();
    memw();
  }
  else {
    set_chan_freq_sw_start('\0',0x4a,in_a12);
    if (hoppe_en == 0) {
      hoppe_n500k = 0x3b;
    }
    else {
      hoppe_n500k = 0x3f;
    }
    BT_tx_8m_enable(hoppe_n500k);
    memw();
    memw();
    memw();
  }
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  _DAT_60032110 = &DAT_3ffc9000;
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  memw();
  _DAT_600320fc = _DAT_600320fc | 2;
  memw();
  memw();
  _DAT_600320f4 = _DAT_600320f4 & 0xffffffc0 | 0x14;
  memw();
  memw();
  memw();
  memw();
  _DAT_600320f0 = _DAT_600320f0 & 0xfe00fe00 | 0xf000f0;
  memw();
  memw();
  memw();
  _DAT_60032098 = 0x11122233;
  memw();
  _DAT_6003209c = _DAT_6003209c & 0xffff0000;
  memw();
  memw();
  memw();
  _DAT_600320a0 = 0x3fff7890;
  memw();
  iVar1 = 0xb;
  _DAT_600320a4 = _DAT_600320a4 & 0xffff0000;
  memw();
  do {
    uVar2 = BT_s_page(hoppe_en,0xffffeeee,1,0);
    iVar1 = iVar1 + -1;
    if (uVar2 == 0) {
      phy_printf("page scan success!\n");
      do {
        BT_mac_loopback_slave(loopback,link_type,1);
        SVar3 = GetStopCmd();
      } while (SVar3 != OK);
      memw();
      _DAT_600320c8 = _DAT_600320c8 & 0xffffffef;
      memw();
      phy_printf("connection end!\n");
      return;
    }
    memw();
    memw();
    phy_printf("page scan failed!   state=0x%x, rx_end_state=0x%x       ",_DAT_600320c4 & 0xf,
               _DAT_60032120 & 0xff);
  } while (iVar1 != 0);
  memw();
  phy_printf("page scan failed!   state=0x%x\n",_DAT_600320c4 & 0xf);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BT_mac_tx_packet(packet_struct packet,u32 data_type)

{
  int iVar1;
  uint in_a3;
  uint uVar2;
  int in_a4;
  u32 in_a5;
  int in_a6;
  u32 in_a7;
  
  BT_test_mode_fill_tx_payload(in_a4 + 2,in_a5,in_a7,0,0);
  BT_mac_set_tx_bytelength(0x3ffc8000,in_a4,in_a6,in_a5,0);
  memw();
  _DAT_600320bc = (data_type & 0xf) << 3 | _DAT_600320bc & 0xffffff87;
  memw();
  memw();
  uVar2 = (in_a3 & 7) << 0x1c;
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar2;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar2;
  memw();
  iVar1 = BT_tx_sim(0,0);
  if (iVar1 == 0) {
    phy_printf("tx success!\n");
    return;
  }
  phy_printf("tx fail!\n");
  return;
}



// WARNING: Variable defined which should be unmapped: pac_b
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_con_tx_test(u32 chan_a,u32 chan_b,u32 pa_type,u32 pb_type,u32 pa_data,u32 pb_data)

{
  packet_struct packet;
  packet_struct packet_00;
  uint uVar1;
  STATUS SVar2;
  packet_struct pac_b;
  packet_struct pac_a;
  
  prbs9_gen(PRBS9);
  memw();
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
  memw();
  memw();
  _DAT_600321bc = _DAT_600321bc | 0x1000000;
  memw();
  memw();
  uVar1 = (chan_a & 0x7f) << 0x10;
  _DAT_60032134 = _DAT_60032134 & 0xff80ffff | uVar1;
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  BT_mac_iqview_debug(1);
  BT_init_packet_struct();
  memw();
  _DAT_60032000 = _DAT_60032000 | 0x80000000;
  memw();
  memw();
  _DAT_60032024 = _DAT_60032024 | 0x80000000;
  memw();
  memw();
  _DAT_6003207c = _DAT_6003207c | 0x80000000;
  memw();
  memw();
  memw();
  memw();
  _DAT_600320f0 = _DAT_600320f0 & 0xfe00fe00 | 0xaa00aa;
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 | 0x100;
  memw();
  if (pa_type == 1) {
    memcpy(&pac_a,&packet_DH1,0x14);
  }
  else if (pa_type == 2) {
    memcpy(&pac_a,&packet_DH3,0x14);
  }
  else if (pa_type == 3) {
    memcpy(&pac_a,&packet_DH5,0x14);
  }
  else if (pa_type == 4) {
    memcpy(&pac_a,&packet_2DH1,0x14);
  }
  else if (pa_type == 5) {
    memcpy(&pac_a,&packet_2DH3,0x14);
  }
  else if (pa_type == 6) {
    memcpy(&pac_a,&packet_2DH5,0x14);
  }
  else if (pa_type == 7) {
    memcpy(&pac_a,&packet_3DH1,0x14);
  }
  else if (pa_type == 8) {
    memcpy(&pac_a,&packet_3DH3,0x14);
  }
  else {
    memcpy(&pac_a,&packet_3DH5,0x14);
  }
  if (pb_type == 1) {
    memcpy(&pac_b,&packet_DH1,0x14);
  }
  else if (pb_type == 2) {
    memcpy(&pac_b,&packet_DH3,0x14);
  }
  else if (pb_type == 3) {
    memcpy(&pac_b,&packet_DH5,0x14);
  }
  else if (pb_type == 4) {
    memcpy(&pac_b,&packet_2DH1,0x14);
  }
  else if (pb_type == 5) {
    memcpy(&pac_b,&packet_2DH3,0x14);
  }
  else if (pb_type == 6) {
    memcpy(&pac_b,&packet_2DH5,0x14);
  }
  else if (pb_type == 7) {
    memcpy(&pac_b,&packet_3DH1,0x14);
  }
  else if (pb_type == 8) {
    memcpy(&pac_b,&packet_3DH3,0x14);
  }
  else {
    memcpy(&pac_b,&packet_3DH5,0x14);
  }
  do {
    packet.link_type = pac_b.link_type;
    packet.payload_header_length = pac_b.payload_header_length;
    packet.payload_length = pac_b.payload_length;
    packet.payload1_header_length = pac_b.payload1_header_length;
    packet.type_code = pac_b.type_code;
    BT_mac_tx_packet(packet,pac_a.type_code);
    memw();
    _DAT_60032134 = _DAT_60032134 & 0xff80ffff | (chan_b & 0x7f) << 0x10;
    memw();
    packet_00.link_type = pac_b.link_type;
    packet_00.payload_header_length = pac_b.payload_header_length;
    packet_00.payload_length = pac_b.payload_length;
    packet_00.payload1_header_length = pac_b.payload1_header_length;
    packet_00.type_code = pac_b.type_code;
    BT_mac_tx_packet(packet_00,pac_b.type_code);
    memw();
    _DAT_60032134 = _DAT_60032134 & 0xff80ffff | uVar1;
    memw();
    SVar2 = GetStopCmd();
  } while (SVar2 != OK);
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffeff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_mac_rx_start_debug(u32 link_type,u32 chan)

{
  uint uVar1;
  uint8 in_a12;
  
  set_chan_freq_sw_start('\0',(short)chan + 2,in_a12);
  memw();
  uVar1 = (link_type & 7) << 0x1c;
  memw();
  memw();
  _DAT_3ff5c02c = _DAT_3ff5c02c & 0x7fffff | 0x41000000;
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  BT_tx_8m_enable(0x3b);
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  BT_mac_iqview_debug(1);
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar1;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar1;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 2;
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  memw();
  _DAT_600321bc = _DAT_600321bc | 0x80000000;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_gen_prbs9(void)

{
  prbs9_gen(PRBS9);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void freq_offset_cfg(u32 tx_offset_bb,u32 rx_offset_bb,u32 tx_offset_hoppe,u32 rx_offset_hoppe,
                    u32 cmpx_on,u32 cmpx_offset,u32 bt_mode_force_en,u32 bt_mode_force,
                    u32 bt_rx_force_on)

{
  memw();
  memw();
  memw();
  _DAT_3ff4e0c4 =
       (rx_offset_hoppe & 0xf) << 0x14 |
       (tx_offset_hoppe & 0xf) << 0x10 | _DAT_3ff4e0c4 & 0xff00ffff;
  memw();
  BT_tx_8m_enable(tx_offset_bb);
  BT_init_rx_filters((uint16)rx_offset_bb);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_rx_ber(u32 bits,u32 link_type,u32 chan,u32 time_out,u32 be_thresh)

{
  sint16 sVar1;
  uint uVar2;
  uint uVar3;
  u32 get_err_bits;
  u32 get_total_bits;
  u32 uStack_c0;
  uint uStack_bc;
  uint uStack_b8;
  u32 uStack_b4;
  u32 uStack_b0;
  u32 uStack_ac;
  u32 uStack_a8;
  u32 uStack_a4;
  u32 uStack_a0;
  u32 uStack_9c;
  u32 uStack_98;
  u32 uStack_94;
  u32 uStack_90;
  u32 uStack_8c;
  uint uStack_88;
  u32 uStack_84;
  u32 uStack_80;
  u32 uStack_7c;
  u32 uStack_78;
  u32 uStack_74;
  u32 uStack_70;
  u32 *puStack_6c;
  u32 uStack_68;
  u32 uStack_64;
  u32 uStack_60;
  u32 uStack_5c;
  u32 uStack_58;
  u32 uStack_54;
  u32 uStack_50;
  u32 uStack_4c;
  u32 uStack_48;
  u32 uStack_44;
  u32 uStack_40;
  u32 uStack_3c;
  u32 uStack_38;
  int iStack_34;
  uint uStack_30;
  uint uStack_2c;
  
  memw();
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
  memw();
  memw();
  _DAT_600321bc = _DAT_600321bc | 0x1000000;
  memw();
  memw();
  _DAT_60032134 = (chan & 0x7f) << 0x10 | _DAT_60032134 & 0xff80ffff;
  memw();
  uStack_b4 = bits;
  uStack_70 = be_thresh;
  sVar1 = (*g_phyFuns->check_noise_floor_)();
  iStack_34 = (int)sVar1;
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  BT_mac_iqview_debug(1);
  memw();
  uVar2 = (link_type & 7) << 0x1c;
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar2;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar2;
  memw();
  prbs9_gen(PRBS9);
  memw();
  _DAT_600320fc = _DAT_600320fc | 2;
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  memw();
  get_total_bits = 0;
  get_err_bits = 0;
  uVar2 = time_out * 1000000 + _DAT_60033c00;
  if (uStack_b4 == 0) {
    uStack_c0 = uStack_b4;
    uStack_88 = uStack_b4;
    uStack_b0 = uStack_b4;
    uStack_78 = uStack_b4;
    uStack_b8 = uStack_b4;
    uStack_74 = uStack_b4;
    uStack_8c = uStack_b4;
    uStack_90 = uStack_b4;
    uStack_94 = uStack_b4;
    uStack_98 = uStack_b4;
    uStack_9c = uStack_b4;
    uStack_a0 = uStack_b4;
    uStack_a4 = uStack_b4;
    uStack_a8 = uStack_b4;
    uStack_38 = uStack_b4;
    uStack_3c = uStack_b4;
    uStack_40 = uStack_b4;
    uStack_44 = uStack_b4;
    uStack_48 = uStack_b4;
    uStack_4c = uStack_b4;
    uStack_50 = uStack_b4;
    uStack_54 = uStack_b4;
    uStack_58 = uStack_b4;
    uStack_5c = uStack_b4;
    uStack_60 = uStack_b4;
    uStack_64 = uStack_b4;
    uStack_68 = uStack_b4;
    uStack_ac = uStack_b4;
    uStack_7c = uStack_b4;
    uStack_80 = uStack_b4;
    uStack_84 = uStack_b4;
  }
  else {
    uStack_c0 = 0;
    uStack_88 = 0;
    uStack_b0 = 0;
    uStack_78 = 0;
    uStack_b8 = 0;
    uStack_bc = 0;
    uStack_74 = 0;
    uStack_8c = 0;
    uStack_90 = 0;
    uStack_94 = 0;
    uStack_98 = 0;
    uStack_9c = 0;
    uStack_a0 = 0;
    uStack_a4 = 0;
    uStack_a8 = 0;
    uStack_38 = 0;
    uStack_3c = 0;
    uStack_40 = 0;
    uStack_44 = 0;
    uStack_48 = 0;
    uStack_4c = 0;
    uStack_50 = 0;
    uStack_54 = 0;
    uStack_58 = 0;
    uStack_5c = 0;
    uStack_60 = 0;
    uStack_64 = 0;
    uStack_68 = 0;
    uStack_ac = 0;
    uStack_7c = 0;
    puStack_6c = &get_total_bits;
    uStack_80 = 0;
    uStack_84 = 0;
    while( true ) {
      ets_delay_us(0x14);
      memw();
      uStack_bc = uStack_bc + 1;
      _DAT_600321bc = _DAT_600321bc | 0x80000000;
      memw();
      while (memw(), (_DAT_60032100 & 2) == 0) {
        memw();
        if (uVar2 < _DAT_60033c00) {
          memw();
          _DAT_600321bc = _DAT_600321bc & 0x7fffffff;
          memw();
        }
      }
      memw();
      _DAT_60032108 = _DAT_60032108 | 2;
      memw();
      memw();
      uVar3 = _DAT_60032120 & 0xff;
      if ((1 < uVar3 - 0x38) && (uVar3 != 0x43)) {
        switch(uVar3) {
        case 0:
          uStack_64 = uStack_64 + 1;
          break;
        case 1:
          uStack_38 = uStack_38 + 1;
          break;
        default:
          uStack_48 = uStack_48 + 1;
          break;
        case 4:
          uStack_40 = uStack_40 + 1;
          break;
        case 8:
          uStack_3c = uStack_3c + 1;
          break;
        case 0x40:
          uStack_68 = uStack_68 + 1;
          break;
        case 0x41:
          memw();
          uStack_60 = uStack_60 + 1;
          uStack_c0 = _DAT_3ff51078 >> 0x10 & 0xff;
          break;
        case 0x42:
          uStack_58 = uStack_58 + 1;
          break;
        case 0x44:
          uStack_54 = uStack_54 + 1;
          break;
        case 0x45:
          uStack_50 = uStack_50 + 1;
          break;
        case 0x46:
          uStack_4c = uStack_4c + 1;
          break;
        case 0x47:
          uStack_5c = uStack_5c + 1;
          break;
        case 0x53:
          uStack_44 = uStack_44 + 1;
        }
        memw();
        uStack_2c = _DAT_3ff51050 & 0x40;
        uStack_30 = (uint)((_DAT_3ff51050 & 0x80) != 0);
        uStack_ac = uStack_ac + 1;
        uStack_a8 = uStack_a8 + uStack_30;
        uStack_a4 = uStack_a4 + (uStack_2c != 0);
        uStack_a0 = uStack_a0 + ((_DAT_3ff51050 & 0x20) != 0);
        uStack_94 = uStack_94 + ((_DAT_3ff51050 & 0x10) != 0);
        uStack_9c = uStack_9c + ((_DAT_3ff51050 & 8) != 0);
        uStack_90 = uStack_90 + ((_DAT_3ff51050 & 4) != 0);
        uStack_98 = uStack_98 + ((_DAT_3ff51050 & 2) != 0);
        uStack_8c = uStack_8c + (_DAT_3ff51050 & 1);
      }
      if ((uVar3 == 0) || (uVar3 == 0x41 || uVar3 == 0)) {
        BT_rx_prbs9_status(puStack_6c,&get_err_bits);
        uStack_78 = uStack_78 + get_err_bits;
        uStack_b8 = uStack_b8 + get_total_bits;
        if (uStack_70 < get_err_bits) {
          uStack_74 = uStack_74 + 1;
        }
        memw();
        memw();
        memw();
        memw();
        memw();
        uStack_b0 = uStack_b0 + ((_DAT_3ff51078 >> 0x10 & 0xff) - (_DAT_3ff51074 & 0xff)) + 0x100;
        uStack_88 = uStack_88 + 1;
        uStack_84 = uStack_84 + (0x100 - (_DAT_3ff51074 & 0xff));
        uStack_80 = uStack_80 + (0x100 - (_DAT_3ff51078 >> 0x18));
        uStack_7c = uStack_7c + (_DAT_3ff51078 >> 0x10 & 0xff);
      }
      if ((500 < uStack_bc) && (uStack_b8 == 0)) break;
      memw();
      if ((uVar2 < _DAT_60033c00) || (uStack_b4 <= uStack_b8)) goto LAB_000271a9;
    }
    uStack_b8 = 0;
LAB_000271a9:
    if (uStack_b0 != 0) {
      uStack_b0 = ((uStack_88 >> 1) + uStack_b0) / uStack_88;
    }
  }
  phy_printf("%x %x p %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x w %x %x %x %x %x %x %x %x %x %x %x %x %x %x\n"
             ,uStack_b8,uStack_78,uStack_b0,iStack_34,uStack_84,uStack_80,uStack_7c,uStack_88,
             uStack_ac,uStack_64,uStack_68,uStack_60,uStack_5c,uStack_58,uStack_54,uStack_50,
             uStack_4c,uStack_44,uStack_40,uStack_3c,uStack_38,uStack_48,uStack_a8,uStack_a4,
             uStack_98,uStack_9c,uStack_a0,uStack_8c,uStack_90,uStack_94,uStack_c0,0,0,0,0,uStack_74
            );
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_rx_per(u32 link_type,u32 chan)

{
  bool bVar1;
  bool bVar2;
  sint16 sVar3;
  uint uVar4;
  STATUS SVar5;
  uint uStack_b0;
  int iStack_a4;
  int iStack_a0;
  int iStack_9c;
  int iStack_98;
  int iStack_94;
  int iStack_90;
  int iStack_8c;
  int iStack_88;
  int iStack_84;
  int iStack_80;
  int iStack_7c;
  int iStack_78;
  uint uStack_6c;
  int iStack_68;
  int iStack_64;
  int iStack_60;
  int iStack_5c;
  int iStack_58;
  int iStack_54;
  int iStack_50;
  int iStack_4c;
  int iStack_48;
  int iStack_44;
  int iStack_40;
  int iStack_3c;
  int iStack_38;
  
  memw();
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
  memw();
  memw();
  _DAT_600321bc = _DAT_600321bc | 0x1000000;
  uVar4 = (link_type & 7) << 0x1c;
  memw();
  memw();
  _DAT_60032134 = (chan & 0x7f) << 0x10 | _DAT_60032134 & 0xff80ffff;
  memw();
  sVar3 = (*g_phyFuns->check_noise_floor_)();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  BT_mac_iqview_debug(1);
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar4;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar4;
  memw();
  phy_printf("Bt rx per\n");
  memw();
  _DAT_600320fc = _DAT_600320fc | 2;
  memw();
  memw();
  uStack_b0 = 0;
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  SVar5 = OK;
  uStack_6c = 0;
  iStack_78 = 0;
  iStack_7c = 0;
  iStack_80 = 0;
  iStack_84 = 0;
  iStack_88 = 0;
  iStack_8c = 0;
  iStack_90 = 0;
  iStack_94 = 0;
  iStack_38 = 0;
  iStack_3c = 0;
  iStack_40 = 0;
  iStack_44 = 0;
  iStack_48 = 0;
  iStack_4c = 0;
  iStack_50 = 0;
  iStack_54 = 0;
  iStack_58 = 0;
  iStack_5c = 0;
  iStack_64 = 0;
  iStack_68 = 0;
  iStack_60 = 0;
  iStack_98 = 0;
  iStack_9c = 0;
  iStack_a0 = 0;
  iStack_a4 = 0;
  do {
    ets_delay_us(0x14);
    memw();
    _DAT_600321bc = _DAT_600321bc | 0x80000000;
    memw();
    do {
      memw();
      if ((_DAT_60032100 & 2) != 0) {
        bVar2 = false;
        bVar1 = false;
        goto LAB_00027489;
      }
      SVar5 = GetStopCmd();
      bVar2 = SVar5 == BUSY || SVar5 == OK;
    } while (SVar5 != BUSY && SVar5 != OK);
    memw();
    bVar1 = true;
    _DAT_600321bc = _DAT_600321bc & 0x7fffffff;
    memw();
LAB_00027489:
    memw();
    _DAT_60032108 = _DAT_60032108 | 2;
    memw();
    memw();
    uVar4 = _DAT_60032120 & 0xff;
    if ((1 < uVar4 - 0x38) && (uVar4 != 0x43)) {
      switch(uVar4) {
      case 0:
        memw();
        memw();
        uStack_6c = uStack_6c + ((_DAT_3ff51078 >> 0x10 & 0xff) - (_DAT_3ff51074 & 0xff)) + 0x100;
        iStack_68 = iStack_68 + 1;
        break;
      case 1:
        iStack_38 = iStack_38 + 1;
        break;
      default:
        iStack_48 = iStack_48 + 1;
        break;
      case 4:
        iStack_40 = iStack_40 + 1;
        break;
      case 8:
        iStack_3c = iStack_3c + 1;
        break;
      case 0x40:
        iStack_60 = iStack_60 + 1;
        break;
      case 0x41:
        memw();
        memw();
        memw();
        uStack_6c = uStack_6c + ((_DAT_3ff51078 >> 0x10 & 0xff) - (_DAT_3ff51074 & 0xff)) + 0x100;
        iStack_64 = iStack_64 + 1;
        uStack_b0 = _DAT_3ff51078 >> 0x10 & 0xff;
        break;
      case 0x42:
        iStack_58 = iStack_58 + 1;
        break;
      case 0x44:
        iStack_54 = iStack_54 + 1;
        break;
      case 0x45:
        iStack_50 = iStack_50 + 1;
        break;
      case 0x46:
        iStack_4c = iStack_4c + 1;
        break;
      case 0x47:
        iStack_5c = iStack_5c + 1;
        break;
      case 0x53:
        iStack_44 = iStack_44 + 1;
      }
      memw();
      memw();
      memw();
      memw();
      iStack_98 = iStack_98 + 1;
      iStack_94 = iStack_94 + (uint)((_DAT_3ff51050 & 0x80) != 0);
      iStack_90 = iStack_90 + (uint)((_DAT_3ff51050 & 0x40) != 0);
      iStack_8c = iStack_8c + (uint)((_DAT_3ff51050 & 0x20) != 0);
      iStack_80 = iStack_80 + (uint)((_DAT_3ff51050 & 0x10) != 0);
      iStack_88 = iStack_88 + (uint)((_DAT_3ff51050 & 8) != 0);
      iStack_7c = iStack_7c + (uint)((_DAT_3ff51050 & 4) != 0);
      iStack_78 = iStack_78 + (_DAT_3ff51050 & 1);
      iStack_a4 = iStack_a4 + (0x100 - (_DAT_3ff51074 & 0xff));
      iStack_84 = iStack_84 + (uint)((_DAT_3ff51050 & 2) != 0);
      iStack_a0 = iStack_a0 + (0x100 - (_DAT_3ff51078 >> 0x18));
      iStack_9c = iStack_9c + (_DAT_3ff51078 >> 0x10 & 0xff);
    }
    if (!bVar1) {
      SVar5 = GetStopCmd();
    }
    if ((SVar5 == BUSY || SVar5 == OK) || (bVar2)) {
      if (uStack_6c != 0) {
        uStack_6c = (((uint)(iStack_68 + iStack_64) >> 1) + uStack_6c) /
                    (uint)(iStack_68 + iStack_64);
      }
      phy_printf("%x %x %x %x %x %x %x %x %x %x %x %x %x %x w %x %x %x %x %x %x %x %x p %x %x %x %x %x %x %x %x %x %x\n"
                 ,iStack_98,iStack_68,iStack_60,iStack_64,iStack_5c,iStack_58,iStack_54,iStack_50,
                 iStack_4c,iStack_44,iStack_40,iStack_3c,iStack_38,iStack_48,iStack_94,iStack_90,
                 iStack_84,iStack_88,iStack_8c,iStack_78,iStack_7c,iStack_80,uStack_6c,(int)sVar3,
                 iStack_a4,iStack_a0,iStack_9c,uStack_b0,0,0,0,0);
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_rx_dump(u32 link_type,u32 chan)

{
  uint uVar1;
  uint8 in_a12;
  int32 in_a14;
  int32 in_a15;
  int32 in_stack_ffffffe0;
  int32 in_stack_ffffffe4;
  int32 in_stack_ffffffe8;
  
  set_chan_freq_sw_start('\0',(sint16)chan,in_a12);
  ets_delay_us(5000);
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  BT_mac_iqview_debug(1);
  memw();
  uVar1 = (link_type & 7) << 0x1c;
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar1;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar1;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 2;
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  ets_delay_us(0x14);
  memw();
  _DAT_600321bc = _DAT_600321bc | 0x80000000;
  memw();
  adctrig(0x1fff,0,0,0,in_a14,in_a15,in_stack_ffffffe0,in_stack_ffffffe4,in_stack_ffffffe8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_get_inq_info(void)

{
  memw();
  memw();
  if (((_DAT_60032104 & 2) != 0) && ((_DAT_60032120 & 0xff) == 0)) {
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_60032108 = _DAT_60032108 | 2;
    memw();
    phy_printf("S %d %d %d %d %d %d\n",
               (_DAT_3ffc9018 >> 0x10 & 0xff) << 8 | _DAT_3ffc9018 >> 8 & 0xff,_DAT_3ffc9018 & 0xff,
               (_DAT_3ffc9014 & 0x3fffffc) >> 2,_DAT_3ffc901c >> 0x10 & 7,
               (_DAT_3ffc9020 & 0x1fff) << 0xd | _DAT_3ffc901c >> 0x13,_DAT_3ffc9004);
    return;
  }
  phy_printf(&DAT_00054750);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_inq(u32 hoppe_en)

{
  bool bVar1;
  STATUS SVar2;
  undefined4 in_a7;
  uint8 in_a12;
  uint uStack_40;
  uint uStack_3c;
  uint uStack_38;
  uint uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  uint uStack_28;
  undefined4 uStack_24;
  
  memw();
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffff0000 | 0x9696;
  memw();
  if (hoppe_en == 1) {
    memw();
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
    memw();
    memw();
    _DAT_60032110 = &DAT_3ffc9000;
    BT_tx_8m_enable(0x3f);
  }
  else {
    set_chan_freq_sw_start('\0',0x4a,in_a12);
    memw();
    _DAT_60032110 = &DAT_3ffc9000;
    if (hoppe_en == 0) {
      BT_tx_8m_enable(0x3b);
      BT_tx_if_init(0x14a,1000,200,1);
      BT_init_rx_filters(0x3b);
      memw();
      _DAT_600321bc = _DAT_600321bc | 0x10000000;
      memw();
      memw();
      _DAT_600321b8 = _DAT_600321b8 & 0xf0000000 | 0xffffccc;
      memw();
      goto LAB_00027b15;
    }
    BT_tx_8m_enable(0x3f);
  }
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
LAB_00027b15:
  memw();
  _DAT_600320f4 = _DAT_600320f4 & 0xffffffc0 | 0x1e;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff5c02c = _DAT_3ff5c02c & 0x7fffff | 0x41000000;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 0x402;
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x402;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0xfff & 0xfffffff;
  memw();
  memw();
  _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 1;
  memw();
  bVar1 = false;
  while( true ) {
    memw();
    if ((_DAT_60032104 & 0x400) != 0) {
      memw();
      _DAT_60032108 = _DAT_60032108 | 0x400;
      memw();
      memw();
      if ((_DAT_600320cc & 0x20000000) == 0) {
        memw();
        _DAT_600320cc = _DAT_600320cc | 0x20000000;
        memw();
      }
      else {
        memw();
        _DAT_600320cc = _DAT_600320cc & 0xdfffffff;
        memw();
      }
      memw();
      _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 1;
      memw();
    }
    memw();
    memw();
    if ((_DAT_60032104 & 2) != 0) {
      if ((_DAT_60032120 & 0xff) == 0) {
        memw();
        memw();
        memw();
        memw();
        memw();
        memw();
        memw();
        memw();
        uStack_3c = (_DAT_3ffc9018 >> 0x10 & 0xff) << 8 | _DAT_3ffc9018 >> 8 & 0xff;
        uStack_2c = _DAT_3ffc9004;
        memw();
        uStack_38 = _DAT_3ffc9018 & 0xff;
        uStack_34 = (_DAT_3ffc9014 & 0x3fffffc) >> 2;
        uStack_40 = _DAT_3ffc901c >> 0x10 & 7;
        uStack_30 = (_DAT_3ffc9020 & 0x1fff) << 0xd | _DAT_3ffc901c >> 0x13;
        if ((_DAT_3ffc9014 >> 0x1a & 1) == 1) {
          memw();
          _DAT_60032108 = _DAT_60032108 | 2;
          memw();
          do {
            memw();
          } while ((_DAT_60032104 & 2) != 0);
          do {
            memw();
          } while ((_DAT_60032104 & 2) == 0);
          memw();
          uStack_28 = _DAT_60032120 & 0xff;
          memw();
          uStack_24 = _DAT_3ffc9010;
          bVar1 = true;
          in_a7 = 1;
        }
        else {
          bVar1 = true;
          in_a7 = 0;
        }
      }
      memw();
      _DAT_60032108 = _DAT_60032108 | 2;
      memw();
      do {
        memw();
      } while ((_DAT_60032104 & 2) != 0);
    }
    SVar2 = GetStopCmd();
    if (SVar2 == OK) break;
    if (SVar2 == BUSY) {
      if (bVar1) {
        phy_printf("S %x %x %x %x %x %x %x %x %x\n",uStack_3c,uStack_38,uStack_34,uStack_40,
                   uStack_30,uStack_2c,in_a7,uStack_28,uStack_24);
        bVar1 = false;
      }
      else {
        phy_printf(&DAT_00054750);
      }
    }
  }
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0;
  memw();
  phy_printf("inq stop!\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_inq_scan(u32 hoppe_en)

{
  STATUS SVar1;
  uint8 crystal_select;
  
  crystal_select = '\x11';
  BT_fill_eir_sample_pac(3,1,0x11,(u32)eir_payload);
  memw();
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffff0000 | 0x9696;
  memw();
  if (hoppe_en == 1) {
    memw();
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
    memw();
    memw();
    _DAT_60032110 = &DAT_3ffc9000;
    BT_tx_8m_enable(0x3f);
  }
  else {
    set_chan_freq_sw_start('\0',0x4a,crystal_select);
    memw();
    _DAT_60032110 = &DAT_3ffc9000;
    if (hoppe_en == 0) {
      BT_tx_8m_enable(0x3b);
      BT_tx_if_init(0x14a,1000,200,1);
      BT_init_rx_filters(0x3b);
      memw();
      memw();
      memw();
      memw();
      memw();
      _DAT_600321bc = _DAT_600321bc | 0x10000000;
      memw();
      memw();
      _DAT_600321b8 = _DAT_600321b8 & 0xf0000000 | 0xffffccc;
      memw();
      goto LAB_00027f60;
    }
    BT_tx_8m_enable(0x3f);
  }
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  memw();
  memw();
  memw();
  memw();
LAB_00027f60:
  memw();
  memw();
  memw();
  _DAT_3ff5c02c = _DAT_3ff5c02c & 0x7fffff | 0x41000000;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 0x41f;
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x41f;
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0xffff & 0xfffffff;
  memw();
  memw();
  _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 2;
  memw();
  do {
    memw();
    if ((_DAT_60032104 & 0x400) != 0) {
      memw();
      _DAT_60032108 = _DAT_60032108 | 0x400;
      memw();
      memw();
      _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 2;
      memw();
    }
    SVar1 = GetStopCmd();
  } while (SVar1 != OK);
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0;
  memw();
  phy_printf("inq scan stop!\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_page(u32 hoppe_en,u32 mulap,u32 mnap,u32 sulap,u32 snap,u32 clk_offset)

{
  u32 uVar1;
  undefined4 uVar2;
  STATUS SVar3;
  int iVar4;
  uint hoppe_n500k;
  uint8 in_a12;
  
  phy_printf("page start!\n");
  if (hoppe_en == 1) {
    memw();
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
    memw();
    BT_tx_8m_enable(0x3f);
  }
  else {
    set_chan_freq_sw_start('\0',0x4a,in_a12);
    if (hoppe_en == 0) {
      hoppe_n500k = 0x3b;
    }
    else {
      hoppe_n500k = 0x3f;
    }
    BT_tx_8m_enable(hoppe_n500k);
  }
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  memw();
  _DAT_600320e4 = _DAT_600320e4 & 0xf0000000 | clk_offset & 0xfffffff;
  memw();
  memw();
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffff0000 | 0x9696;
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  memw();
  _DAT_600320f4 = _DAT_600320f4 & 0xffffffc0 | 0x14;
  memw();
  memw();
  memw();
  memw();
  _DAT_600320f0 = _DAT_600320f0 & 0xfe00fe00 | 0xf000f0;
  memw();
  BT_m_set_nulap(mulap,mnap,sulap,snap);
  iVar4 = 0xb;
  do {
    uVar1 = BT_m_page(hoppe_en,0xffffeeee,0);
    iVar4 = iVar4 + -1;
    if (uVar1 == 0) {
      uVar2 = 0;
      goto LAB_0002825c;
    }
  } while (iVar4 != 0);
  uVar2 = 1;
LAB_0002825c:
  do {
    SVar3 = GetStopCmd();
    if (SVar3 == OK) break;
  } while (SVar3 != BUSY && SVar3 != OK);
  phy_printf(&DAT_000547a0,uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_page_scan(u32 hoppe_en,u32 slave_sel)

{
  u32 uVar1;
  undefined4 uVar2;
  STATUS SVar3;
  int iVar4;
  uint hoppe_n500k;
  uint8 in_a12;
  
  phy_printf("page scan start!\n");
  if (hoppe_en == 1) {
    memw();
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
    memw();
    BT_tx_8m_enable(0x3f);
  }
  else {
    set_chan_freq_sw_start('\0',0x4a,in_a12);
    if (hoppe_en == 0) {
      hoppe_n500k = 0x3b;
    }
    else {
      hoppe_n500k = 0x3f;
    }
    BT_tx_8m_enable(hoppe_n500k);
  }
  BT_tx_if_init(0x14a,1000,200,1);
  BT_init_rx_filters(0x3b);
  memw();
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffff0000 | 0x9696;
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  memw();
  _DAT_600320f4 = _DAT_600320f4 & 0xffffffc0 | 0x14;
  memw();
  memw();
  memw();
  memw();
  _DAT_600320f0 = _DAT_600320f0 & 0xfe00fe00 | 0xf000f0;
  memw();
  iVar4 = 0xb;
  do {
    uVar1 = BT_s_page(hoppe_en,0xffffeeee,slave_sel,0);
    iVar4 = iVar4 + -1;
    if (uVar1 == 0) {
      uVar2 = 0;
      goto LAB_00028411;
    }
  } while (iVar4 != 0);
  uVar2 = 1;
LAB_00028411:
  do {
    SVar3 = GetStopCmd();
    if (SVar3 == BUSY) break;
  } while (SVar3 != OK && SVar3 != BUSY);
  phy_printf(&DAT_000547a0,uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int BT_con_loopback_df(u32 device_sel)

{
  bool bVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  int iVar5;
  uint uVar6;
  
  memw();
  memw();
  memw();
  memw();
  if (_DAT_600320b8 != (_DAT_3ffc9000 & 0x7ff)) {
    phy_printf("1 %d %d\n");
    return 1;
  }
  bVar1 = false;
  uVar6 = 0;
  iVar5 = 0;
  if (_DAT_600320b8 != 0) {
    do {
      if (uVar6 != 1) {
        puVar4 = (uint *)((((int)uVar6 >> 2) + 0xfff2000) * 4);
        memw();
        memw();
        uVar3 = 0xff << 0x20 - ((uVar6 & 3) * -8 + 0x20);
        uVar2 = *puVar4 & uVar3;
        uVar3 = uVar3 & puVar4[0x404];
        if (uVar2 != uVar3) {
          iVar5 = iVar5 + ((uVar2 ^ uVar3) & 1);
          bVar1 = true;
        }
      }
      uVar6 = uVar6 + 1;
    } while (uVar6 != _DAT_600320b8);
    if (bVar1) {
      phy_printf("2 %d\n",iVar5);
      return 1;
    }
  }
  phy_printf(&DAT_000547c4);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_con_loopback_master(u32 loopback)

{
  int iVar1;
  
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffffff00 | 0x96;
  memw();
  memw();
  _DAT_600320f4 = _DAT_600320f4 & 0xffffffc0 | 0x14;
  memw();
  iVar1 = BT_tx_sim_rx_prepare(0,0);
  if (iVar1 != 0) {
    phy_printf(&DAT_000547d0);
    return;
  }
  if (loopback != 1) {
    phy_printf(&DAT_000547c4);
    return;
  }
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  memw();
  memw();
  do {
    memw();
  } while ((_DAT_60032100 & 2) == 0);
  memw();
  memw();
  memw();
  if ((_DAT_60032120 & 0xff) == 0) {
    _DAT_600320c0 = _DAT_600320c0 | 0x80000000;
    _DAT_60032108 = _DAT_60032108 | 2;
    BT_con_loopback_df(0);
    return;
  }
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  memw();
  _DAT_600320c0 = _DAT_600320c0 | 0x80000000;
  memw();
  do {
    memw();
  } while ((_DAT_60032100 & 2) == 0);
  memw();
  _DAT_60032108 = _DAT_60032108 | 2;
  memw();
  memw();
  phy_printf("4 %x %x\n",_DAT_60032120 & 0xff,_DAT_60032120 & 0xff);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_con_loopback_slave(u32 link_type,u32 loopback,u32 payload_length,u32 slave_sel)

{
  bool bVar1;
  uint uVar2;
  u32 lpayload;
  u32 uVar3;
  STATUS SVar4;
  undefined4 uVar5;
  int iVar6;
  u32 in_a13;
  u32 in_a14;
  
  memw();
  memw();
  memw();
  _DAT_600320b0 =
       _DAT_600320b0 & 0xffc00c00 | (payload_length & 0x3ff) << 0xc | payload_length & 0x3ff;
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffffff00 | 0x96;
  memw();
  memw();
  _DAT_600320f4 = _DAT_600320f4 & 0xffffffc0 | 0x14;
  memw();
  memw();
  uVar2 = (link_type & 7) << 0x1c;
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar2;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar2;
  memw();
  lpayload = BT_rx_sim_tx_prepare(slave_sel);
  uVar3 = 0x43;
  if (lpayload != 0) {
    iVar6 = 0x47;
    do {
      iVar6 = iVar6 + -1;
      bVar1 = uVar3 != 0x39;
      if ((lpayload != 0x43) && ((lpayload != 0x39 || (uVar3 = 0x39, bVar1 || lpayload != 0x39)))) {
        uVar3 = lpayload;
      }
      if (iVar6 == 0) {
        uVar5 = 1;
        goto LAB_000287b4;
      }
      lpayload = BT_rx_sim_tx_prepare(slave_sel);
    } while (lpayload != 0);
    lpayload = 0;
  }
  if (loopback == 1) {
    memw();
    _DAT_600320b8 = _DAT_3ffc9000 & 0x7ff;
    memw();
    memw();
    _DAT_600320b0 = (_DAT_3ffc9000 & 0x3ff) << 0xc | _DAT_600320b0 & 0xffc00fff;
    memw();
    BT_test_mode_fill_tx_payload_(lpayload,lpayload,1,in_a13,in_a14);
    iVar6 = BT_tx_sim(0,slave_sel);
    uVar5 = 2;
    if (iVar6 == 0) {
      uVar5 = 0;
    }
  }
  else {
    uVar5 = 0;
  }
LAB_000287b4:
  do {
    SVar4 = GetStopCmd();
  } while (SVar4 != BUSY);
  phy_printf("%d %x\n",uVar5,uVar3);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_con(u32 device_sel)

{
  if (device_sel == 0) {
    memw();
    _DAT_600320c8 = _DAT_600320c8 | 0x100;
    memw();
  }
  else if (device_sel == 1) {
    memw();
    memw();
    _DAT_600320c8 = _DAT_600320c8 | 0x10;
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_m_discon(void)

{
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffeff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_s_discon(u32 device_sel)

{
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xffffffef;
  if (device_sel == 1) {
    return;
  }
  return;
}



// WARNING: Unknown calling convention

u32 GetCmd_BT_testmode(void)

{
  int iVar1;
  u32 uVar2;
  
  iVar1 = UartGetCmdLn(pString);
  uVar2 = 0;
  if (iVar1 == 0) {
    iVar1 = cmd_parse(pString,command,&para_num,para_array);
    if (iVar1 == 0) {
      iVar1 = strcmp(command,"again");
      uVar2 = 1;
      if (iVar1 != 0) {
        iVar1 = strcmp(command,"exit");
        uVar2 = 2;
        if (iVar1 != 0) {
          iVar1 = strcmp(command,"ttype");
          if (iVar1 == 0) {
            phy_printf("change test type\n");
            return 3;
          }
          iVar1 = strcmp(command,"hmode");
          if (iVar1 == 0) {
            phy_printf("change hopping mode\n");
            return 4;
          }
          iVar1 = strcmp(command,"txdelay");
          if (iVar1 == 0) {
            phy_printf("change txdelay\n");
            return 5;
          }
          iVar1 = strcmp(command,"rxdelay");
          if (iVar1 != 0) {
            phy_printf("Unknown CMD!\n");
            return 0;
          }
          phy_printf("change rxdelay\n");
          return 6;
        }
      }
    }
    else {
      phy_printf("cmd syntax error!\n");
      uVar2 = 0;
    }
  }
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_bblc_init(void)

{
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 is_ACLC(void)

{
  memw();
  return (uint)((_DAT_3ffc9008 & 3) == 3);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void get_packetheader(u32 *LT_ADDR,u32 *TYPE,u32 *FLOW,u32 *SEQN,u32 *ARQN)

{
  uint uVar1;
  
  uVar1 = _DAT_3ffc9008;
  memw();
  *LT_ADDR = _DAT_3ffc9008 >> 0x16 & 7;
  *TYPE = uVar1 >> 0x19 & 0xf;
  *FLOW = uVar1 >> 0x1d & 1;
  *SEQN = uVar1 >> 0x1f;
  *ARQN = uVar1 >> 0x1e & 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_packetheader(u32 LT_ADDR,u32 TYPE,u32 FLOW,u32 SEQN,u32 ARQN,u32 device_sel)

{
  memw();
  memw();
  _DAT_600320bc =
       (SEQN << 9 | ARQN << 8 | LT_ADDR | FLOW << 7) & 0x3ff | (TYPE & 0xf) << 3 |
       _DAT_600320bc & 0xfffffc00;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_ARQN(u32 ARQN,u32 device_sel)

{
  memw();
  memw();
  _DAT_600320bc = (ARQN & 1) << 8 | _DAT_600320bc & 0xfffffeff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_SEQN(u32 SEQN,u32 device_sel)

{
  memw();
  memw();
  _DAT_600320bc = (SEQN & 1) << 9 | _DAT_600320bc & 0xfffffdff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_LLID(u32 LLID,u32 device_sel)

{
  memw();
  memw();
  _DAT_600320bc = (LLID & 3 | 4) << 10 | _DAT_600320bc & 0xffffe3ff;
  return;
}



// WARNING: Unknown calling convention

void BT_test_mode_fill_tx_payload_
               (u32 lpayload,u32 data_type,u32 loopback,u32 device_sel,u32 tx_addr_base)

{
  u32 unaff_a10;
  u32 unaff_a11;
  u32 in_a12;
  u32 in_a13;
  u32 in_a14;
  
  if (loopback == 0) {
    switch(data_type) {
    case 1:
      unaff_a10 = 0;
      break;
    case 2:
      unaff_a10 = 0xffffffff;
      break;
    case 3:
      unaff_a10 = 0xaaaaaaaa;
      break;
    case 4:
      unaff_a10 = PRBS9[0];
      break;
    case 9:
      unaff_a10 = 0xf0f0f0f0;
    }
    memw();
    *(u32 *)tx_addr_base = unaff_a10;
    return;
  }
  BT_test_mode_fill_tx_payload_(unaff_a10,unaff_a11,in_a12,in_a13,in_a14);
  return;
}



// WARNING: Unknown calling convention

void print_type4(u32 type,u32 link_type)

{
  switch(type) {
  case 0:
    phy_printf(&DAT_00054888);
    return;
  case 1:
    phy_printf(&DAT_00054890);
    return;
  case 2:
    phy_printf(&DAT_00054898);
    return;
  case 3:
    phy_printf(&DAT_0005489c);
    return;
  case 4:
    if (link_type == 4) {
      phy_printf(&DAT_000548a0);
      return;
    }
    if (link_type == 5) {
      phy_printf(&DAT_000548a4);
      return;
    }
    break;
  case 5:
    if (link_type == 1) {
      phy_printf(&DAT_000548b4);
      return;
    }
    break;
  case 6:
    if (link_type == 1) {
      phy_printf(&DAT_000548b8);
      return;
    }
    if (link_type == 3) {
      phy_printf(&DAT_000548bc);
      return;
    }
    break;
  case 7:
    if (link_type == 1) {
      phy_printf(&DAT_000548c4);
      return;
    }
    if (link_type == 2) {
      phy_printf(&DAT_000548c8);
      return;
    }
    if (link_type == 3) {
      phy_printf(&DAT_000548cc);
      return;
    }
    break;
  case 8:
    if (link_type == 1) {
      phy_printf(&DAT_000548d4);
      return;
    }
    if (link_type == 5) {
      phy_printf(&DAT_000548d8);
      return;
    }
    break;
  case 9:
    if (link_type - 4 < 2) {
      phy_printf(&DAT_000548e0);
      return;
    }
    break;
  case 10:
    if (link_type == 4) {
      phy_printf(&DAT_000548e8);
      return;
    }
    if (link_type == 5) {
      phy_printf(&DAT_000548ec);
      return;
    }
    break;
  case 0xb:
    if (link_type == 4) {
      phy_printf(&DAT_000548f4);
      return;
    }
    if (link_type == 5) {
      phy_printf(&DAT_000548f8);
      return;
    }
    break;
  case 0xc:
    if (link_type == 2) {
      phy_printf(&DAT_00054900);
      return;
    }
    if (link_type == 3) {
      phy_printf(&DAT_00054904);
      return;
    }
    break;
  case 0xd:
    if (link_type == 2) {
      phy_printf(&DAT_0005490c);
      return;
    }
    if (link_type == 3) {
      phy_printf(&DAT_00054910);
      return;
    }
    break;
  case 0xe:
    if (link_type == 4) {
      phy_printf(&DAT_00054918);
      return;
    }
    if (link_type == 5) {
      phy_printf(&DAT_0005491c);
      return;
    }
    break;
  case 0xf:
    if (link_type == 4) {
      phy_printf(&DAT_00054924);
      return;
    }
    if (link_type == 5) {
      phy_printf(&DAT_00054928);
      return;
    }
    break;
  default:
    return;
  }
  phy_printf(&DAT_000548ac);
  return;
}



// WARNING: Unknown calling convention

void type_check(u32 gtype,u32 link_type,u32 etype)

{
  if (gtype != etype) {
    phy_printf(&DAT_00054930);
    print_type4(etype,link_type);
    phy_printf(&DAT_00054934);
    print_type4(gtype,link_type);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 BT_testmode_inq(u32 *nap,u32 *uap,u32 *lap,u32 *clk27_2,u32 *clkn,u32 *cod)

{
  uint uVar1;
  bool bVar2;
  u32 uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 0x402;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0xfff & 0xfffffff;
  memw();
  memw();
  _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 1;
  memw();
  uVar8 = 0;
  uVar1 = _DAT_60032108 | 0x402;
  do {
    do {
      _DAT_60032108 = uVar1;
      uVar6 = _DAT_3ffc901c;
      uVar5 = _DAT_3ffc9018;
      uVar4 = _DAT_3ffc9014;
      uVar3 = _DAT_3ffc9004;
      memw();
      if ((_DAT_60032104 & 0x400) != 0) {
        memw();
        _DAT_60032108 = _DAT_60032108 | 0x400;
        memw();
        memw();
        if ((_DAT_600320cc & 0x20000000) == 0) {
          memw();
          _DAT_600320cc = _DAT_600320cc | 0x20000000;
          memw();
        }
        else {
          memw();
          _DAT_600320cc = _DAT_600320cc & 0xdfffffff;
          memw();
        }
        if (9 < uVar8) {
          return 0;
        }
        memw();
        memw();
        memw();
        memw();
        _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0xfff & 0xfffffff;
        memw();
        memw();
        _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
        memw();
        memw();
        _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0 | 1;
        uVar8 = uVar8 + 1;
        memw();
      }
      memw();
      memw();
      uVar1 = _DAT_60032108;
    } while ((_DAT_60032104 & 2) == 0);
    bVar2 = false;
    if ((_DAT_60032120 & 0xff) == 0) {
      memw();
      memw();
      memw();
      memw();
      memw();
      memw();
      memw();
      uVar7 = _DAT_3ffc9020 & 0x1fff;
      memw();
      memw();
      uVar1 = _DAT_3ffc901c >> 0x13;
      memw();
      uVar9 = _DAT_3ffc9018 & 0xff;
      *nap = (_DAT_3ffc9018 >> 0x10 & 0xff) << 8 | _DAT_3ffc9018 >> 8 & 0xff;
      *uap = uVar9;
      *lap = (uVar4 & 0x3fffffc) >> 2;
      *clk27_2 = uVar1 | uVar7 << 0xd;
      uVar1 = _DAT_3ffc9014;
      memw();
      *clkn = uVar3;
      bVar2 = true;
      *cod = (uVar6 & 0xffff) << 8 | uVar5 >> 0x18;
      if ((uVar1 & 0x4000000) != 0) {
        memw();
        _DAT_60032108 = _DAT_60032108 | 2;
        memw();
        do {
          memw();
        } while ((_DAT_60032104 & 2) != 0);
        do {
          memw();
        } while ((_DAT_60032104 & 2) == 0);
        bVar2 = true;
        memw();
        memw();
      }
    }
    memw();
    memw();
    do {
      memw();
    } while ((_DAT_60032104 & 2) != 0);
    uVar1 = _DAT_60032108 | 2;
  } while (!bVar2);
  memw();
  memw();
  _DAT_600320c8 = _DAT_600320c8 & 0xfffffff0;
  do {
    memw();
  } while ((_DAT_60032104 & 0x400) == 0);
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x402;
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_testmode_inq_scan(u32 fast)

{
  int in_a3;
  uint uVar1;
  
  BT_fill_eir_sample_pac(3,1,0x11,(u32)eir_payload);
  memw();
  memw();
  _DAT_600320e0 = _DAT_600320e0 & 0xff | 0x5a020c00;
  memw();
  memw();
  _DAT_600320fc = _DAT_600320fc | 0x400;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320dc = (_DAT_60032000 & 0xfffffff) + 0xffff & 0xfffffff;
  memw();
  memw();
  _DAT_600320d8 = _DAT_600320d8 & 0xfffffc00;
  memw();
  uVar1 = _DAT_600320c8 & 0xfffffff0;
  memw();
  _DAT_600320c8 = uVar1 | 2;
  if (fast == 1) {
    memw();
    in_a3 = _DAT_60032018;
  }
  do {
    memw();
    if ((_DAT_60032104 & 0x400) != 0) {
      memw();
      memw();
      _DAT_60032108 = _DAT_60032108 | 0x400;
      return;
    }
    memw();
  } while ((uint)(_DAT_60032018 - in_a3) < 0xf4241);
  memw();
  memw();
  _DAT_600320c8 = uVar1;
  do {
    memw();
  } while ((_DAT_60032104 & 0x400) == 0);
  memw();
  memw();
  _DAT_60032108 = _DAT_60032108 | 0x400;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ac_lost_print(u32 status,u32 init)

{
  uint uVar1;
  
  if (init == 0) {
    if (status == 0x39) {
      ac_lost = ac_lost + 1;
    }
    memw();
    if (p_print_al < (_DAT_60032000 & 0xfffffff) - t_print_al) {
      if (stage_al == 0) {
        uVar1 = 0;
        if (HP_cp + HP_ep != 0) {
          uVar1 = (HP_ep * 100) / (HP_cp + HP_ep);
        }
        phy_printf("\n%d %d %d %d %d %d %d\n",ac_lost,HP_cp,HP_ap,HP_ep,dut_boost_cnt,uVar1,HP_ppt);
        HP_cp = 0;
        HP_ep = 0;
        ac_lost = 0;
        dut_boost_cnt = 0;
        HP_ap = 0;
        stage_al = 1;
        HP_ppt = 0;
      }
      else if (stage_al == 1) {
        if (HP_total == 0) {
          phy_printf("pwrna\n");
        }
        else {
          phy_printf("-%d -%d %d\n",HP_pwr_ib / HP_total,HP_pwr_fb / HP_total,HP_gain / HP_total);
        }
        HP_pwr_ib = 0;
        HP_total = 0;
        HP_pwr_fb = 0;
        HP_gain = 0;
        stage_al = 0;
      }
      memw();
      t_print_al = _DAT_60032000 & 0xfffffff;
    }
    return;
  }
  memw();
  t_print_al = _DAT_60032000 & 0xfffffff;
  stage_al = 0;
  ac_lost = 0;
  HP_cp = 0;
  HP_ep = 0;
  HP_ap = 0;
  HP_pwr_ib = 0;
  HP_pwr_fb = 0;
  HP_gain = 0;
  HP_total = 0;
  HP_ep_gain0 = 0;
  HP_ep_gain1 = 0;
  HP_ep_gain2 = 0;
  HP_ep_gain3 = 0;
  HP_ep_gain_cycle = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void al_get_power(u32 rx_status)

{
  if ((rx_status == 0) || (rx_status == 0x41 || rx_status == 0)) {
    HP_total = HP_total + 1;
    memw();
    HP_pwr_ib = (HP_pwr_ib + 0x100) - (_DAT_3ff51074 & 0xff);
    memw();
    HP_pwr_fb = (HP_pwr_fb + 0x100) - (_DAT_3ff51078 >> 0x18);
    memw();
    HP_gain = (_DAT_3ff51078 >> 0x10 & 0xff) + HP_gain;
    if (rx_status == 0x41) {
      if (HP_ep_gain_cycle == 0) {
        memw();
        HP_ep_gain0 = _DAT_3ff51078 >> 0x10 & 0xff;
        HP_ep_gain_cycle = 1;
        return;
      }
      if (HP_ep_gain_cycle == 1) {
        memw();
        HP_ep_gain1 = _DAT_3ff51078 >> 0x10 & 0xff;
        HP_ep_gain_cycle = 2;
        return;
      }
      if (HP_ep_gain_cycle == 2) {
        memw();
        HP_ep_gain2 = _DAT_3ff51078 >> 0x10 & 0xff;
        HP_ep_gain_cycle = 3;
        return;
      }
      memw();
      HP_ep_gain3 = _DAT_3ff51078 >> 0x10 & 0xff;
      HP_ep_gain_cycle = 0;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void print_opcode_DUT(u32 opcode)

{
  if (opcode == 7) {
    phy_printf(&DAT_00054964);
    return;
  }
  if (opcode < 8) {
    if (opcode == 3) {
      memw();
      phy_printf("AC%d\n",_DAT_3ffc9010 >> 8 & 0xff);
      return;
    }
    if (opcode == 4) {
      phy_printf(&DAT_00054970);
      return;
    }
  }
  else if (opcode - 0x38 < 2) {
    return;
  }
  phy_printf(&DAT_000547a0,opcode);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 LM_get_opcode(void)

{
  memw();
  return _DAT_3ffc9010 >> 1 & 0x7f;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LM_get_test_control(u32 *test_scenario,u32 *hopping_mode,u32 *TX_frequency,u32 *RX_frequency,
                        u32 *power_control_mode,u32 *poll_period,u32 *packet_type,
                        u32 *length_of_test_data)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar3 = _DAT_3ffc9014;
  uVar2 = _DAT_3ffc9010;
  memw();
  memw();
  memw();
  uVar1 = _DAT_3ffc9010 >> 0x10;
  memw();
  memw();
  *test_scenario = _DAT_3ffc9010 >> 8 & 0xff ^ 0x55;
  uVar4 = _DAT_3ffc9014;
  memw();
  *hopping_mode = uVar1 & 0xff ^ 0x55;
  uVar1 = _DAT_3ffc9014;
  memw();
  *TX_frequency = uVar2 >> 0x18 ^ 0x55;
  uVar2 = _DAT_3ffc9018;
  memw();
  *RX_frequency = uVar3 & 0xff ^ 0x55;
  *power_control_mode = uVar3 >> 8 & 0xff ^ 0x55;
  *packet_type = uVar1 >> 0x18 ^ 0x55;
  *poll_period = uVar4 >> 0x10 & 0xff ^ 0x55;
  *length_of_test_data = uVar2 & 0xffff ^ 0x5555;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LM_hopping_mode(u32 freq)

{
  phy_printf(&DAT_00054568);
  if (testmode_state != 2) {
    memw();
    memw();
    memw();
    memw();
    _DAT_60032124 = _DAT_60032124 & 0xfffffffc;
    memw();
    memw();
    _DAT_600321bc = _DAT_600321bc & 0xfeffffff;
    return;
  }
  if ((transmitter_test == 1) || (test_scenario - 7 < 2)) {
    memw();
    memw();
    memw();
    _DAT_60032124 = _DAT_60032124 | 3;
    memw();
  }
  else {
    memw();
    memw();
    memw();
    _DAT_60032124 = _DAT_60032124 & 0xfffffffc;
    memw();
  }
  if (hopping_mode == 0) {
    TX_frequency = myTX_frequency;
    RX_frequency = myRX_frequency;
    memw();
    memw();
    _DAT_600321bc = _DAT_600321bc | 0x1000000;
    return;
  }
  memw();
  memw();
  _DAT_600321bc = _DAT_600321bc & 0xfeffffff;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_testmode_fill_test_packet(void)

{
  if (testmode_state == 2) {
    if ((test_scenario < 5) || (transmitter_test = (u32)(test_scenario == 9), test_scenario == 9)) {
      transmitter_test = 1;
      phy_printf(&DAT_00054974);
    }
    else {
      phy_printf(&DAT_00054978);
    }
    if (transmitter_test == 1) {
      BT_test_mode_fill_tx_payload_(length_of_test_data,test_scenario,0,1,0x3ffc8000);
      BT_test_mode_fill_tx_payload_(length_of_test_data,test_scenario,0,1,0x3ffca000);
      tx_length = length_of_test_data;
      phy_printf(&DAT_000547a0,length_of_test_data);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LM_accepted(u32 op_code,u32 tx_buffer_addr)

{
  memw();
  *(u32 *)tx_buffer_addr = op_code << 8 | 6;
  tx_length = 2;
  return;
}



// WARNING: Unknown calling convention

void LM_accepted_ext(u32 op_code,u32 tx_buffer_addr,u32 TID)

{
  memw();
  *(u32 *)tx_buffer_addr = TID & 1 | 0x7f01fe | op_code << 0x18;
  tx_length = 4;
  return;
}



// WARNING: Unknown calling convention

void LM_not_accepted(u32 op_code,u32 err_code,u32 tx_buffer_addr)

{
  memw();
  *(u32 *)tx_buffer_addr = err_code << 0x10 | 8 | op_code << 8;
  tx_length = 3;
  return;
}



// WARNING: Unknown calling convention

void LM_fill_payload(u32 len,u32 tx_buffer_addr)

{
  if (len != 0) {
    memw();
    *(u32 *)tx_buffer_addr = LMP_payload[0];
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void link_supervision(link_supervision_struct *param,u32 rx_status)

{
  u32 uVar1;
  u32 now;
  
  uVar1 = _DAT_60032018;
  memw();
  if (param->init == 1) {
    param->init = 0;
    param->last_anchor = uVar1;
    param->detach = 0;
    return;
  }
  if (_DAT_60032018 - param->last_anchor <= param->time_out) {
    if ((rx_status == 0) || (rx_status == 0x41 || rx_status == 0)) {
      param->last_anchor = _DAT_60032018;
    }
    param->detach = 0;
    return;
  }
  if (rx_status != 0) {
    param->detach = 1;
    return;
  }
  param->last_anchor = _DAT_60032018;
  param->detach = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_testmode_lc_ARQN_refresh(void)

{
  u32 uVar1;
  
  if (get_SEQN == last_rx_SEQN) {
    if (get_type < 3) {
LAB_00029960:
      ignore_payload = 0;
LAB_00029a0d:
      if ((last_arq != 1) || (last_tx_crc != 1)) {
        retransmit = 0;
        goto LAB_000299f3;
      }
      uVar1 = 0;
LAB_000299cc:
      if (get_ARQN == 0) {
        retransmit = 1;
        if (uVar1 != 1) {
          retransmit = 1;
          return;
        }
        goto LAB_000299dd;
      }
    }
    else {
      if ((testmode_state != 2) && ((tester_state & 0xfffffffd) != 0)) {
        ARQN = 1;
        if ((get_first_crc != 0) || (rx_status != 0)) goto LAB_000299a0;
        get_first_crc = 1;
        ignore_payload = rx_status;
        goto LAB_00029a0d;
      }
      ARQN = (u32)(rx_status == 0);
      uVar1 = ignore_payload;
      if ((last_arq == 1) && (last_tx_crc == 1)) goto LAB_000299cc;
    }
    retransmit = 0;
    if (uVar1 != 1) goto LAB_000299f3;
  }
  else {
    if (2 < get_type) {
      if (rx_status == 0) {
        HP_cp = HP_cp + 1;
        ARQN = 1;
        last_rx_SEQN = get_SEQN;
      }
      else {
        ARQN = 0;
      }
      goto LAB_00029960;
    }
    ARQN = 0;
LAB_000299a0:
    ignore_payload = 1;
    if ((last_arq == 1) && (uVar1 = last_tx_crc, last_tx_crc == 1)) goto LAB_000299cc;
    retransmit = 0;
  }
LAB_000299dd:
  phy_printf(&DAT_00054980);
LAB_000299f3:
  if (get_ARQN != 1) {
    return;
  }
  SEQN = SEQN ^ 1;
  HP_ap = HP_ap + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram
// WARNING: Unknown calling convention

void BT_testmode_lc_tx_model
               (u32 tx_payload,u32 device_sel,u32 lt_addr,u32 packet_type,u32 LLID,
               u32 packetheader_len,u32 arq)

{
  if (last_tx_old == 1) {
    phy_printf(&DAT_00054984);
  }
  if (retransmit == 0) {
    rtx = retransmit;
    t_time = retransmit;
    if ((tx_payload == 1) || (last_tx_old == 1)) {
      if (TX_BUFFER_SEL == 0) {
        memw();
        _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
        memw();
      }
      else {
        memw();
        _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0xa000;
        memw();
      }
      if (last_tx_old == 1) {
        BT_mac_set_tx_bytelength(0x3ffc8000,pheader_len_next,0,tx_length_next,device_sel);
        memw();
        memw();
        memw();
        _DAT_600320bc =
             (LLID_next & 3 | 4) << 10 |
             (SEQN << 9 | ARQN << 8 | 0x80 | (packet_type_next & 0xf) << 3 | lt_addr) & 0x3ff |
             _DAT_600320bc & 0xffffe000;
        memw();
        phy_printf(&DAT_00054988);
        last_arq = last_arq_new;
        txed_lm = tx_lm_delay;
        if (tx_payload == 1) {
          last_tx_old = 1;
          last_arq_new = arq;
          tx_lm_delay = tx_lm;
          tx_length_next = tx_length;
          LLID_next = LLID;
          pheader_len_next = packetheader_len;
          packet_type_next = packet_type;
        }
        else {
          last_tx_old = 0;
        }
      }
      else {
        BT_mac_set_tx_bytelength(0x3ffc8000,packetheader_len,0,tx_length,device_sel);
        memw();
        memw();
        memw();
        _DAT_600320bc =
             (LLID & 3 | 4) << 10 |
             (SEQN << 9 | ARQN << 8 | 0x80 | lt_addr) & 0x3ff | (packet_type & 0xf) << 3 |
             _DAT_600320bc & 0xffffe000;
        memw();
        txed_lm = tx_lm;
        last_arq = arq;
      }
      TX_BUFFER_SEL = TX_BUFFER_SEL ^ 1;
      last_tx_crc = 1;
    }
    else {
      txed_lm = tx_lm;
      memw();
      _DAT_600320b8 = _DAT_600320b8 & 0xfffff800;
      memw();
      memw();
      memw();
      memw();
      _DAT_600320b0 = _DAT_600320b0 & 0xffc00c00;
      memw();
      memw();
      _DAT_600320bc =
           (SEQN << 9 | ARQN << 8 | 0x80 | lt_addr) & 0x3ff | (packet_type & 0xf) << 3 |
           _DAT_600320bc & 0xfffffc00;
      memw();
      last_tx_crc = 0;
    }
  }
  else {
    if (tx_payload == 1) {
      last_tx_old = 1;
      last_arq_new = arq;
      tx_lm_delay = tx_lm;
      tx_length_next = tx_length;
      LLID_next = LLID;
      pheader_len_next = packetheader_len;
      packet_type_next = packet_type;
    }
    t_time = t_time + 1;
    phy_printf(&DAT_0005498c);
    rtx = 1;
    if (500 < t_time) {
      last_arq = 0;
      t_time = 0;
    }
  }
  memw();
  memw();
  _DAT_600320bc = (ARQN & 1) << 8 | _DAT_600320bc & 0xfffffeff;
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 | 0x100000;
  wait4tx_en_valid = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_testmode_lc_tx_loopback(u32 device_sel)

{
  uint data_type;
  u32 in_a12;
  u32 in_a13;
  u32 in_a14;
  
  data_type = _DAT_600320b0;
  memw();
  _DAT_600320b8 = _DAT_3ffc9000 & 0x7ff;
  memw();
  memw();
  _DAT_600320b0 = (_DAT_3ffc9000 & 0x3ff) << 0xc | _DAT_600320b0 & 0xffc00fff;
  memw();
  BT_test_mode_fill_tx_payload_(0x600320b0,data_type,in_a12,in_a13,in_a14);
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_600320bc = (ARQN & 1) << 8 | (SEQN & 1) << 9 | _DAT_600320bc & 0xffffe0ff | 0x1800;
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 | 0x100000;
  wait4tx_en_valid = 1;
  return;
}



// WARNING: Unknown calling convention

void print_opcode_tester(u32 opcode)

{
  if (opcode == 7) {
    phy_printf("G LMP_detach\n");
    return;
  }
  if (7 < opcode) {
    if (opcode == 0x38) {
      phy_printf("G LMP_test_activate\n");
      return;
    }
    if (opcode != 0x39) {
      return;
    }
    phy_printf("G LMP_test_control\n");
    return;
  }
  if (opcode == 3) {
    phy_printf("G LMP_accepted\n");
    return;
  }
  if (opcode != 4) {
    return;
  }
  phy_printf("G LMP_not_accepted\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void LM_hopping_mode_tester(u32 freq)

{
  phy_printf(&DAT_00054568);
  if (tester_state != 2) {
    memw();
    memw();
    memw();
    memw();
    _DAT_60032124 = _DAT_60032124 & 0xfffffffc;
    memw();
    memw();
    _DAT_600321bc = _DAT_600321bc & 0xfeffffff;
    return;
  }
  memw();
  _DAT_3ffc8000 = PRBS9[0];
  memw();
  _DAT_3ffca000 = PRBS9[0];
  if ((test_scenario - 1 < 4) || (test_scenario - 7 < 3)) {
    memw();
    memw();
    memw();
    _DAT_60032124 = _DAT_60032124 | 3;
    memw();
  }
  else {
    memw();
    memw();
    memw();
    _DAT_60032124 = _DAT_60032124 & 0xfffffffc;
    memw();
  }
  if (hopping_mode == 0) {
    TX_frequency = myTX_frequency;
    RX_frequency = myRX_frequency;
    memw();
    memw();
    _DAT_600321bc = _DAT_600321bc | 0x1000000;
    return;
  }
  memw();
  memw();
  _DAT_600321bc = _DAT_600321bc & 0xfeffffff;
  return;
}



// WARNING: Unknown calling convention

void LM_test_activate(u32 tx_buffer_addr)

{
  memw();
  *(undefined4 *)tx_buffer_addr = 0x70;
  tx_length = 1;
  return;
}



// WARNING: Unknown calling convention

void LM_test_control(u32 test_scenario,u32 hopping_mode,u32 tx_freq,u32 rx_freq,u32 power_ctrl_mode,
                    u32 poll_period,u32 packet_type,u32 len,u32 tx_buffer_addr)

{
  memw();
  *(u32 *)tx_buffer_addr =
       (tx_freq ^ 0x55) << 0x18 | 0x72 | (hopping_mode ^ 0x55) << 0x10 | (test_scenario ^ 0x55) << 8
  ;
  memw();
  *(u32 *)(tx_buffer_addr + 4) =
       (poll_period ^ 0x55) << 0x10 | (packet_type ^ 0x55) << 0x18 | rx_freq ^ 0x55 |
       (power_ctrl_mode ^ 0x55) << 8;
  memw();
  *(u32 *)(tx_buffer_addr + 8) = len ^ 0x5555;
  tx_length = 10;
  return;
}



// WARNING: Unknown calling convention

void LM_detatch(u32 error_code,u32 tx_buffer_addr)

{
  memw();
  *(u32 *)tx_buffer_addr = error_code << 8 | 0xe;
  tx_length = 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_testmode_lm_state
               (u32 tx_buffer_addr,u32 get_ACLC,u32 get_opcode,u32 get_accepted_opcode,
               u32 get_ext_opcode)

{
  u32 uVar1;
  char *pcVar2;
  uint uVar3;
  
  if (LM_xchg_state == 0) {
    LLID = 3;
    packet_type = 3;
    tx_packet = 1;
    LM_xchg_state = 1;
    pheader_len = 1;
    switch(LM_state) {
    case 0:
      LMP_payload[0] = 0x8ffeff4e;
      LMP_payload[1] = 0x5b3fd8fe;
      LMP_payload[2] = 3;
      memw();
      *(undefined4 *)tx_buffer_addr = 0x8ffeff4e;
      uVar1 = LMP_payload[3];
      memw();
      *(undefined4 *)(tx_buffer_addr + 4) = 0x5b3fd8fe;
      memw();
      *(undefined4 *)(tx_buffer_addr + 8) = 3;
      memw();
      *(u32 *)(tx_buffer_addr + 0xc) = uVar1;
      tx_length = 9;
      return;
    case 1:
      LMP_payload[1] = 0;
      LMP_payload[0] = 0x1044a;
      memw();
      *(undefined4 *)tx_buffer_addr = 0x1044a;
      memw();
      *(undefined4 *)(tx_buffer_addr + 4) = 0;
      tx_length = 6;
      return;
    case 2:
      LMP_payload[0] = 0x66;
      break;
    case 3:
      LMP_payload[0] = 0x62;
      break;
    case 4:
      LMP_payload[0] = 10;
      break;
    case 5:
      LMP_payload[0] = 0x55c;
      memw();
      *(undefined4 *)tx_buffer_addr = 0x55c;
      tx_length = 2;
      return;
    case 6:
      LMP_payload[0] = 0x55a;
      memw();
      *(undefined4 *)tx_buffer_addr = 0x55a;
      tx_length = 2;
      LM_state = 7;
      LM_xchg_state = 0;
      return;
    case 7:
      LMP_payload[0] = 0x3e86e;
      memw();
      *(undefined4 *)tx_buffer_addr = 0x3e86e;
      tx_length = 3;
      LM_state = 8;
      LM_xchg_state = 0;
      return;
    case 8:
      LMP_payload[0] = 2;
      memw();
      *(undefined4 *)tx_buffer_addr = 2;
      tx_length = 2;
      return;
    default:
      goto switchD_0002a359_caseD_6;
    }
    memw();
    *(u32 *)tx_buffer_addr = LMP_payload[0];
    tx_length = 1;
    return;
  }
  if (LM_xchg_state != 1) {
    return;
  }
  if (get_ACLC != 1) {
    packet_type = LM_xchg_state;
    tx_packet = LM_xchg_state;
    pheader_len = 0;
switchD_0002a359_caseD_6:
    return;
  }
  memw();
  if ((_DAT_3ffc9010 & 1) != 0) {
    phy_printf(&DAT_00054b54);
    if (get_opcode == 0x2e) {
      phy_printf("max_slot_req\n");
      memw();
      *(undefined4 *)tx_buffer_addr = 0x2e06;
      tx_length = 2;
      LLID = 3;
      packet_type = 3;
      pheader_len = get_ACLC;
      tx_packet = get_ACLC;
      LM_xchg_state = 0;
      LM_state = 4;
      return;
    }
    if (get_opcode == 0x7f) {
      if (get_ext_opcode == 0xb) {
        phy_printf("packet_type_table_req\n");
        memw();
        *(undefined4 *)tx_buffer_addr = 0xb7f01ff;
        tx_length = 4;
        LLID = 3;
        packet_type = 3;
        pheader_len = get_ACLC;
        tx_packet = get_ACLC;
        return;
      }
      if (get_ext_opcode == 0x31) {
        LM_state = 4;
        phy_printf("setup_cmpl\n");
        LM_xchg_state = 0;
        return;
      }
      pcVar2 = "ext%d\n";
      get_opcode = get_ext_opcode;
    }
    else {
      pcVar2 = "%d\n";
    }
    phy_printf(pcVar2,get_opcode);
    packet_type = get_ACLC;
    tx_packet = get_ACLC;
    pheader_len = 0;
    return;
  }
  switch(LM_state) {
  case 0:
    pcVar2 = "%d for f_req\n";
    if (get_opcode == 0x28) {
      memw();
      memw();
      memw();
      phy_printf("f_res %x %x\n",_DAT_3ffc9014 << 0x18 | _DAT_3ffc9010 >> 8,
                 _DAT_3ffc9018 << 0x18 | _DAT_3ffc9014 >> 8);
      LM_state = 1;
      LM_xchg_state = 0;
      return;
    }
    break;
  case 1:
    pcVar2 = "%d for v_req\n";
    if (get_opcode == 0x26) {
      memw();
      memw();
      memw();
      phy_printf("v_res %x %x\n",_DAT_3ffc9014 << 0x18 | _DAT_3ffc9010 >> 8,
                 _DAT_3ffc9018 << 0x18 | _DAT_3ffc9014 >> 8);
      if (LM_chart_almst == 0) {
        LM_state = 2;
      }
      else {
        LM_state = 10;
      }
      LM_xchg_state = 0;
      return;
    }
    break;
  case 2:
    if (get_opcode - 3 < 2) {
      memw();
      uVar3 = _DAT_3ffc9010 >> 8 & 0xff;
      if (uVar3 == 0x33) {
        if (get_opcode == 3) {
          phy_printf("hcon_acpt\n");
        }
        else {
          phy_printf("hcon_nacpt\n");
        }
        LM_state = 3;
        LM_xchg_state = 0;
        return;
      }
      pcVar2 = "%d in LMP_acpt/nacpt for hcon_req\n";
      get_opcode = uVar3;
    }
    else {
      pcVar2 = "%d for hcon_req\n";
    }
    break;
  case 3:
    pcVar2 = "%d for setup_cmpl\n";
    if (get_opcode == 0x31) {
      phy_printf("setup_cmpl\n");
      LM_state = 4;
      LM_xchg_state = 0;
      return;
    }
    break;
  case 4:
    pcVar2 = "%d for clkoffset_req\n";
    if (get_opcode == 6) {
      memw();
      phy_printf("clkoffset_res %x\n",_DAT_3ffc9010 >> 8 & 0xffff);
      LM_state = 5;
      LM_xchg_state = 0;
      return;
    }
    break;
  case 5:
    if (get_opcode - 3 < 2) {
      memw();
      uVar3 = _DAT_3ffc9010 >> 8 & 0xff;
      if (uVar3 == 0x2e) {
        if (get_opcode == 3) {
          phy_printf("max_slot_req_acpt\n");
        }
        else {
          phy_printf("max_slot_req_nacpt\n");
        }
        LM_state = 6;
        LM_xchg_state = 0;
        return;
      }
      pcVar2 = "%d in LMP_acpt/nacpt for max_slot_req\n";
      get_opcode = uVar3;
    }
    else {
      pcVar2 = "%d for max_slot_req\n";
    }
    break;
  default:
    goto switchD_0002a359_caseD_6;
  case 8:
    pcVar2 = "%d for n_req\n";
    if (get_opcode == 2) {
      memw();
      memw();
      memw();
      phy_printf("n_res %x %x\n",_DAT_3ffc9014 << 0x18 | _DAT_3ffc9010 >> 8,
                 _DAT_3ffc9018 << 0x18 | _DAT_3ffc9014 >> 8);
      LM_state = 0;
      LM_chart_almst = 1;
      LM_xchg_state = 0;
      return;
    }
  }
  phy_printf(pcVar2,get_opcode);
  packet_type = 1;
  tx_packet = 1;
  pheader_len = 0;
  return;
}



// WARNING: Unknown calling convention

void BT_testmode_senario_print(u32 senario)

{
  if (senario == 1) {
    phy_printf("\nLMP_TS_ttest_0");
    return;
  }
  if (senario == 2) {
    phy_printf("\nLMP_TS_ttest_1");
    return;
  }
  if (senario == 3) {
    phy_printf("\nLMP_TS_ttest_1010");
    return;
  }
  if (senario == 4) {
    phy_printf("\nLMP_TS_ttest_prbs");
    return;
  }
  if (senario == 5) {
    phy_printf("\nLMP_TS_lbtest_ACL");
    return;
  }
  if (senario == 7) {
    phy_printf("\nLMP_TS_lbtest_ACL_nw");
    return;
  }
  if (senario == 8) {
    phy_printf("\nLMP_TS_lbtest_SCO_nw");
    return;
  }
  if (senario == 9) {
    phy_printf("\nLMP_TS_ttest_11110000");
    return;
  }
  if (senario == 0xff) {
    phy_printf("\nLMP_TS_exit_test_mode");
    return;
  }
  if (senario == 0) {
    phy_printf("\nLMP_TS_pause_test_mode");
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_testmode_lm_model_tester(u32 get_pac)

{
  u32 uVar1;
  uint uVar2;
  undefined4 *tx_buffer_addr;
  u32 in_a13;
  u32 in_a14;
  
  arq = 1;
  memw();
  tx_buffer_addr = (undefined4 *)&DAT_3ffc8000;
  check_packet = 0;
  if (TX_BUFFER_SEL != 0) {
    tx_buffer_addr = (undefined4 *)&DAT_3ffca000;
  }
  if (((_DAT_3ffc9008 & 3) == 3) && (get_pac == 1)) {
    uVar1 = 0;
    if ((rx_status == 0) && ((ignore_payload == 0 || ((tester_state & 0xfffffffd) == 0)))) {
      memw();
      get_opcode = _DAT_3ffc9010 >> 1 & 0x7f;
      print_opcode_tester(get_opcode);
      if (get_opcode == 3) {
        memw();
        in_a13 = _DAT_3ffc9010 >> 8 & 0xff;
        if (((next_tester_state & 0xfffffffd) == 0) && (in_a13 == 0x39)) {
          uVar1 = 1;
          LM_ack = 1;
          in_a13 = 0x39;
        }
        else if ((in_a13 == 0x38) && (next_tester_state == 1)) {
          uVar1 = 1;
          LM_ack = 1;
        }
        else {
          uVar1 = 1;
        }
      }
      else if (get_opcode == 0x7f) {
        memw();
        uVar1 = 1;
        in_a14 = _DAT_3ffc9010 >> 8 & 0xff;
      }
      else {
        uVar1 = 1;
        if (get_opcode == 4) {
          memw();
          in_a13 = _DAT_3ffc9010 >> 8 & 0xff;
          phy_printf("ncop %d\n",in_a13);
          uVar1 = 1;
        }
      }
    }
  }
  else {
    uVar1 = 0;
  }
  if (LM_state != 10) {
    tx_packet = 1;
    packet_type = 1;
    pheader_len = 0;
    if (tpoll == 0) {
      BT_testmode_lm_state((u32)tx_buffer_addr,uVar1,get_opcode,in_a13,in_a14);
    }
    return;
  }
  if ((next_tester_state == tester_state) || (LM_ack != 1)) {
    LM_ack = 0;
LAB_0002a922:
    uVar1 = jump;
    tx_packet = 0;
    if (tester_state != 1) {
      if (tester_state != 0) {
        if (tester_state != 2) {
          return;
        }
        if (tpoll != 0) {
          packet_type = 1;
          rpoll = rpoll + 1;
          ARQN = 1;
          tx_packet = 1;
          pheader_len = 0;
          jump = 0;
          return;
        }
        if (poll_period - 1 != period_past) {
          period_past = period_past + 1;
          return;
        }
        period_past = tpoll;
        tx_packet = 1;
        if (ins_count < 1) {
          if (jump == 0) {
            jump = 1;
            tester_state = 1;
            next_tester_state = 1;
            packet_type = 1;
            pheader_len = uVar1;
            goto LAB_0002b02b;
          }
        }
        else {
          arq = tpoll;
          check_packet = 1;
          LLID = 2;
          if ((3 < test_scenario - 1) && (test_scenario != 9)) {
            pheader_len = 2;
            if (tc_packet_type == 4) {
              pheader_len = 1;
            }
            tx_length = length_of_test_data;
            packet_type = tc_packet_type;
            goto LAB_0002b02b;
          }
        }
        packet_type = 1;
        pheader_len = 0;
LAB_0002b02b:
        ins_count = ins_count + -1;
        return;
      }
      if (tpoll != 0) {
        packet_type = 1;
        tx_packet = 1;
        pheader_len = tester_state;
        rpoll = rpoll + 1;
        return;
      }
      if (jump != 0) {
        pheader_len = 0;
        tx_packet = 1;
        packet_type = 1;
        return;
      }
      nidle = nidle + 1;
      if (nidle < 6) {
        memw();
        *tx_buffer_addr = 0x70;
        tx_length = 1;
        phy_printf(&DAT_00054c6c);
        LLID = 3;
        jump = 1;
        packet_type = 3;
        next_tester_state = 1;
        tx_packet = 1;
        pheader_len = 1;
        return;
      }
      goto LAB_0002aecc;
    }
  }
  else {
    if (2 < next_tester_state) {
LAB_0002a914:
      tpoll = 1;
      goto LAB_0002a922;
    }
    if (4 < rpoll) {
      LM_ack = 0;
      tester_state = next_tester_state;
      LM_hopping_mode_tester(RX_frequency);
      rpoll = 0;
      tpoll = 0;
      ARQN = 0;
      goto LAB_0002a922;
    }
    if (next_tester_state != 1) goto LAB_0002a914;
    tester_state = next_tester_state;
    tpoll = 0;
    LM_ack = 0;
  }
  tx_packet = 0;
  if (tpoll != 0) {
    ARQN = 1;
    packet_type = 1;
    tx_packet = 1;
    pheader_len = 0;
    rpoll = rpoll + 1;
    return;
  }
  if (jump == 0) {
    packet_type = 1;
    tx_packet = 1;
    pheader_len = 0;
    return;
  }
  if (test_case == 0) {
    hopping_mode = test_case;
    myTX_frequency = 0x4e;
    myRX_frequency = 0x4d;
    power_control_mode = test_case;
    poll_period = 1;
    tc_packet_type = 0xf;
    link_type = 4;
    test_scenario = 7;
    length_of_test_data = 0x153;
  }
  else if (test_case == 1) {
    hopping_mode = tpoll;
    myTX_frequency = 0x29;
    myRX_frequency = tpoll;
    power_control_mode = tpoll;
    poll_period = test_case;
    length_of_test_data = 0x14;
    test_scenario = 4;
    tc_packet_type = 4;
    link_type = 4;
    test_case = 2;
  }
  else if (test_case == 2) {
    hopping_mode = tpoll;
    myTX_frequency = 3;
    myRX_frequency = 0x4e;
    power_control_mode = tpoll;
    poll_period = 1;
    test_scenario = 4;
    tc_packet_type = 4;
    link_type = 4;
    length_of_test_data = 0x14;
    test_case = tpoll;
  }
  else if (test_case == 3) {
    hopping_mode = tpoll;
    myTX_frequency = tpoll;
    myRX_frequency = 0x27;
    power_control_mode = tpoll;
    poll_period = 1;
    tc_packet_type = 0x2f;
    length_of_test_data = 0x3fd;
    test_scenario = 5;
    link_type = 5;
    test_case = 4;
  }
  else if (test_case == 4) {
    hopping_mode = tpoll;
    myTX_frequency = 0x42;
    myRX_frequency = 0x46;
    power_control_mode = tpoll;
    poll_period = 1;
    tc_packet_type = 0x2e;
    test_scenario = 5;
    link_type = 5;
    length_of_test_data = 0x2a7;
    test_case = tpoll;
  }
  else if (test_case == 5) {
    hopping_mode = 1;
    myTX_frequency = 0x42;
    myRX_frequency = 0x46;
    power_control_mode = tpoll;
    poll_period = 1;
    tc_packet_type = 4;
    link_type = 4;
    length_of_test_data = 0x1b;
    test_scenario = 7;
    test_case = 6;
  }
  else if (test_case == 6) {
    hopping_mode = 1;
    myTX_frequency = 0x42;
    myRX_frequency = 0x46;
    power_control_mode = tpoll;
    poll_period = 1;
    tc_packet_type = 0x2e;
    link_type = 5;
    test_scenario = 7;
    length_of_test_data = 0x2a7;
    test_case = 7;
  }
  else if (test_case == 7) {
    hopping_mode = 0;
    myTX_frequency = 2;
    myRX_frequency = 0x4e;
    power_control_mode = 0;
    poll_period = 1;
    tc_packet_type = 0xb;
    link_type = 4;
    length_of_test_data = 0xb7;
    test_scenario = 2;
    test_case = 8;
  }
  else if (test_case == 8) {
    hopping_mode = 0;
    myTX_frequency = 0x4e;
    myRX_frequency = 0x14;
    power_control_mode = 0;
    poll_period = 1;
    tc_packet_type = 0x2f;
    length_of_test_data = 0x3fd;
    test_scenario = 5;
    link_type = 5;
    test_case = 9;
  }
  else if (test_case == 9) {
    hopping_mode = 1;
    myTX_frequency = 0x4e;
    myRX_frequency = 0x14;
    power_control_mode = 0;
    tc_packet_type = 4;
    link_type = 4;
    poll_period = 1;
    length_of_test_data = 0x1b;
    test_scenario = 7;
    test_case = 10;
  }
  else if (test_case == 10) {
    hopping_mode = 0;
    myTX_frequency = 0x4d;
    myRX_frequency = 0;
    power_control_mode = 0;
    poll_period = 1;
    tc_packet_type = 0x2e;
    length_of_test_data = 500;
    link_type = 5;
    test_scenario = 3;
    test_case = 0xb;
  }
  else if (test_case == 0xb) {
    hopping_mode = 0;
    myTX_frequency = 1;
    myRX_frequency = 10;
    power_control_mode = 0;
    poll_period = 1;
    tc_packet_type = 4;
    link_type = 4;
    test_scenario = 7;
    length_of_test_data = 0x1a;
    test_case = 0xc;
  }
  else if (test_case == 0xc) {
    hopping_mode = 0;
    myTX_frequency = 0x4c;
    myRX_frequency = 0x4b;
    power_control_mode = 0;
    poll_period = 1;
    tc_packet_type = 10;
    link_type = 4;
    length_of_test_data = 0x79;
    test_scenario = 7;
    test_case = 0xd;
  }
  else if (test_case == 0xd) {
    hopping_mode = 0;
    myTX_frequency = 0;
    myRX_frequency = 0x4e;
    power_control_mode = 0;
    poll_period = 1;
    tc_packet_type = 0x28;
    link_type = 5;
    length_of_test_data = 0x53;
    test_scenario = 7;
    test_case = 0xe;
  }
  else if (test_case == 0xe) {
    hopping_mode = 0;
    myTX_frequency = 0x27;
    myRX_frequency = 0;
    power_control_mode = 0;
    poll_period = 1;
    tc_packet_type = 0x24;
    length_of_test_data = 0x36;
    test_scenario = 5;
    link_type = 5;
    test_case = 0xf;
  }
  else if (test_case == 0xf) {
    hopping_mode = 0;
    myTX_frequency = 0;
    myRX_frequency = 0x27;
    power_control_mode = 0;
    poll_period = 1;
    link_type = 4;
    tc_packet_type = 0xb;
    test_scenario = 7;
    length_of_test_data = 0xb7;
    test_case = 0;
  }
  else if (test_case - 0x10 < 0x16) {
    test_case = 1;
  }
  BT_testmode_senario_print(test_scenario);
  epac_type = tc_packet_type & 0xf;
  tc_linktype = tc_packet_type >> 4;
  link_type = 4;
  if (((tc_linktype != 0) && (link_type = 2, tc_linktype != 1)) && (link_type = 5, tc_linktype != 2)
     ) {
    link_type = 3;
  }
  print_type4(epac_type,link_type);
  phy_printf(&DAT_00054568);
  nactv = nactv + 1;
  if (nactv < 0x11) {
    memw();
    uVar2 = (link_type & 7) << 0x1c;
    _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | uVar2;
    memw();
    memw();
    _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | uVar2;
    memw();
    LM_test_control(test_scenario,hopping_mode,myTX_frequency,myRX_frequency,power_control_mode,
                    poll_period,tc_packet_type,length_of_test_data,(u32)tx_buffer_addr);
    phy_printf(&DAT_00054c70);
    jump = 0;
    tx_packet = 1;
    LLID = 3;
    packet_type = 3;
    next_tester_state = 2;
    ins_count = 50000;
    pheader_len = 1;
    return;
  }
LAB_0002aecc:
  detach = detach + 1;
  packet_type = 3;
  tx_packet = 1;
  pheader_len = 1;
  LLID = 3;
  LMP_payload[0] = 0x130e;
  memw();
  *tx_buffer_addr = 0x130e;
  tx_length = 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_testmode_lc_model_master_response(u32 lt_addr)

{
  u32 link_type;
  u32 type;
  u32 uVar1;
  u32 err_bits;
  u32 total_bits;
  
  uVar1 = 0;
  if (tx_packet == 1) {
    ARQN = 0;
    if ((last_arq == 1) && (last_tx_crc == 1)) {
      retransmit = last_tx_crc;
    }
    else {
      retransmit = 0;
    }
    if ((rx_status == 0) || (rx_status == 0x41 || rx_status == 0)) {
      memw();
      get_type = _DAT_3ffc9008 >> 0x19 & 0xf;
      get_flow = _DAT_3ffc9008 >> 0x1d & 1;
      get_SEQN = _DAT_3ffc9008 >> 0x1f;
      get_lt_addr = _DAT_3ffc9008 >> 0x16 & 7;
      get_ARQN = _DAT_3ffc9008 >> 0x1e & 1;
      if (lt_addr == get_lt_addr) {
        if (rx_status == 0x41) {
          phy_printf(&DAT_00054c74);
        }
        else {
          phy_printf(&DAT_00054c78);
        }
        BT_testmode_lc_ARQN_refresh();
        type = get_type;
        link_type = ::link_type;
        uVar1 = epac_type;
        if (check_packet != 0) {
          if (get_type != epac_type) {
            phy_printf(&DAT_00054930);
            print_type4(uVar1,link_type);
            phy_printf(&DAT_00054934);
            print_type4(type,link_type);
          }
          uVar1 = 4;
          if ((test_scenario & 0xfffffffd) != 5) {
            uVar1 = test_scenario;
          }
          BT_rx_content_status(&total_bits,&err_bits,uVar1);
          if (err_bits != 0) {
            phy_printf(" eb%d ");
          }
        }
        uVar1 = 1;
      }
      else {
        phy_printf(&DAT_00054c84);
        uVar1 = 0;
      }
    }
    else {
      phy_printf(&DAT_00054c8c);
      uVar1 = 0;
    }
  }
  BT_testmode_lm_model_tester(uVar1);
  if (tx_packet == 1) {
    BT_testmode_lc_tx_model((uint)(1 < packet_type),0,lt_addr,packet_type,LLID,pheader_len,arq);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void BT_testmode_lc_model_master(void)

{
  u32 uVar1;
  u32 uVar2;
  link_supervision_struct link_supervision_core;
  uint uStack_30;
  
  memw();
  link_supervision_core.detach = 0;
  link_supervision_core.time_out = 0x98968;
  link_supervision_core.init = 1;
  memw();
  memw();
  _DAT_600320c0 = _DAT_600320c0 & 0x8fffffff | 0x40000000;
  memw();
  memw();
  _DAT_600320b8 = _DAT_600320b8 & 0xfffff800;
  memw();
  memw();
  memw();
  memw();
  _DAT_600320b0 = _DAT_600320b0 & 0xffc00c00;
  memw();
  memw();
  _DAT_600320bc = (SEQN & 1) << 9 | _DAT_600320bc & 0xfffffc00 | 0x8e;
  memw();
  memw();
  uStack_30 = 0;
  _DAT_600320b4 = _DAT_600320b4 & 0x8fffffff | 0x40100000;
  memw();
  uVar1 = 0;
  do {
    memw();
    memw();
    memw();
    _DAT_600320b4 = _DAT_600320b4 | 0x80000000;
    memw();
    do {
      memw();
    } while ((int)_DAT_600320b4 < 0);
    memw();
    tend_debug = _DAT_60033c00;
    memw();
    clk_debug = _DAT_60032000 & 0xfffffff;
    memw();
    uVar2 = 0;
    _DAT_60032134 = (TX_frequency & 0x7f) << 0x10 | _DAT_60032134 & 0xff80ffff;
    memw();
    memw();
    _DAT_600320c0 = _DAT_600320c0 | 0x80000000;
    memw();
    if (wait4tx_en_valid == 1) {
      uVar2 = BT_wait4tx_end_();
    }
    tx_status = uVar2;
    rx_status = BT_wait4rx_end();
    if (uVar1 == 0) {
      if (rx_status == 0) {
        memw();
        if (link_supervision_core.init == 1) {
          link_supervision_core.init = 0;
        }
        link_supervision_core.last_anchor = _DAT_60032018;
        jump = 0;
        tpoll = 0;
        tester_con_to = 0;
        rpoll = 0;
        uVar1 = 1;
        link_supervision_core.detach = 0;
      }
      else {
        uStack_30 = uStack_30 + 1;
        tpoll = 1;
        if (0x20 < uStack_30) {
          SEQN = 1;
          pheader_len = 1;
          next_tester_state = uVar1;
          tester_state = uVar1;
          t_time = uVar1;
          last_arq = uVar1;
          last_tx_old = uVar1;
          last_rx_SEQN = uVar1;
          get_first_crc = uVar1;
          ARQN = uVar1;
          LM_hopping_mode_tester(TX_frequency);
          tester_con_to = 1;
          period_past = uVar1;
          return;
        }
      }
    }
    else {
      link_supervision(&link_supervision_core,rx_status);
      uVar1 = 1;
    }
    BT_testmode_lc_model_master_response(6);
    uVar2 = GetCmd_BT_testmode();
    if (link_supervision_core.detach == 1) {
      detach = 2;
    }
  } while ((uVar2 != 2) && (detach != 2));
  LM_chart_almst = 0;
  LM_state = 0;
  LM_xchg_state = 0;
  SEQN = 1;
  nactv = 0;
  nidle = 0;
  tpoll = 1;
  tester_state = 0;
  next_tester_state = 0;
  period_past = 0;
  ARQN = 0;
  last_rx_SEQN = 0;
  last_arq = 0;
  last_tx_old = 0;
  t_time = 0;
  pheader_len = 1;
  get_first_crc = 0;
  LM_hopping_mode_tester(TX_frequency);
  phy_printf("Tester end!\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_testmode_tester(u32 ulap,u32 nap,u32 dut_lap_est)

{
  u32 uVar1;
  uint uVar2;
  uint uVar3;
  u32 dut_cod;
  u32 clkn;
  u32 dut_clk27_2;
  u32 dut_lap;
  u32 dut_uap;
  u32 dut_nap;
  u32 uStack_30;
  u32 uStack_2c;
  u32 uStack_28;
  uint uStack_24;
  
  memw();
  memw();
  memw();
  _DAT_6003209c = _DAT_6003209c & 0xffff0000 | nap & 0xffff;
  memw();
  memw();
  memw();
  _DAT_600320a0 = 0;
  memw();
  _DAT_600320a4 = _DAT_600320a4 & 0xffff0000;
  memw();
  memw();
  _DAT_600320b4 = _DAT_600320b4 & 0xfffc0000 | 0x8000;
  memw();
  memw();
  _DAT_60032110 = &DAT_3ffc9000;
  _DAT_60032098 = ulap;
  uStack_30 = dut_lap_est;
  uStack_2c = ulap;
  uStack_28 = nap;
  prbs9_gen(PRBS9);
  uVar2 = 0;
LAB_0002b734:
  do {
    do {
      do {
        asserted_debug = 0;
        phy_printf(&DAT_00054ca0);
        uVar1 = BT_testmode_inq(&dut_nap,&dut_uap,&dut_lap,&dut_clk27_2,&clkn,&dut_cod);
      } while (uVar1 != 1);
      phy_printf("get device! %x\n",dut_lap);
    } while (dut_lap != uStack_30);
    uStack_24 = (dut_clk27_2 - (clkn >> 2)) * 4;
    phy_printf("get DUT!\n");
    memw();
    _DAT_600320e4 = _DAT_600320e4 & 0xf0000000 | uStack_24 & 0xfffffff;
    memw();
    BT_m_set_nulap(uStack_2c,uStack_28,dut_uap << 0x18 | dut_lap,dut_nap);
    uVar1 = BT_m_page(1,0xffffeeee,6);
    while (uVar1 != 0) {
      memw();
      uVar3 = _DAT_600320c4 & 0xf;
      if (uVar3 == 2) {
        phy_printf(&DAT_00054cc8);
      }
      else if (uVar3 < 3) {
        if (uVar3 == 1) {
          phy_printf(&DAT_00054cc4);
        }
        else {
LAB_0002b819:
          phy_printf(&DAT_00054cd0);
        }
      }
      else if (uVar3 == 3) {
        phy_printf(&DAT_000547d0);
      }
      else {
        if (uVar3 != 4) goto LAB_0002b819;
        phy_printf(&DAT_00054ccc);
      }
      uVar2 = uVar2 + 1;
      if (0x14 < uVar2) {
        uVar2 = 0;
        goto LAB_0002b734;
      }
      uVar1 = BT_m_page(1,0xffffeeee,6);
    }
    phy_printf(&DAT_000547c4);
    BT_testmode_lc_model_master();
    if (tester_con_to == 0) {
      while ((uVar1 = GetCmd_BT_testmode(), uVar1 != 1 && (detach == 0))) {
        if (uVar1 == 3) {
          lb_test = para_array[0];
          if (para_array[0] == 0) {
            phy_printf("tx test\n");
          }
          else {
            phy_printf("loop test\n");
          }
        }
        else if (uVar1 == 4) {
          if (para_array[0] == 1) {
            hopping_mode = para_array[0];
            phy_printf("normal hop\n");
          }
          else {
            hopping_mode = detach;
            phy_printf("single freq\n");
          }
        }
        else if (uVar1 == 5) {
          memw();
          _DAT_600320f4 = (para_array[0] & 0x3fU) << 8 | _DAT_600320f4 & 0xffffc0ff;
          memw();
          phy_printf(&DAT_000547a0);
        }
        else if (uVar1 == 6) {
          memw();
          _DAT_60032130 = (para_array[0] + 0x49) * 0x100 & 0xffffU | _DAT_60032130 & 0xffff00ff;
          memw();
          memw();
          _DAT_600320f4 = _DAT_600320f4 & 0xffffffc0 | para_array[0] & 0x3fU;
          memw();
          phy_printf(&DAT_000547a0);
        }
      }
      detach = 0;
    }
    memw();
    _DAT_600320c8 = _DAT_600320c8 & 0xfffffeff;
    memw();
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void cmd_polling_handler(void)

{
  cmddesc *pcVar1;
  
  memw();
  _DAT_6001f000 = _DAT_6001f000 | 0x400;
  memw();
  memw();
  _DAT_6001f0a4 = _DAT_6001f0a4 | 1;
  pcVar1 = cmd_queue;
  memw();
  do {
    if ((code)pcVar1->valid != (code)0x0) {
      (*pcVar1->cmd_handler)(pcVar1->args);
    }
    pcVar1 = pcVar1 + 1;
  } while (pcVar1 != (cmddesc *)rtc_time_get);
  return;
}



// WARNING: Unknown calling convention

bool cmd_polling_attach(bool duplicate,u32 dup_id,_xtos_handler cmd_handler,void *args)

{
  uint uVar1;
  
  if ((((duplicate) || (!cmd_queue[0].valid)) || (cmd_queue[0].cmd_handler != cmd_handler)) &&
     (uVar1 = (uint)cmd_queue[0].valid, uVar1 == 0)) {
    cmd_queue[0].valid = true;
    cmd_queue[0].duplicate = duplicate;
    cmd_queue[0].cmd_handler = cmd_handler;
    cmd_queue[0].args = args;
    if (!duplicate) {
      cmd_queue[0].dup_id = uVar1;
      return true;
    }
    cmd_queue[0].dup_id = dup_id;
    return duplicate;
  }
  return false;
}



// WARNING: Unknown calling convention

bool cmd_polling_dettach(bool duplicate,u32 dup_id,_xtos_handler cmd_handler)

{
  undefined uVar1;
  
  if (((cmd_queue[0].valid) && (cmd_queue[0].cmd_handler == cmd_handler)) &&
     ((uVar1 = cmd_queue[0].valid, !duplicate ||
      ((cmd_queue[0].duplicate && (uVar1 = cmd_queue[0].duplicate, cmd_queue[0].dup_id == dup_id))))
     )) {
    cmd_queue[0].valid = false;
    cmd_queue[0].args = (void *)0x0;
    return (bool)uVar1;
  }
  return false;
}



// WARNING: Unknown calling convention

void cmd_polling_start(u32 period)

{
  intr_matrix_set(0,0xe,0xc);
  _xtos_set_interrupt_handler_arg(0xc,cmd_polling_handler,0);
  t0_start_toggle(period);
  _xtos_ints_on(0x1000);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

RESET_REASON rtc_get_reset_reason(void)

{
  RESET_REASON RVar1;
  uint uVar2;
  
  RVar1 = _DAT_3ff48034;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff48018);
  memw();
  _DAT_3ff48018 = uVar2 & 0xdfffffff;
  return RVar1 & 0x3f;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void wdt_nrst_inc(void)

{
  uint uVar1;
  
  uVar1 = _DAT_3ff48034;
  memw();
  _DAT_3ff48018 = esp_dport_access_reg_read(&DAT_3ff48018);
  _DAT_3ff48018 = _DAT_3ff48018 & 0xdfffffff;
  memw();
  if ((uVar1 & 0x3f) - 7 < 3) {
    _DAT_3ff4804c = esp_dport_access_reg_read(&DAT_3ff4804c);
    _DAT_3ff4804c = _DAT_3ff4804c + 1;
    memw();
  }
  return;
}



// WARNING: Unknown calling convention

uint32_t wdt_nrst(void)

{
  uint32_t uVar1;
  uint32_t val;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4804c);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void wdt_init(u32 stage,u32 mode,u32 timeout)

{
  uint uVar1;
  
  if (stage == 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5f048);
    _DAT_3ff5f048 = (mode & 3) << 0x1d | uVar1 & 0x9fffffff;
    memw();
    memw();
    _DAT_3ff5f050 = timeout;
  }
  else if (stage == 1) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5f048);
    _DAT_3ff5f048 = (mode & 3) << 0x1b | uVar1 & 0xe7ffffff;
    memw();
    memw();
    _DAT_3ff5f054 = timeout;
  }
  else if (stage == 2) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5f048);
    _DAT_3ff5f048 = (mode & 3) << 0x19 | uVar1 & 0xf9ffffff;
    memw();
    memw();
    _DAT_3ff5f058 = timeout;
  }
  else if (stage == 3) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5f048);
    _DAT_3ff5f048 = (mode & 3) << 0x17 | uVar1 & 0xfe7fffff;
    memw();
    memw();
    _DAT_3ff5f05c = timeout;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5f048);
  memw();
  _DAT_3ff5f048 = uVar1 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void wdt_feed(void)

{
  memw();
  _DAT_3ff5f060 = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void t0_start_toggle(u32 alarm)

{
  uint uVar1;
  
  _DAT_3ff5f000 = esp_dport_access_reg_read(&DAT_3ff5f000);
  _DAT_3ff5f000 = _DAT_3ff5f000 | 0x60000c00;
  memw();
  _DAT_3ff5f098 = esp_dport_access_reg_read(&DAT_3ff5f098);
  _DAT_3ff5f098 = _DAT_3ff5f098 | 1;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5f000);
  _DAT_3ff5f000 = uVar1 & 0xe0001fff | 0xa0000;
  memw();
  memw();
  memw();
  _DAT_3ff5f014 = 0;
  memw();
  _DAT_3ff5f018 = 0;
  memw();
  _DAT_3ff5f01c = 0;
  memw();
  _DAT_3ff5f020 = 0;
  _DAT_3ff5f010 = alarm;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5f000);
  memw();
  _DAT_3ff5f000 = uVar1 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t0_toggle_service(void)

{
  _DAT_3ff5f000 = esp_dport_access_reg_read(&DAT_3ff5f000);
  _DAT_3ff5f000 = _DAT_3ff5f000 | 0x400;
  memw();
  _DAT_3ff5f0a4 = esp_dport_access_reg_read(&DAT_3ff5f0a4);
  _DAT_3ff5f0a4 = _DAT_3ff5f0a4 | 1;
  memw();
  phy_printf(&DAT_00054d08);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void t1_start_toggle(u32 alarm)

{
  uint uVar1;
  
  _DAT_3ff5f024 = esp_dport_access_reg_read(&DAT_3ff5f024);
  _DAT_3ff5f024 = _DAT_3ff5f024 | 0x60000c00;
  memw();
  _DAT_3ff5f098 = esp_dport_access_reg_read(&DAT_3ff5f098);
  _DAT_3ff5f098 = _DAT_3ff5f098 | 2;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5f024);
  _DAT_3ff5f024 = uVar1 & 0xe0001fff | 0xa0000;
  memw();
  memw();
  memw();
  _DAT_3ff5f038 = 0;
  memw();
  _DAT_3ff5f03c = 0;
  memw();
  _DAT_3ff5f040 = 0;
  memw();
  _DAT_3ff5f044 = 0;
  _DAT_3ff5f034 = alarm;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5f024);
  memw();
  _DAT_3ff5f024 = uVar1 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void t1_toggle_service(void)

{
  _DAT_3ff5f024 = esp_dport_access_reg_read(&DAT_3ff5f024);
  _DAT_3ff5f024 = _DAT_3ff5f024 | 0x400;
  memw();
  _DAT_3ff5f0a4 = esp_dport_access_reg_read(&DAT_3ff5f0a4);
  _DAT_3ff5f0a4 = _DAT_3ff5f0a4 | 2;
  memw();
  phy_printf(&DAT_00054d0c);
  return;
}



// WARNING: Unknown calling convention

void esp_phy_rftest_config(uint8 conf)

{
  idf_enable(conf);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void esp_phy_rftest_init(void)

{
  rftest_init();
  return;
}



// WARNING: Unknown calling convention

void esp_phy_tx_contin_en(bool contin_en)

{
  tx_contin_en(contin_en);
  return;
}



// WARNING: Unknown calling convention

void esp_phy_cbw40m_en(bool en)

{
  cbw40m_en(en);
  return;
}



// WARNING: Unknown calling convention

void esp_phy_wifi_tx(u32 chan,esp_phy_wifi_rate_t rate,s8 backoff,u32 length_byte,u32 packet_delay,
                    u32 packet_num)

{
  int para_array [6];
  
  para_array[2] = (int)backoff;
  para_array[0] = chan;
  para_array[1] = rate;
  para_array[3] = length_byte;
  para_array[4] = packet_delay;
  para_array[5] = packet_num;
  esp_tx_func(para_array,6);
  return;
}



// WARNING: Unknown calling convention

void esp_phy_wifi_rx(u32 chan,esp_phy_wifi_rate_t rate)

{
  esp_rx_func(chan,rate);
  return;
}



// WARNING: Unknown calling convention

void esp_phy_get_rx_result(esp_phy_rx_result *rx_result)

{
  int32 iVar1;
  int32 iVar2;
  uint uVar3;
  
  iVar1 = esp_rx_result[1];
  rx_result->phy_rx_correct_count = esp_rx_result[0];
  iVar2 = esp_rx_result[2];
  uVar3 = (uint)esp_rx_valid;
  rx_result->phy_rx_rssi = iVar1;
  rx_result->phy_rx_total_count = iVar2;
  rx_result->phy_rx_result_flag = uVar3;
  return;
}



// WARNING: Unknown calling convention

void esp_phy_wifi_tx_tone(u32 start,u32 chan,u32 backoff)

{
  wifiscwout(start,chan,backoff);
  return;
}



// WARNING: Unknown calling convention

void esp_phy_short_gi_en(bool en)

{
  short_gi_enable = (u32)en;
  phy_printf("short_gi_enable=%d\n",short_gi_enable);
  return;
}



// WARNING: Unknown calling convention

void esp_phy_ble_tx(u32 txpwr,u32 chan,u32 len,esp_phy_ble_type_t data_type,u32 syncw,
                   esp_phy_ble_rate_t rate,u32 tx_num_in)

{
  esp_ble_tx_func(txpwr,chan,len,data_type,syncw,rate,tx_num_in);
  return;
}



// WARNING: Unknown calling convention

void esp_phy_ble_rx(u32 chan,u32 syncw,esp_phy_ble_rate_t rate)

{
  esp_ble_rx_func(chan,syncw,rate);
  return;
}



// WARNING: Unknown calling convention

void esp_phy_bt_tx_tone(u32 start,u32 chan,u32 backoff)

{
  bt_tx_tone(start,chan,backoff);
  return;
}



// WARNING: Unknown calling convention

void test_digital_pads_slpsel(u32 maskl,u32 maskh,u32 value)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  
  puVar3 = (uint *)&DAT_3ff49004;
  uVar2 = (value & 1) << 1;
  uVar4 = 1;
  do {
    if ((maskl & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffffd | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49084);
  uVar4 = 1;
  puVar3 = (uint *)0x3ff49084;
  do {
    if ((maskh & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffffd | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49090);
  return;
}



// WARNING: Unknown calling convention

void test_digital_pads_slppu(u32 maskl,u32 maskh,u32 value)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  
  puVar3 = (uint *)&DAT_3ff49004;
  uVar2 = (value & 1) << 3;
  uVar4 = 1;
  do {
    if ((maskl & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffff7 | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49084);
  uVar4 = 1;
  puVar3 = (uint *)0x3ff49084;
  do {
    if ((maskh & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffff7 | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49090);
  return;
}



// WARNING: Unknown calling convention

void test_digital_pads_pd(u32 maskl,u32 maskh,u32 value)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  
  puVar3 = (uint *)&DAT_3ff49004;
  uVar2 = (value & 1) << 7;
  uVar4 = 1;
  do {
    if ((maskl & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xffffff7f | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49084);
  uVar4 = 1;
  puVar3 = (uint *)0x3ff49084;
  do {
    if ((maskh & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xffffff7f | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49090);
  return;
}



// WARNING: Unknown calling convention

void test_digital_pads_drv(u32 maskl,u32 maskh,u32 value)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  
  puVar3 = (uint *)&DAT_3ff49004;
  uVar2 = (value & 3) << 10;
  uVar4 = 1;
  do {
    if ((maskl & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffff3ff | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49084);
  uVar4 = 1;
  puVar3 = (uint *)0x3ff49084;
  do {
    if ((maskh & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffff3ff | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49090);
  return;
}



// WARNING: Unknown calling convention

void test_digital_pads_pu(u32 maskl,u32 maskh,u32 value)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  
  puVar3 = (uint *)&DAT_3ff49004;
  uVar2 = (value & 1) << 8;
  uVar4 = 1;
  do {
    if ((maskl & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffeff | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49084);
  uVar4 = 1;
  puVar3 = (uint *)0x3ff49084;
  do {
    if ((maskh & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffeff | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49090);
  return;
}



// WARNING: Unknown calling convention

void test_digital_pads_slppd(u32 maskl,u32 maskh,u32 value)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  
  puVar3 = (uint *)&DAT_3ff49004;
  uVar2 = (value & 1) << 2;
  uVar4 = 1;
  do {
    if ((maskl & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffffb | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49084);
  uVar4 = 1;
  puVar3 = (uint *)0x3ff49084;
  do {
    if ((maskh & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffffb | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49090);
  return;
}



// WARNING: Unknown calling convention

void test_digital_pads_slpoe(u32 maskl,u32 maskh,u32 value)

{
  uint uVar1;
  uint *puVar2;
  uint uVar3;
  
  uVar3 = 1;
  puVar2 = (uint *)&DAT_3ff49004;
  do {
    if ((maskl & uVar3) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar2);
      memw();
      *puVar2 = uVar1 & 0xfffffffe | value & 1;
    }
    puVar2 = puVar2 + 1;
    uVar3 = uVar3 << 1;
  } while (puVar2 != (uint *)0x3ff49084);
  uVar3 = 1;
  puVar2 = (uint *)0x3ff49084;
  do {
    if ((maskh & uVar3) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar2);
      memw();
      *puVar2 = uVar1 & 0xfffffffe | value & 1;
    }
    puVar2 = puVar2 + 1;
    uVar3 = uVar3 << 1;
  } while (puVar2 != (uint *)0x3ff49090);
  return;
}



// WARNING: Unknown calling convention

void test_digital_pads_GPIO(u32 maskl,u32 maskh)

{
  uint uVar1;
  uint *puVar2;
  uint uVar3;
  
  puVar2 = (uint *)&DAT_3ff49004;
  uVar3 = 1;
  do {
    if ((maskl & uVar3) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar2);
      memw();
      *puVar2 = uVar1 & 0xffff8fff | 0x2000;
    }
    puVar2 = puVar2 + 1;
    uVar3 = uVar3 << 1;
  } while (puVar2 != (uint *)0x3ff49084);
  uVar3 = 1;
  puVar2 = (uint *)0x3ff49084;
  do {
    if ((maskh & uVar3) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar2);
      memw();
      *puVar2 = uVar1 & 0xffff8fff | 0x2000;
    }
    puVar2 = puVar2 + 1;
    uVar3 = uVar3 << 1;
  } while (puVar2 != (uint *)0x3ff49090);
  return;
}



// WARNING: Unknown calling convention

void test_digital_pads_ie(u32 maskl,u32 maskh,u32 value)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  
  puVar3 = (uint *)&DAT_3ff49004;
  uVar2 = (value & 1) << 9;
  uVar4 = 1;
  do {
    if ((maskl & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffdff | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49084);
  uVar4 = 1;
  puVar3 = (uint *)0x3ff49084;
  do {
    if ((maskh & uVar4) != 0) {
      uVar1 = esp_dport_access_reg_read(puVar3);
      memw();
      *puVar3 = uVar1 & 0xfffffdff | uVar2;
    }
    puVar3 = puVar3 + 1;
    uVar4 = uVar4 << 1;
  } while (puVar3 != (uint *)0x3ff49090);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void test_rtc_pads_muxsel(u32 mask,u32 value)

{
  uint uVar1;
  
  if ((mask & 1) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4847c);
    _DAT_3ff4847c = (value & 1) << 0x1b | uVar1 & 0xf7ffffff;
    memw();
  }
  if ((mask & 2) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4847c);
    _DAT_3ff4847c = (value & 1) << 0x1a | uVar1 & 0xfbffffff;
    memw();
  }
  if ((mask & 4) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4847c);
    _DAT_3ff4847c = (value & 1) << 0x19 | uVar1 & 0xfdffffff;
    memw();
  }
  if ((mask & 8) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4847c);
    _DAT_3ff4847c = (value & 1) << 0x18 | uVar1 & 0xfeffffff;
    memw();
  }
  if ((mask & 0x10) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff48480);
    _DAT_3ff48480 = (value & 1) << 0x1d | uVar1 & 0xdfffffff;
    memw();
  }
  if ((mask & 0x20) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff48480);
    _DAT_3ff48480 = (value & 1) << 0x1c | uVar1 & 0xefffffff;
    memw();
  }
  if ((mask & 0x40) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff48484);
    _DAT_3ff48484 = (value & 1) << 0x11 | uVar1 & 0xfffdffff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff48488);
    _DAT_3ff48488 = (value & 1) << 0x11 | uVar1 & 0xfffdffff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4848c);
    _DAT_3ff4848c = (value & 1) << 0x12 | uVar1 & 0xfffbffff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4848c);
    _DAT_3ff4848c = (value & 1) << 0x11 | uVar1 & 0xfffdffff;
    memw();
  }
  if ((mask & 0x400) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff48494);
    _DAT_3ff48494 = (value & 1) << 0x13 | uVar1 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x800) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff48498);
    _DAT_3ff48498 = (value & 1) << 0x13 | uVar1 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4849c);
    _DAT_3ff4849c = (value & 1) << 0x13 | uVar1 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff484a0);
    _DAT_3ff484a0 = (value & 1) << 0x13 | uVar1 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff484a4);
    _DAT_3ff484a4 = (value & 1) << 0x13 | uVar1 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff484a8);
    _DAT_3ff484a8 = (value & 1) << 0x13 | uVar1 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff484ac);
    _DAT_3ff484ac = (value & 1) << 0x13 | uVar1 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff484b0);
    _DAT_3ff484b0 = (value & 1) << 0x13 | uVar1 & 0xfff7ffff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void test_slp_pad_ctrl(u32 rtc_excpt_mask)

{
  uint mask;
  
  test_digital_pads_slpsel(0xffffffff,0xffffffff,1);
  test_digital_pads_slpoe(0xffffffff,0xffffffff,0);
  test_digital_pads_slppu(0xffffffff,0xffffffff,0);
  test_digital_pads_slppd(0xffffffff,0xffffffff,0);
  test_digital_pads_pu(0xffffffff,0xffffffff,0);
  test_digital_pads_pd(0xffffffff,0xffffffff,0);
  test_digital_pads_ie(0xffffffff,0xfffffffe,0);
  mask = rtc_excpt_mask ^ 0xffffffff;
  rtc_pads_muxsel(mask,1);
  rtc_pads_slpsel(mask,1);
  rtc_pads_slpoe(mask,0);
  rtc_pads_slpie(mask,0);
  rtc_pads_pu(mask,0);
  rtc_pads_pd(mask,0);
  rtc_pads_funsel(mask,0);
  _DAT_3ff4840c = esp_dport_access_reg_read(&DAT_3ff4840c);
  _DAT_3ff4840c = (mask << 0xe ^ 0xffffffff) & _DAT_3ff4840c;
  memw();
  test_digital_pads_GPIO(0xffffffff,0xfffffffc);
  memw();
  _DAT_3ff44020 = 0;
  memw();
  _DAT_3ff4402c = 0;
  memw();
  _DAT_3ff44004 = 0xffffffff;
  memw();
  _DAT_3ff44010 = 0xffffffff;
  test_digital_pads_pu(0x400000,0,1);
  test_digital_pads_slppu(0x400000,0,1);
  return;
}



// WARNING: Unknown calling convention

void test_pad_mode_sel(u8 mode,u32 maskl,u32 maskh)

{
  uint value;
  
  value = (uint)mode;
  if (mode == '\0') {
    phy_printf("pad initialed\n");
    ets_delay_us(5000);
    test_digital_pads_slpsel(0xffffffff,0xffffffff,1);
    test_digital_pads_slpoe(0xffffffff,0xffffffff,value);
    test_digital_pads_slppu(0xffffffff,0xffffffff,value);
    test_digital_pads_slppd(0xffffffff,0xffffffff,value);
    test_digital_pads_pu(0xffffffff,0xffffffff,value);
    test_digital_pads_pd(0xffffffff,0xffffffff,value);
    test_digital_pads_ie(0xffffffff,0xfffffffe,value);
    test_rtc_pads_muxsel(0xffffffff,value);
    return;
  }
  if (value == 1) {
    phy_printf("pad set to analog mode\n");
    ets_delay_us(5000);
    test_slp_pad_ctrl(0);
    return;
  }
  if (value == 2) {
    phy_printf("pad set to GPIO mode\n");
    ets_delay_us(5000);
    test_digital_pads_slpsel(maskl,maskh,0);
    test_digital_pads_slpoe(maskl,maskh,0);
    test_digital_pads_slppu(maskl,maskh,0);
    test_digital_pads_slppd(maskl,maskh,0);
    test_digital_pads_pu(maskl,maskh,0);
    test_digital_pads_pd(maskl,maskh,0);
    test_digital_pads_ie(maskl,maskh,1);
    test_digital_pads_GPIO(maskl,maskh);
    test_rtc_pads_muxsel(0xffffffff,0);
  }
  return;
}



// WARNING: Unknown calling convention

void ESP_TEST_GPIO(u32 *test_gpio,u32 *Input_result)

{
  u32 uVar1;
  uint uVar2;
  u32 *puVar3;
  uint uVar4;
  u32 *puVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  int iVar10;
  u32 Input_value [3];
  uint uStack_30;
  u32 *puStack_2c;
  
  puVar5 = Input_value;
  Input_value[0] = 0;
  Input_value[1] = 0;
  Input_value[2] = 0;
  phy_printf("GPIO TEST MODE\n");
  uart_wait_idle('\0');
  ets_delay_us(10000);
  puVar3 = ini_gpio_val;
  do {
    uVar1 = esp_dport_access_reg_read(puVar3 + 0xffb8bde);
    *puVar3 = uVar1;
    puVar3 = puVar3 + 1;
  } while ((packet_struct *)puVar3 != &packet_2EV5);
  test_pad_mode_sel('\x02',0xffffffff,0xfffffffc);
  uVar6 = 0;
  puVar3 = test_gpio;
  do {
    uVar7 = uVar6 - 0x23;
    uVar8 = uVar6 - 0x25;
    uVar2 = 0;
    uVar4 = uVar6;
    do {
      uVar8 = uVar8 & 0xff;
      uVar7 = uVar7 & 0xff;
      uVar9 = *puVar3 >> (uVar2 & 0x1f) & 3;
      if (uVar9 != 1) {
        if ((uVar9 != 2) || (uVar4 == 0x22)) {
          if ((uVar9 != 3) || (uVar4 == 0x22)) {
            if (uVar9 != 0) goto LAB_0002cbc4;
            if (uVar4 < 0x20) {
              gpio_output_set(0,0,0,1 << 0x20 - (0x20 - (uVar4 & 0x1f)));
            }
            else {
              gpio_output_set_high(0,0,0,1 << 0x20 - (0x20 - (uVar4 & 0x1f)));
            }
          }
          else if ((uVar7 < 2) || (uVar8 < 3)) {
LAB_0002cbc4:
            phy_printf("gpio setting error!");
          }
          else if (uVar4 < 0x20) {
            iVar10 = 1 << 0x20 - (0x20 - (uVar4 & 0x1f));
            gpio_output_set(iVar10,0,iVar10);
          }
          else {
            iVar10 = 1 << 0x20 - (0x20 - (uVar4 & 0x1f));
            gpio_output_set_high(iVar10,0,iVar10);
          }
        }
        else {
          if ((uVar7 < 2) || (uVar8 < 3)) goto LAB_0002cbc4;
          if (uVar4 < 0x20) {
            iVar10 = 1 << 0x20 - (0x20 - (uVar4 & 0x1f));
            gpio_output_set(0,iVar10,iVar10);
          }
          else {
            iVar10 = 1 << 0x20 - (0x20 - (uVar4 & 0x1f));
            gpio_output_set_high(0,iVar10,iVar10);
          }
        }
      }
      uVar7 = uVar7 + 1;
      uVar8 = uVar8 + 1;
      uVar2 = uVar2 + 2;
      uVar4 = uVar4 + 1 & 0xff;
    } while (uVar2 != 0x20);
    uVar6 = uVar6 + 0x10 & 0xff;
    puVar3 = puVar3 + 1;
    if (uVar6 == 0x30) {
      uVar6 = 0;
      uStack_30 = 0;
      puStack_2c = Input_result;
      while( true ) {
        uVar2 = 0;
        uVar4 = uStack_30;
        do {
          uVar7 = 0;
          if ((*test_gpio >> (uVar2 & 0x1f) & 3) == 1) {
            if (uVar4 < 0x20) {
              uVar7 = gpio_input_get();
              uVar7 = (uVar7 >> (uVar4 & 0x1f) & 1 | 2) << 0x20 - (0x20 - (uVar2 & 0x1f));
            }
            else {
              uVar7 = gpio_input_get_high();
              uVar7 = (uVar7 >> (uVar4 & 0x1f) & 1 | 2) << 0x20 - (0x20 - (uVar2 & 0x1f));
            }
          }
          uVar6 = uVar6 | uVar7;
          *puVar5 = uVar6;
          uVar2 = uVar2 + 2;
          uVar4 = uVar4 + 1 & 0xff;
        } while (uVar2 != 0x20);
        uStack_30 = uStack_30 + 0x10 & 0xff;
        puVar5 = puVar5 + 1;
        test_gpio = test_gpio + 1;
        *puStack_2c = uVar6;
        puStack_2c = puStack_2c + 1;
        if (uStack_30 == 0x30) break;
        uVar6 = *puVar5;
      }
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void ESP_TEST_GPIO_DRV(u32 *test_gpio,u32 *Input_result,u8 drv)

{
  u32 uVar1;
  uint uVar2;
  u32 *puVar3;
  uint uVar4;
  u32 *puVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  int iVar10;
  u32 Input_value [3];
  uint uStack_30;
  u32 *puStack_2c;
  
  puVar5 = Input_value;
  Input_value[0] = 0;
  Input_value[1] = 0;
  Input_value[2] = 0;
  phy_printf("GPIO TEST MODE\n");
  uart_wait_idle('\0');
  ets_delay_us(10000);
  puVar3 = ini_gpio_val;
  do {
    uVar1 = esp_dport_access_reg_read(puVar3 + 0xffb8bde);
    *puVar3 = uVar1;
    puVar3 = puVar3 + 1;
  } while ((packet_struct *)puVar3 != &packet_2EV5);
  test_pad_mode_sel('\x02',0xffffffff,0xfffffffc);
  test_digital_pads_drv(0xffffffff,0xfffffffc,(uint)drv);
  uVar6 = 0;
  puVar3 = test_gpio;
  do {
    uVar7 = uVar6 - 0x23;
    uVar8 = uVar6 - 0x25;
    uVar2 = 0;
    uVar4 = uVar6;
    do {
      uVar8 = uVar8 & 0xff;
      uVar7 = uVar7 & 0xff;
      uVar9 = *puVar3 >> (uVar2 & 0x1f) & 3;
      if (uVar9 != 1) {
        if ((uVar9 != 2) || (uVar4 == 0x22)) {
          if ((uVar9 != 3) || (uVar4 == 0x22)) {
            if (uVar9 != 0) goto LAB_0002ce27;
            if (uVar4 < 0x20) {
              gpio_output_set(0,0,0,1 << 0x20 - (0x20 - (uVar4 & 0x1f)));
            }
            else {
              gpio_output_set_high(0,0,0,1 << 0x20 - (0x20 - (uVar4 & 0x1f)));
            }
          }
          else if ((uVar7 < 2) || (uVar8 < 3)) {
LAB_0002ce27:
            phy_printf("gpio setting error!");
          }
          else if (uVar4 < 0x20) {
            iVar10 = 1 << 0x20 - (0x20 - (uVar4 & 0x1f));
            gpio_output_set(iVar10,0,iVar10);
          }
          else {
            iVar10 = 1 << 0x20 - (0x20 - (uVar4 & 0x1f));
            gpio_output_set_high(iVar10,0,iVar10);
          }
        }
        else {
          if ((uVar7 < 2) || (uVar8 < 3)) goto LAB_0002ce27;
          if (uVar4 < 0x20) {
            iVar10 = 1 << 0x20 - (0x20 - (uVar4 & 0x1f));
            gpio_output_set(0,iVar10,iVar10);
          }
          else {
            iVar10 = 1 << 0x20 - (0x20 - (uVar4 & 0x1f));
            gpio_output_set_high(0,iVar10,iVar10);
          }
        }
      }
      uVar7 = uVar7 + 1;
      uVar8 = uVar8 + 1;
      uVar2 = uVar2 + 2;
      uVar4 = uVar4 + 1 & 0xff;
    } while (uVar2 != 0x20);
    uVar6 = uVar6 + 0x10 & 0xff;
    puVar3 = puVar3 + 1;
    if (uVar6 == 0x30) {
      uVar6 = 0;
      uStack_30 = 0;
      puStack_2c = Input_result;
      while( true ) {
        uVar2 = 0;
        uVar4 = uStack_30;
        do {
          uVar7 = 0;
          if ((*test_gpio >> (uVar2 & 0x1f) & 3) == 1) {
            if (uVar4 < 0x20) {
              uVar7 = gpio_input_get();
              uVar7 = (uVar7 >> (uVar4 & 0x1f) & 1 | 2) << 0x20 - (0x20 - (uVar2 & 0x1f));
            }
            else {
              uVar7 = gpio_input_get_high();
              uVar7 = (uVar7 >> (uVar4 & 0x1f) & 1 | 2) << 0x20 - (0x20 - (uVar2 & 0x1f));
            }
          }
          uVar6 = uVar6 | uVar7;
          *puVar5 = uVar6;
          uVar2 = uVar2 + 2;
          uVar4 = uVar4 + 1 & 0xff;
        } while (uVar2 != 0x20);
        uStack_30 = uStack_30 + 0x10 & 0xff;
        puVar5 = puVar5 + 1;
        test_gpio = test_gpio + 1;
        *puStack_2c = uVar6;
        puStack_2c = puStack_2c + 1;
        if (uStack_30 == 0x30) break;
        uVar6 = *puVar5;
      }
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void CMDSTOP_GPIO(void)

{
  memw();
  _DAT_3ff49004 = ini_gpio_val[0];
  phy_printf("\n\n\nEND!\n\n\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint16 pvt(u16 dig_dbias,bool pvt_res_en,u16 pvt_delay)

{
  uint uVar1;
  int iVar2;
  ushort extraout_var;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  _DAT_3ff4807c = (dig_dbias & 7) << 0xb | uVar1 & 0xffffc7ff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = uVar1 & 0xfffffc00 | pvt_delay & 0x3ff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = (pvt_res_en & 1) << 0xb | uVar1 & 0xfffff7ff;
  memw();
  _DAT_3ff48030 = esp_dport_access_reg_read(&DAT_3ff48030);
  _DAT_3ff48030 = _DAT_3ff48030 | 0x4000000;
  memw();
  _DAT_3ff4e0f8 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = _DAT_3ff4e0f8 & 0xfffffbff;
  memw();
  _DAT_3ff4e0f8 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = _DAT_3ff4e0f8 | 0x400;
  memw();
  while (iVar2 = esp_dport_access_reg_read(&DAT_3ff4e0f8), -1 < iVar2) {
    ets_delay_us(10000);
  }
  esp_dport_access_reg_read(&DAT_3ff4e0f8);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48030);
  memw();
  _DAT_3ff48030 = uVar1 & 0xfbffffff;
  return extraout_var & 0x3fff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint16 pvt_test(u16 dig_dbias,bool pvt_res_en,u16 pvt_delay)

{
  uint uVar1;
  int iVar2;
  ushort extraout_var;
  uint32_t val;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  _DAT_3ff4807c = (dig_dbias & 7) << 0xb | uVar1 & 0xffffc7ff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = uVar1 & 0xfffffc00 | pvt_delay & 0x3ff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = (pvt_res_en & 1) << 0xb | uVar1 & 0xfffff7ff;
  memw();
  _DAT_3ff4e0f8 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = _DAT_3ff4e0f8 & 0xfffffbff;
  memw();
  _DAT_3ff4e0f8 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = _DAT_3ff4e0f8 | 0x400;
  memw();
  while (iVar2 = esp_dport_access_reg_read(&DAT_3ff4e0f8), -1 < iVar2) {
    ets_delay_us(600);
  }
  _DAT_3ff4e0f8 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = _DAT_3ff4e0f8 & 0xfffffbff;
  memw();
  _DAT_3ff4e0f8 = esp_dport_access_reg_read(&DAT_3ff4e0f8);
  _DAT_3ff4e0f8 = _DAT_3ff4e0f8 | 0x400;
  memw();
  while (iVar2 = esp_dport_access_reg_read(&DAT_3ff4e0f8), -1 < iVar2) {
    ets_delay_us(600);
  }
  esp_dport_access_reg_read(&DAT_3ff4e0f8);
  return extraout_var & 0x3fff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void pvt_pwr_ctrl(u8 pvt_pu_en)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48030);
  _DAT_3ff48030 = (pvt_pu_en & 1) << 0x1a | uVar1 & 0xfbffffff;
  memw();
  if (pvt_pu_en == '\0') {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
    _DAT_3ff4807c = uVar1 & 0xffffc7ff | 0x2000;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint32 clk8M(u32 req,u32 delay)

{
  uint uVar1;
  
  rtc_8m_ena(1);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48070);
  _DAT_3ff48070 = (req & 0xff) << 0x11 | uVar1 & 0xfe01ffff;
  memw();
  ets_delay_us(1000);
  uVar1 = rtc_slowck_cali(1,delay);
  return 0x1f400000 / (uVar1 >> 8);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint32 GPIO_cali(u32 num)

{
  uint uVar1;
  int iVar2;
  uint32_t val;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff44128);
  _DAT_3ff44128 = uVar1 & 0xfffffc00 | num & 0x3ff;
  memw();
  _DAT_3ff44128 = esp_dport_access_reg_read(&DAT_3ff44128);
  _DAT_3ff44128 = _DAT_3ff44128 & 0x7fffffff;
  memw();
  ets_delay_us(2);
  _DAT_3ff44128 = esp_dport_access_reg_read(&DAT_3ff44128);
  _DAT_3ff44128 = _DAT_3ff44128 | 0x80000000;
  memw();
  ets_delay_us(2);
  while (iVar2 = esp_dport_access_reg_read(0x3ff4412c), -1 < iVar2) {
    ets_delay_us(1000);
  }
  uVar1 = esp_dport_access_reg_read(0x3ff4412c);
  return uVar1 & 0xfffff;
}



// WARNING: Unknown calling convention

u8 slow_clk_write_efuse(u8 set_temp)

{
  u8 uVar1;
  uint32 uVar2;
  uint uVar3;
  int result;
  uint uVar4;
  
  uVar2 = GPIO_cali(0x32);
  uVar4 = ((uint)temp_wr - (uint)set_temp) * 0x14 + -8000 + uVar2;
  uVar3 = uVar4 & 0xffff;
  phy_printf("GPIO_cali_init:%d,write_delta:%d\n",uVar2,uVar3);
  wr_en[0x16] = 0xff;
  wr_en[0x17] = 0xff;
  wr_data[0x16] = (u8)uVar3;
  wr_data[0x17] = (u8)(uVar3 >> 8);
  memw();
  phy_printf("0x%02x,0x%02x\n",uVar4 & 0xff,uVar3 >> 8);
  uVar1 = burn_efuse(wr_data,wr_en);
  wr_data[0x16] = '\0';
  wr_data[0x17] = '\0';
  wr_en[0x16] = '\0';
  wr_en[0x17] = '\0';
  memw();
  return uVar1;
}



// WARNING: Unknown calling convention

u8 slow_clk_read_temp(void)

{
  uint uVar1;
  uint32 uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  u32 read_slow_clk;
  uint uVar6;
  
  uVar2 = GPIO_cali(0x32);
  uVar3 = esp_dport_access_reg_read(0x3ff5a014);
  uVar1 = uVar3 >> 0x18;
  uVar6 = uVar3 >> 0x10 & 0xff;
  uVar5 = uVar1 << 8 | uVar6;
  iVar4 = (int)(short)((short)uVar2 + -8000);
  phy_printf("GPIO_cali_read:%d,read_delta:%d,write_delta:%d,0x%02x,0x%02x\n",uVar2,iVar4,uVar5,
             uVar6,uVar1);
  if (((uVar3 >> 0x10 & 0xff) != 0) && (uVar1 != 0)) {
    iVar4 = (int)((iVar4 - uVar5) * 0x19) >> 9;
    phy_printf("tmp:%d\n",iVar4);
    return temp_wr + temp_offset + (char)iVar4;
  }
  return 0xff;
}



// WARNING: Unknown calling convention

bool esp_crc8(bool *p,uint len)

{
  bool *pbVar1;
  uint uVar2;
  
  pbVar1 = p + len;
  uVar2 = 0;
  for (; p != pbVar1; p = p + 1) {
    uVar2 = uVar2 ^ *p;
    if ((uVar2 & 1) == 0) {
      uVar2 = uVar2 >> 1;
    }
    else {
      uVar2 = (uVar2 >> 1 ^ 0xffffff8c) & 0xff;
    }
  }
  return SUB41(uVar2,0);
}



// WARNING: Unknown calling convention

u8 check_usermac_from_efuse(uint8 *macaddr)

{
  char cVar1;
  uint8 uVar2;
  u8 uVar3;
  uint uVar4;
  u8 crc_calc;
  uint uVar5;
  uint uVar6;
  byte *pbVar7;
  u8 temp [6];
  byte abStack_2a [42];
  
  pbVar7 = temp;
  cVar1 = esp_dport_access_reg_read(0x3ff5a08f);
  uVar4 = esp_dport_access_reg_read(0x3ff5a078);
  uVar2 = esp_dport_access_reg_read(0x3ff5a079);
  *macaddr = uVar2;
  memw();
  uVar2 = esp_dport_access_reg_read(0x3ff5a07a);
  macaddr[1] = uVar2;
  memw();
  uVar2 = esp_dport_access_reg_read(0x3ff5a07b);
  macaddr[2] = uVar2;
  memw();
  uVar2 = esp_dport_access_reg_read(0x3ff5a07c);
  macaddr[3] = uVar2;
  memw();
  uVar2 = esp_dport_access_reg_read(0x3ff5a07d);
  macaddr[4] = uVar2;
  memw();
  temp[5] = esp_dport_access_reg_read(0x3ff5a07e);
  macaddr[5] = temp[5];
  memw();
  uVar5 = (uint)*macaddr;
  if (cVar1 == '\0') {
    temp[1] = macaddr[1];
    temp[2] = macaddr[2];
    if ((uVar5 == 0) && (temp[1] == '\0')) {
      if (temp[2] == '\0') {
        temp[3] = macaddr[3];
        if (temp[3] == '\0') {
          temp[4] = macaddr[4];
          if (temp[4] == '\0') {
            if ((uVar4 & 0xff) == 0 && temp[5] == '\0') {
              return '\0';
            }
            uVar5 = 0;
            temp[1] = '\0';
            temp[2] = '\0';
            temp[3] = '\0';
          }
          else {
            uVar5 = 0;
            temp[1] = '\0';
            temp[2] = '\0';
          }
        }
        else {
          temp[4] = macaddr[4];
          uVar5 = 0;
          temp[1] = '\0';
        }
        goto LAB_0002d583;
      }
      uVar5 = 0;
    }
    temp[3] = macaddr[3];
    temp[4] = macaddr[4];
  }
  else {
    temp[1] = macaddr[1];
    temp[2] = macaddr[2];
    temp[3] = macaddr[3];
    temp[4] = macaddr[4];
  }
LAB_0002d583:
  uVar6 = 0;
  memw();
  while( true ) {
    uVar6 = uVar6 ^ uVar5;
    pbVar7 = pbVar7 + 1;
    if ((uVar6 & 1) == 0) {
      uVar6 = uVar6 >> 1;
    }
    else {
      uVar6 = (uVar6 >> 1 ^ 0xffffff8c) & 0xff;
    }
    if (pbVar7 == abStack_2a) break;
    uVar5 = (uint)*pbVar7;
  }
  uVar3 = '\x01';
  if ((uVar4 & 0xff) != uVar6) {
    uVar3 = '\x02';
  }
  return uVar3;
}



// WARNING: Unknown calling convention

u8 wr_adc_blk0(void)

{
  u8 uVar1;
  
  wr_data[0xd] = '@';
  wr_en[0xd] = '@';
  wr_data[0x18] = '\x01';
  wr_en[0x18] = '\x03';
  memw();
  uVar1 = burn_efuse(wr_data,wr_en);
  wr_data[0xd] = '\0';
  wr_en[0xd] = '\0';
  wr_data[0x18] = '\0';
  wr_en[0x18] = '\0';
  memw();
  return uVar1;
}



// WARNING: Unknown calling convention

u8 wr_adc_blk0_data3_14b(void)

{
  u8 uVar1;
  
  wr_data[0xd] = '@';
  wr_en[0xd] = '@';
  memw();
  uVar1 = burn_efuse(wr_data,wr_en);
  wr_data[0xd] = '\0';
  wr_en[0xd] = '\0';
  memw();
  return uVar1;
}



// WARNING: Unknown calling convention

u8 write_coding_to_efuse(void)

{
  u8 uVar1;
  
  wr_data[0x18] = '\x01';
  wr_en[0x18] = '\x03';
  memw();
  uVar1 = burn_efuse(wr_data,wr_en);
  wr_data[0x18] = '\0';
  wr_en[0x18] = '\0';
  memw();
  return uVar1;
}



// WARNING: Unknown calling convention

bool count_ones(bool in)

{
  char cVar1;
  uint uVar2;
  
  uVar2 = (uint)in;
  if (in) {
    cVar1 = '\0';
    do {
      if ((uVar2 & 1) != 0) {
        cVar1 = cVar1 + '\x01';
      }
      uVar2 = uVar2 >> 1;
    } while (uVar2 != 0);
    return (bool)cVar1;
  }
  return in;
}



// WARNING: Unknown calling convention

void make_efuse(u8 *all_bytes,u8 *efuse_result)

{
  uint uVar1;
  u32 uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  byte *pbVar6;
  uint uVar7;
  byte *pbVar8;
  u32 *puVar9;
  byte *pbVar10;
  u32 *puVar11;
  byte *pbVar12;
  u8 burn_value [32];
  u32 efuse_raw [8];
  u8 ones [4];
  u8 parity [4];
  byte abStack_38 [8];
  uint uStack_30;
  uint uStack_2c;
  
  puVar9 = (u32 *)burn_value;
  uVar4 = 0;
  burn_value[0] = '\0';
  burn_value[1] = '\0';
  burn_value[2] = '\0';
  burn_value[3] = '\0';
  pbVar10 = parity;
  pbVar8 = ones;
  uVar7 = 0;
  parity[0] = '\0';
  parity[1] = '\0';
  parity[2] = '\0';
  parity[3] = '\0';
  ones[0] = '\0';
  ones[1] = '\0';
  ones[2] = '\0';
  ones[3] = '\0';
  efuse_raw[1] = 0;
  efuse_raw[2] = 0;
  efuse_raw[3] = 0;
  efuse_raw[4] = 0;
  efuse_raw[5] = 0;
  efuse_raw[6] = 0;
  efuse_raw[7] = 0;
  pbVar12 = all_bytes;
  while( true ) {
    iVar5 = 1;
    pbVar6 = pbVar12;
    do {
      uVar1 = (uint)*pbVar6;
      uVar7 = uVar1 ^ uVar7;
      if (uVar1 == 0) {
        uVar1 = 0;
      }
      else {
        uVar3 = 0;
        do {
          if ((uVar1 & 1) != 0) {
            uVar3 = uVar3 + 1 & 0xff;
          }
          uVar1 = uVar1 >> 1;
        } while (uVar1 != 0);
        uVar1 = uVar3 * iVar5 & 0xff;
      }
      uVar1 = uVar4 + uVar1;
      uVar4 = uVar1 & 0xff;
      *pbVar8 = (byte)uVar1;
      memw();
      iVar5 = iVar5 + 1;
      pbVar6 = pbVar6 + 1;
    } while (iVar5 != 7);
    pbVar8 = pbVar8 + 1;
    *pbVar10 = (byte)uVar7;
    memw();
    pbVar10 = pbVar10 + 1;
    pbVar12 = pbVar12 + 6;
    if (pbVar10 == abStack_38) break;
    uVar7 = (uint)*pbVar10;
    uVar4 = (uint)*pbVar8;
  }
  uStack_30 = ((uint)ones >> 8) << 0x18 | ((uint)parity >> 8 & 0xff) << 0x10;
  uStack_2c = ((uint)ones >> 0x10) << 0x18 | ((uint)parity >> 0x10 & 0xff) << 0x10;
  efuse_raw[2] = *(u32 *)(all_bytes + 6);
  efuse_raw[1] = (int)ones << 0x18 | ((uint)parity & 0xff) << 0x10 | (uint)all_bytes[4] |
                 (uint)all_bytes[5] << 8;
  uVar2 = *(u32 *)all_bytes;
  efuse_raw[5] = uStack_2c | all_bytes[0x10] | (uint)all_bytes[0x11] << 8;
  efuse_raw[3] = uStack_30 | all_bytes[10] | (uint)all_bytes[0xb] << 8;
  efuse_raw[4] = *(u32 *)(all_bytes + 0xc);
  efuse_raw[6] = *(u32 *)(all_bytes + 0x12);
  efuse_raw[7] = (uint)ones & 0xff000000 | ((uint)parity >> 0x18) << 0x10 | (uint)all_bytes[0x16] |
                 (uint)all_bytes[0x17] << 8;
  puVar11 = efuse_raw;
  while( true ) {
    puVar11 = puVar11 + 1;
    *(char *)puVar9 = (char)uVar2;
    *(char *)((int)puVar9 + 1) = (char)(uVar2 >> 8);
    *(char *)((int)puVar9 + 2) = (char)(uVar2 >> 0x10);
    *(char *)((int)puVar9 + 3) = (char)(uVar2 >> 0x18);
    memw();
    puVar9 = puVar9 + 1;
    if (efuse_raw == puVar9) break;
    uVar2 = *puVar11;
  }
  *efuse_result = burn_value[0];
  memw();
  return;
}



// WARNING: Unknown calling convention

u8 write_usermac_to_efuse(u32 mac_upper,u32 mac_lower)

{
  u8 uVar1;
  uint uVar2;
  int iVar3;
  u8 *puVar4;
  u8 crc_calc;
  u8 *puVar5;
  u8 *puVar6;
  byte *pbVar7;
  uint uVar8;
  u8 wr_efuse_val [32];
  u8 all_bytes [24];
  u8 macaddr [6];
  byte abStack_32 [2];
  uint uStack_30;
  u8 *puStack_2c;
  
  puVar6 = wr_efuse_val;
  wr_data[0x18] = '\x01';
  wr_en[0x18] = '\x03';
  memw();
  burn_efuse(wr_data,wr_en);
  wr_data[0x18] = '\0';
  wr_en[0x18] = '\0';
  memw();
  uVar2 = esp_dport_access_reg_read(0x3ff5a018);
  if ((uVar2 & 3) == 1) {
    uStack_30 = mac_lower >> 0x10 & 0xff;
    wr_data[0x62] = (u8)mac_lower;
    wr_data[0x61] = (u8)(mac_lower >> 8);
    uVar8 = mac_upper >> 8 & 0xff;
    wr_data[0x5e] = (u8)mac_upper;
    uVar2 = 0;
    pbVar7 = macaddr;
    macaddr[5] = wr_data[0x62];
    macaddr[4] = wr_data[0x61];
    wr_data[0x60] = (u8)(mac_lower >> 0x10);
    macaddr[3] = wr_data[0x60];
    wr_data[0x5f] = (u8)(mac_lower >> 0x18);
    macaddr[2] = wr_data[0x5f];
    macaddr[1] = wr_data[0x5e];
    wr_data[0x5d] = (u8)(mac_upper >> 8);
    macaddr[0] = wr_data[0x5d];
    memw();
    while( true ) {
      pbVar7 = pbVar7 + 1;
      uVar8 = uVar8 ^ uVar2;
      if ((uVar8 & 1) == 0) {
        uVar2 = uVar8 >> 1;
      }
      else {
        uVar2 = (uVar8 >> 1 ^ 0xffffff8c) & 0xff;
      }
      if (pbVar7 == abStack_32) break;
      uVar8 = (uint)*pbVar7;
    }
    wr_data[0x5c] = (u8)uVar2;
    memw();
    puVar5 = all_bytes;
    memw();
    pbVar7 = wr_data + 0x5d;
    wr_data[0x73] = '\x01';
    while( true ) {
      *puVar5 = (u8)uVar2;
      memw();
      puVar5 = puVar5 + 1;
      if (pbVar7 == wr_data + 0x74) break;
      uVar2 = (uint)*pbVar7;
      pbVar7 = pbVar7 + 1;
    }
    make_efuse(all_bytes,wr_efuse_val);
    puVar4 = wr_data + 0x5c;
    iVar3 = 0x20;
    puVar5 = wr_en + 0x5c;
    do {
      uVar1 = *puVar6;
      puVar6 = puVar6 + 1;
      *puVar4 = uVar1;
      puVar4 = puVar4 + 1;
      *puVar5 = 0xff;
      memw();
      puVar5 = puVar5 + 1;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    puStack_2c = wr_data + 0x5c;
    uVar1 = burn_efuse(wr_data,wr_en);
  }
  else {
    puStack_2c = wr_data + 0x5c;
    uVar1 = '\x04';
  }
  *puStack_2c = '\0';
  wr_en[0x5c] = '\0';
  memw();
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void Vsar2_pwc_mea_ate(u32 bias,u8 pad)

{
  uint uVar1;
  
  _DAT_3ff48078 = esp_dport_access_reg_read(&DAT_3ff48078);
  _DAT_3ff48078 = _DAT_3ff48078 & 0xfcffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  _DAT_3ff4807c = uVar1 & 0xf1ffffff | (bias & 7) << 0x19;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  _DAT_3ff4807c = uVar1 & 0xfe3fffff | (bias & 7) << 0x16;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff480a8);
  _DAT_3ff480a8 = uVar1 & 0x3fffffff | 0x40000000;
  memw();
  _DAT_3ff480a8 = esp_dport_access_reg_read(&DAT_3ff480a8);
  _DAT_3ff480a8 = _DAT_3ff480a8 | 0x20000000;
  memw();
  _DAT_3ff4882c = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = _DAT_3ff4882c | 0x10;
  memw();
  _DAT_3ff4880c = esp_dport_access_reg_read(&DAT_3ff4880c);
  _DAT_3ff4880c = _DAT_3ff4880c | 0xc0000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48894);
  _DAT_3ff48894 = (1 << 0x20 - (0x20 - (pad & 0x1f)) & 0xfffU) << 0x13 | uVar1 & 0x8007ffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48894);
  memw();
  _DAT_3ff48894 = uVar1 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void DIG_pwc_mea_ate(u32 bias,u8 pad)

{
  uint uVar1;
  
  _DAT_3ff48078 = esp_dport_access_reg_read(&DAT_3ff48078);
  _DAT_3ff48078 = _DAT_3ff48078 & 0xfcffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  _DAT_3ff4807c = uVar1 & 0xffffc7ff | (bias & 7) << 0xb;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  _DAT_3ff4807c = uVar1 & 0xfffff8ff | (bias & 7) << 8;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff480a8);
  _DAT_3ff480a8 = uVar1 & 0x3fffffff | 0x80000000;
  memw();
  _DAT_3ff480a8 = esp_dport_access_reg_read(&DAT_3ff480a8);
  _DAT_3ff480a8 = _DAT_3ff480a8 | 0x20000000;
  memw();
  _DAT_3ff4882c = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = _DAT_3ff4882c | 0x10;
  memw();
  _DAT_3ff4880c = esp_dport_access_reg_read(&DAT_3ff4880c);
  _DAT_3ff4880c = _DAT_3ff4880c | 0xc0000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48894);
  _DAT_3ff48894 = (1 << 0x20 - (0x20 - (pad & 0x1f)) & 0xfffU) << 0x13 | uVar1 & 0x8007ffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48894);
  memw();
  _DAT_3ff48894 = uVar1 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void RTC_pwc_mea_ate(u32 bias,u8 pad)

{
  uint uVar1;
  
  _DAT_3ff48078 = esp_dport_access_reg_read(&DAT_3ff48078);
  _DAT_3ff48078 = _DAT_3ff48078 & 0xfcffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  _DAT_3ff4807c = uVar1 & 0xf1ffffff | (bias & 7) << 0x19;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  _DAT_3ff4807c = uVar1 & 0xfe3fffff | (bias & 7) << 0x16;
  memw();
  _DAT_3ff480a8 = esp_dport_access_reg_read(&DAT_3ff480a8);
  _DAT_3ff480a8 = _DAT_3ff480a8 & 0x3fffffff;
  memw();
  _DAT_3ff480a8 = esp_dport_access_reg_read(&DAT_3ff480a8);
  _DAT_3ff480a8 = _DAT_3ff480a8 | 0x20000000;
  memw();
  _DAT_3ff4882c = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = _DAT_3ff4882c | 0x10;
  memw();
  _DAT_3ff4880c = esp_dport_access_reg_read(&DAT_3ff4880c);
  _DAT_3ff4880c = _DAT_3ff4880c | 0xc0000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48894);
  _DAT_3ff48894 = (1 << 0x20 - (0x20 - (pad & 0x1f)) & 0xfffU) << 0x13 | uVar1 & 0x8007ffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48894);
  memw();
  _DAT_3ff48894 = uVar1 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void clr_pwc_mea(void)

{
  uint uVar1;
  
  _DAT_3ff48078 = esp_dport_access_reg_read(&DAT_3ff48078);
  _DAT_3ff48078 = _DAT_3ff48078 | 0x3000000;
  memw();
  _DAT_3ff480a8 = esp_dport_access_reg_read(&DAT_3ff480a8);
  _DAT_3ff480a8 = _DAT_3ff480a8 & 0x3fffffff;
  memw();
  _DAT_3ff480a8 = esp_dport_access_reg_read(&DAT_3ff480a8);
  _DAT_3ff480a8 = _DAT_3ff480a8 & 0xdfffffff;
  memw();
  _DAT_3ff4882c = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = _DAT_3ff4882c & 0xffffffef;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4880c);
  memw();
  _DAT_3ff4880c = uVar1 & 0xfff3ffff;
  return;
}



// WARNING: Unknown calling convention

void delay_ns(uint n_ns)

{
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void tx_add_pocketnum(void)

{
  char cVar1;
  u16 uVar2;
  u32 uVar3;
  ushort uVar4;
  uchar *packet0;
  
  uVar3 = PSDU0_OFFSET;
  uVar2 = rx_ack_num;
  cVar1 = (char)tx_pocket_num;
  if (tx_pocket_num == 0) {
    uVar4 = 1;
    rx_ack_num = tx_pocket_num;
    *(char *)(PSDU0_OFFSET + 0x16) = cVar1;
    *(char *)(uVar3 + 0x17) = cVar1;
    *(char *)(uVar3 + 0x20) = cVar1;
    *(char *)(uVar3 + 0x21) = cVar1;
  }
  else {
    uVar4 = tx_pocket_num + 1;
    *(char *)(PSDU0_OFFSET + 0x21) = (char)rx_ack_num;
    memw();
    *(char *)(uVar3 + 0x16) = cVar1 << 4;
    *(char *)(uVar3 + 0x17) = (char)(tx_pocket_num >> 4);
    *(char *)(uVar3 + 0x20) = (char)(uVar2 >> 8);
    memw();
    if (0xfff < uVar4) {
      tx_pocket_num = 0;
      memw();
      return;
    }
  }
  tx_pocket_num = uVar4;
  memw();
  return;
}



// WARNING: Unknown calling convention

sint16 get_temp_cal_wifi(void)

{
  byte bVar1;
  int iVar2;
  uint8 temp_meas;
  
  bVar1 = tsens_code_read();
  iVar2 = (int)(short)((ushort)bVar1 - (ushort)btpwr_tsen_init);
  if (iVar2 < 1) {
    iVar2 = (int)(short)((short)((ulonglong)((longlong)iVar2 * 0x55555556) >> 0x20) -
                        ((short)((ushort)bVar1 - (ushort)btpwr_tsen_init) >> 0xf));
    if (iVar2 < -0x18) {
      chip7_sleep_params.loop_pwctrl_correct_power_qdb = -0x18;
      iVar2 = -0x18;
      goto LAB_0002df66;
    }
  }
  else {
    iVar2 = iVar2 >> 2;
    chip7_sleep_params.loop_pwctrl_correct_power_qdb = '\x18';
    if (0x18 < iVar2) {
      iVar2 = 0x18;
      goto LAB_0002df66;
    }
  }
  chip7_sleep_params.loop_pwctrl_correct_power_qdb = (S8)iVar2;
LAB_0002df66:
  memw();
  tx_gain_table_set();
  if (phy_tx_pwr_print_en != false) {
    phy_printf("1 init_temp=%d,temp_meas=%d,temp_cal=%d, atten_cal=%d\n",btpwr_tsen_init,bVar1,iVar2
               ,(int)chip7_sleep_params.loop_pwctrl_correct_atten);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void tx_a_frame(uint queue)

{
  uint *puVar1;
  uint *puVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  STATUS SVar8;
  uint32_t timer0;
  
  puVar1 = (uint *)Plcp0AddrGet(queue);
  puVar2 = (uint *)ConfAddrGet(queue);
  tx_add_pocketnum();
  memw();
  _DAT_60033c10 = 0x40000002;
  _DAT_60033c40 = esp_dport_access_reg_read(&DAT_60033c40);
  _DAT_60033c40 = _DAT_60033c40 | 2;
  memw();
  _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
  _DAT_60033c4c = _DAT_60033c4c | 3;
  memw();
  uVar3 = esp_dport_access_reg_read(puVar2);
  memw();
  *puVar2 = uVar3 & 0xffc00fff | 0x1000;
  uVar3 = esp_dport_access_reg_read(puVar1);
  memw();
  *puVar1 = uVar3 | 0xc0000000;
  iVar4 = esp_dport_access_reg_read(&DAT_60033c00);
  do {
    while( true ) {
      memw();
      if ((_DAT_60033c48 & 2) != 0) {
        return;
      }
      flash_test_run(0x80);
      if (tx_contin_fcc_en != false) break;
      iVar5 = esp_dport_access_reg_read(&DAT_60033c00);
      if (499999 < (uint)(iVar5 - iVar4)) {
        phy_printf("tx is blocked! ");
        uVar6 = esp_dport_access_reg_read(puVar1);
        uVar7 = esp_dport_access_reg_read(puVar2);
        phy_printf("plcp0:0x%x conf:0x%x\n",uVar6,uVar7);
        uVar6 = esp_dport_access_reg_read(&DAT_60033cc0);
        uVar7 = esp_dport_access_reg_read(&DAT_60033cb8);
        phy_printf("col:0x%x block:0x%x\n",uVar6,uVar7);
        return;
      }
    }
    if (phy_tx_pwr_track_en != false) {
      get_temp_cal_wifi();
      phy_ofdm_bandage_opt((uint8)test_tx_rate,'\0',(bool)(undefined)test_tx_cbw40);
      ets_delay_us(60000);
    }
    SVar8 = GetStopCmd();
  } while (SVar8 != OK);
  _DAT_3ff5c458 = esp_dport_access_reg_read(&DAT_3ff5c458);
  _DAT_3ff5c458 = _DAT_3ff5c458 & 0xffefffff;
  memw();
  uVar3 = esp_dport_access_reg_read(&DAT_3ff5c400);
  memw();
  _DAT_3ff5c400 = uVar3 & 0xffdfffff;
  return;
}



// WARNING: Unknown calling convention

void test_tx_frame(uint queue,uint tx_rate,uint tx_num,uint tx_ext_idle_us,uint tx_cbw40,uint ht_dup
                  )

{
  uint *puVar1;
  uint *puVar2;
  uint uVar3;
  
  puVar1 = (uint *)Plcp1AddrGet(queue);
  puVar2 = (uint *)HTsigAddrGet(queue);
  test_tx_rate = tx_rate;
  test_tx_cbw40 = tx_cbw40;
  if ((tx_rate < 0x10) || (lr_enable == true)) {
    uVar3 = esp_dport_access_reg_read(puVar1);
    memw();
    *puVar1 = (tx_rate & 0x1f) << 0xc | uVar3 & 0xfffe0fff;
    uVar3 = esp_dport_access_reg_read(puVar1);
    memw();
    *puVar1 = uVar3 & 0xf9ffffff;
  }
  else {
    uVar3 = esp_dport_access_reg_read();
    memw();
    *puVar1 = uVar3 & 0xfffe0fff | 0xb000;
    uVar3 = esp_dport_access_reg_read(puVar1);
    memw();
    *puVar1 = uVar3 & 0xf9ffffff | 0x2000000;
    uVar3 = esp_dport_access_reg_read(puVar2);
    memw();
    *puVar2 = uVar3 & 0xfffffff0 | tx_rate & 0xf;
  }
  uVar3 = esp_dport_access_reg_read(puVar1);
  memw();
  *puVar1 = (ht_dup & 1) << 0x1a | uVar3 & 0xfbffffff;
  uVar3 = esp_dport_access_reg_read(puVar2);
  memw();
  *puVar2 = (tx_cbw40 & 1) << 7 | uVar3 & 0xffffff7f;
  uVar3 = 0;
  if (tx_num != 0) {
    do {
      tx_a_frame(queue);
      if (phy_tx_pwr_track_en == false) {
        wifi_track_pll_cap();
      }
      else {
        tx_pwctrl_background(phy_tx_pwr_correct_en,phy_tx_pwr_print_en);
        phy_ofdm_bandage_opt
                  ((uint8)tx_rate,(sint8)chip7_sleep_params.loop_pwctrl_correct_atten,
                   SUB41(tx_cbw40,0));
        phy_temp_track((uint8)tx_rate);
      }
      uVar3 = uVar3 + 1;
      ets_delay_us(tx_ext_idle_us & 0xffff);
    } while (uVar3 != tx_num);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_mac_filter(u32 mac_lower,u32 mac_upper)

{
  memw();
  _DAT_60033040 = mac_lower;
  memw();
  _DAT_60033044 = mac_upper;
  memw();
  _DAT_600330dc = 0xf;
  memw();
  _DAT_600330e0 = 0xf;
  memw();
  _DAT_600330e4 = 0xf;
  memw();
  _DAT_60033060 = 0xffffffff;
  memw();
  _DAT_60033064 = 0x1ffff;
  return;
}



// WARNING: Unknown calling convention

sint16 get_rx_freq_local(void)

{
  sint16 freq_offset1;
  sint16 sVar1;
  uint uVar2;
  int iVar3;
  uint *puVar4;
  byte rate;
  
  uVar2 = esp_dport_access_reg_read(0x60033098);
  if ((uVar2 + 0xc0060000 < 0x60001) && ((uVar2 & 3) == 0)) {
    iVar3 = esp_dport_access_reg_read(uVar2 + 4);
    uVar2 = esp_dport_access_reg_read(&DAT_60033080);
    puVar4 = (uint *)((uVar2 & 0xff) + iVar3);
    uVar2 = *puVar4;
    rate = (byte)(uVar2 >> 8) & 0x1f;
    if ((uVar2 & 0xc000) != 0) {
      rate = ((byte)(uVar2 >> 0xe) & 3) * '\x10' + ((byte)puVar4[1] & 0x7f);
    }
    sVar1 = phy_get_rx_freq(rate,puVar4[4]);
    return sVar1;
  }
  phy_printf("rxlink_addr=0x%x\n",uVar2);
  return 0;
}



// WARNING: Unknown calling convention

bool esp_get_rx_result(int32 *rx_result)

{
  *rx_result = esp_rx_result[0];
  rx_result[1] = esp_rx_result[1];
  rx_result[2] = esp_rx_result[2];
  return esp_rx_valid;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void do_rx_poll(uint rx_rate_in)

{
  uint uVar1;
  sint16 sVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  STATUS SVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  int iVar11;
  undefined4 *puVar12;
  uint uVar13;
  undefined4 *puVar14;
  undefined4 *puVar15;
  int iVar16;
  int iVar17;
  undefined4 *puVar18;
  uint err_gain [100];
  uint err_dt [100];
  uint err_timer [100];
  uint err_code [100];
  sint16 bb_freq [4];
  int local_a0;
  int local_9c;
  int local_98;
  int local_94;
  int local_90;
  uint local_88;
  uint local_84;
  int local_7c;
  int local_74;
  int local_70;
  int local_68;
  int local_60;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  
  uVar1 = rx_rate_in >> 0x18;
  uVar9 = rx_rate_in & 0xffff;
  iVar16 = (uVar1 - 0x100) * 10;
  err_code[0] = 0;
  err_timer[0] = 0;
  err_dt[0] = 0;
  err_gain[0] = 0;
  bb_freq[0] = 0;
  esp_rx_valid = false;
  memw();
  _DAT_600330f8 = esp_dport_access_reg_read(&DAT_600330f8);
  _DAT_600330f8 = _DAT_600330f8 | 0xffff0000;
  memw();
  _DAT_60033080 = esp_dport_access_reg_read(&DAT_60033080);
  _DAT_60033080 = _DAT_60033080 & 0xefffffff;
  memw();
  memw();
  _DAT_60033800 = 0;
  memw();
  _DAT_60033c08 = 0;
  _DAT_60033c0c = esp_dport_access_reg_read(&DAT_60033c0c);
  _DAT_60033c0c = _DAT_60033c0c | 0x80000000;
  memw();
  _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
  _DAT_60033c4c = _DAT_60033c4c | 0xc;
  memw();
  uVar3 = esp_dport_access_reg_read(&DAT_3ff5c018);
  iVar11 = 0;
  iVar7 = ((uVar3 >> 5 & 0x3ff) - 0x400) * 10;
  if (iVar7 < 0) {
    iVar7 = iVar7 + 3;
  }
  iVar7 = iVar7 >> 2;
  local_50 = 0;
  local_54 = 0;
  local_58 = 0;
  local_4c = 0;
  local_3c = 0;
  local_38 = 0;
  local_48 = 0;
  local_44 = 0;
  local_40 = 0;
  local_34 = 0;
  local_74 = 0;
  local_9c = 0;
  local_5c = -0x500;
  iVar8 = 0;
  local_88 = 0;
  local_a0 = 0;
  local_68 = 0;
  local_60 = 0;
  local_94 = 0;
  local_90 = 0;
  local_98 = 0;
  local_7c = 0;
  local_70 = 0;
  do {
    flash_test_run(1);
    uVar3 = esp_dport_access_reg_read(&DAT_60033c48);
    uVar4 = esp_dport_access_reg_read(0x600330a4);
    if ((uVar3 & 4) == 0) {
      if ((uVar3 & 8) != 0) {
        uVar3 = esp_dport_access_reg_read(0x3ff5c06c);
        local_84 = uVar3 & 0xff;
        _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
        _DAT_60033c4c = _DAT_60033c4c | 8;
        memw();
        if (local_9c < 5) {
          ets_delay_us(0x1e);
          esp_dport_access_reg_read(0x3ff5cc5c);
        }
      }
    }
    else {
      if (iVar8 < 100) {
        uVar5 = uVar4 & 0xff;
        err_code[iVar8] = uVar5;
        uVar3 = esp_dport_access_reg_read(&DAT_60033c00);
        err_timer[iVar8] = uVar3;
        err_dt[iVar8] = uVar3 - local_88;
        err_gain[iVar8] = local_84;
        if ((uVar5 == 0) || (uVar5 == 0x41 || uVar5 == 0)) {
          local_88 = uVar3;
        }
        iVar8 = iVar8 + 1;
        esp_dport_access_reg_read(0x600330a8);
      }
      uVar4 = uVar4 & 0xff;
      if (uVar4 == 0) {
        uVar4 = esp_dport_access_reg_read(0x600330a8);
        uVar5 = esp_dport_access_reg_read(0x600330ac);
        uVar13 = uVar4 >> 0x16 & 3;
        uVar3 = uVar4 >> 0x18;
        uVar4 = uVar4 >> 0x10 & 0x1f;
        if (uVar13 != 0) {
          uVar4 = uVar5 & 0xf | 0x10;
        }
        if (0x7f < uVar3) {
          uVar3 = uVar3 - 0x100;
        }
        local_90 = local_90 + 1;
        if (uVar9 == (uVar13 << 4 | uVar4)) {
          iVar10 = uVar3 * 10 + iVar7;
          uVar3 = esp_dport_access_reg_read(&DAT_3ff5c104);
          if (((uVar3 & 0x8000) == 0) && (chip7_sleep_params.ht40_mode_cfg != '\0')) {
            if (uVar9 < 8) {
              iVar10 = iVar10 + -10;
            }
            else if ((0xf < uVar9) && ((uVar5 >> 7 & 1) != 0)) {
              iVar10 = iVar10 + 0x1e;
            }
          }
          local_98 = local_98 + 1;
          local_88 = esp_dport_access_reg_read(&DAT_60033c00);
          sVar2 = get_rx_freq_local();
          iVar17 = (int)(short)((short)local_74 + 1);
          bb_freq[local_74] = sVar2;
          memw();
          local_7c = local_7c + local_84;
          local_68 = local_68 + iVar10;
          local_60 = (uint)(local_60 < iVar10) * local_60 + (uint)(local_60 >= iVar10) * iVar10;
          local_5c = (uint)(local_5c < iVar10) * iVar10 + (uint)(local_5c >= iVar10) * local_5c;
          if (iVar17 == 4) {
            iVar17 = 0;
          }
          local_74 = iVar17;
          if (iVar10 < iVar16 + -0x2d) {
            if (iVar10 < iVar16 + -0x37) {
LAB_0002e99c:
              if ((iVar10 < iVar16 + -0x23) || (iVar16 + -0x19 <= iVar10)) {
                if ((iVar10 < iVar16 + -0x19) || (iVar16 + -0xf <= iVar10)) {
                  if ((iVar10 < iVar16 + -0xf) || (iVar16 + -5 <= iVar10)) {
                    if ((iVar10 < iVar16 + -5) || (iVar16 + 4 < iVar10)) {
                      if ((iVar16 + 4 < iVar10) && (iVar10 <= iVar16 + 0xe)) {
                        local_4c = local_4c + 1;
                      }
                      else if ((iVar16 + 0xe < iVar10) && (iVar10 <= iVar16 + 0x18)) {
                        local_58 = local_58 + 1;
                      }
                      else if ((iVar16 + 0x18 < iVar10) && (iVar10 <= iVar16 + 0x22)) {
                        local_54 = local_54 + 1;
                      }
                      else if ((iVar16 + 0x22 < iVar10) && (iVar10 <= iVar16 + 0x2c)) {
                        local_50 = local_50 + 1;
                      }
                      else if ((iVar10 <= iVar16 + 0x36) && (iVar16 + 0x2c < iVar10)) {
                        local_70 = local_70 + 1;
                      }
                    }
                    else {
                      local_48 = local_48 + 1;
                    }
                  }
                  else {
                    local_44 = local_44 + 1;
                  }
                }
                else {
                  local_40 = local_40 + 1;
                }
              }
              else {
                local_3c = local_3c + 1;
              }
            }
            else {
              local_34 = local_34 + 1;
            }
          }
          else {
            if (iVar16 + -0x23 <= iVar10) goto LAB_0002e99c;
            local_38 = local_38 + 1;
          }
        }
        else {
          local_94 = local_94 + 1;
        }
      }
      else {
        iVar11 = iVar11 + 1;
        if (uVar4 == 0x80) {
          local_94 = local_94 + 1;
        }
        else {
          local_a0 = local_a0 + (uint)(uVar4 == 0x41);
        }
        if ((local_9c < 5) && (uVar1 == uVar4)) {
          local_9c = local_9c + 1;
          esp_dport_access_reg_read(0x600330a8);
          esp_dport_access_reg_read(0x600330a8);
        }
      }
      _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
      _DAT_60033c4c = _DAT_60033c4c | 0xc;
      memw();
    }
    SVar6 = GetStopCmd();
    if (SVar6 == OK) {
      _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
      _DAT_60033c4c = _DAT_60033c4c | 0xc;
      memw();
      bb_wdt_rst_enable(false);
      if (local_98 == 0) {
        esp_rx_result[1] = 0;
        iVar16 = 0;
      }
      else {
        iVar16 = (local_7c * 10) / local_98;
        esp_rx_result[1] = local_68 / local_98;
      }
      esp_rx_valid = true;
      memw();
      esp_rx_result[0] = local_98;
      esp_rx_result[2] = local_90;
      if ((rx_rate_in >> 0x11 & 1) == 0) {
        if (short_log_en == false) {
          phy_printf("Correct: %d Desired: %d RSSI: %d noise: %d gain: %d para1: %d para2: %d freq: %d "
                     ,local_90,local_98,esp_rx_result[1],iVar7,iVar16,iVar11,local_a0,
                     (int)bb_freq[0]);
        }
        else {
          phy_printf("rx_num: %d rx_rssi: %d\n",local_98,esp_rx_result[1]);
        }
        if (rssi_min_max_print != false) {
          phy_printf("rssi_min: %d rssi_max: %d ",local_60,local_5c);
        }
        if (uVar1 != 0) {
          phy_printf("rssi_base_p5: %d rssi_base_p4: %d rssi_base_p3: %d rssi_base_p2: %d rssi_base_p1: %d rssi_base_n0: %d rssi_base_n1: %d rssi_base_n2: %d rssi_base_n3: %d rssi_base_n4: %d rssi_base_n5: %d "
                     ,local_34,local_38,local_3c,local_40,local_44,local_48,local_4c,local_58,
                     local_54,local_50,local_70,0);
        }
        phy_printf(&DAT_0005507c);
        return;
      }
      phy_printf("Correct: %d Desired: %d RSSI: %d gain: %d noise: %d err: %d err_fcs: %d err_a1: %d gooddata: %d, freq: %d"
                 ,local_90,local_98,esp_rx_result[1],iVar16,iVar7,iVar11,local_a0,local_94,0,
                 (int)bb_freq[0]);
      iVar7 = 0;
      iVar11 = 0;
      if (iVar8 != 0) {
        do {
          puVar18 = (undefined4 *)((int)err_gain + iVar7);
          puVar15 = (undefined4 *)((int)err_dt + iVar7);
          puVar14 = (undefined4 *)((int)err_timer + iVar7);
          puVar12 = (undefined4 *)((int)err_code + iVar7);
          iVar11 = iVar11 + 1;
          iVar7 = iVar7 + 4;
          phy_printf("err=0x%x,t=%d,gain=%d,dt=%d;#",*puVar12,*puVar14,*puVar18,*puVar15);
        } while (iVar8 != iVar11);
      }
      phy_printf("print done!\n");
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

int rx_data_check(uint RX_buff_start,uint rxrate)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint *puVar7;
  uint packet_word_len;
  
  uVar1 = RX_buff_start & 0xffff;
  if (rxrate < 0x10) {
    uVar2 = *(ushort *)(uVar1 + 2) & 0xfff;
  }
  else {
    uVar2 = *(uint *)(uVar1 + 4) >> 8 & 0xffff;
  }
  puVar7 = (uint *)(uVar1 + 0xc);
  if (uVar2 >> 2 == 1) {
    iVar6 = 0;
LAB_0002ee7e:
    if (((uVar2 & 3) == 0) ||
       (uVar1 = iVar6 * 4,
       (((uVar1 + 3) * 0x1000000 + (uVar1 & 0xff) + (uVar1 + 2 & 0xff) * 0x10000 +
         ((uVar1 + 1) * 0x100 & 0xffff) ^ *puVar7) & (1 << 0x20 - ((uVar2 & 3) * -8 + 0x20)) - 1U)
       == 0)) {
      return 1;
    }
  }
  else {
    iVar6 = 0;
    uVar5 = 6;
    if (*(int *)(uVar1 + 0xc) == 0x3020100) {
      do {
        iVar4 = uVar5 + 1;
        iVar6 = iVar6 + 1;
        uVar1 = uVar5 & 0xff;
        iVar3 = uVar5 - 1;
        *puVar7 = 0;
        puVar7 = puVar7 + 1;
        if ((uVar2 >> 2) - 1 == iVar6) goto LAB_0002ee7e;
        uVar5 = uVar5 + 4;
      } while (iVar4 * 0x1000000 + (iVar6 * 4 & 0xffU) + uVar1 * 0x10000 + (iVar3 * 0x100 & 0xffffU)
               == *puVar7);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void read_macaddr_from_otp(uint8 *macaddr)

{
  undefined2 uVar1;
  undefined4 uVar2;
  u32 efuse16;
  u32 efuse17;
  
  uVar2 = esp_dport_access_reg_read(0x3ff5a004);
  uVar1 = esp_dport_access_reg_read(0x3ff5a008);
  *macaddr = (uint8)((ushort)uVar1 >> 8);
  macaddr[1] = (uint8)uVar1;
  macaddr[2] = (uint8)((uint)uVar2 >> 0x18);
  macaddr[3] = (uint8)((uint)uVar2 >> 0x10);
  macaddr[4] = (uint8)((uint)uVar2 >> 8);
  macaddr[5] = (uint8)uVar2;
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void fill_txaddr(void)

{
  u8 mac_addr [6];
  
  read_macaddr_from_otp(mac_addr);
  memw();
  DAT_60033040 = mac_addr[0];
  DAT_60033040_1._0_1_ = mac_addr[1];
  DAT_60033040_1._1_1_ = mac_addr[2];
  DAT_60033040_1._2_1_ = mac_addr[3];
  memw();
  _DAT_60033044 = (uint)(ushort)mac_addr._4_2_;
  return;
}



// WARNING: Unknown calling convention

uint32_t fill_txdataframe(int cmd,int data_length,uint32_t addr0lo,uint32_t addr0hi,
                         uint32_t key_word,uint32_t *rate,uint32_t *gi_bit,u32 tx_rate_in)

{
  uint *puVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  undefined4 uVar6;
  u32 uVar7;
  uint32_t uVar8;
  uint uVar9;
  uint psdu1_len;
  uint psdu2_len;
  uint32 uStack_40;
  uint uStack_3c;
  
  puVar1 = (uint *)Plcp0AddrGet(10);
  puVar2 = (uint *)ConfAddrGet(10);
  uVar3 = esp_dport_access_reg_read(&DAT_60033040);
  uVar4 = esp_dport_access_reg_read(&DAT_60033044);
  uVar7 = ate_gi_bit;
  if (cmd == 6) {
    uVar5 = 0;
    *rate = 0xb;
    uStack_40 = 0;
    *gi_bit = 0;
    goto LAB_0002f0c6;
  }
  uStack_40 = 0;
  uVar8 = 0xb;
  if (cmd == 5) {
LAB_0002f038:
    *rate = uVar8;
    *gi_bit = uStack_40;
    uVar5 = 0x3000000;
  }
  else if (cmd == 4) {
    *rate = 8;
    uVar5 = 0;
    uStack_40 = 0;
    *gi_bit = 0;
  }
  else {
    if (cmd == 3) {
      uStack_40 = 1;
      uVar8 = 0x16;
      goto LAB_0002f038;
    }
    if (cmd == 2) {
      *rate = ate_rate;
      uStack_40 = uVar7;
      *gi_bit = uVar7;
      uVar5 = 0x3000000;
    }
    else if (cmd == 1) {
      *rate = test_tx_rate;
      uStack_40 = 0;
      uVar5 = 0x1000000;
      *gi_bit = 0;
    }
    else {
      *rate = 0x17;
      *gi_bit = 1;
      uStack_40 = 1;
      uVar5 = 0x1000000;
    }
  }
  data_length = data_length + 0x28;
LAB_0002f0c6:
  uVar9 = 0x800;
  if (data_length < 0x801) {
    psdu2_len = 0;
    psdu1_len = 0;
    uVar9 = data_length;
  }
  else if (data_length < 0xe01) {
    psdu1_len = data_length - 0x800;
    psdu2_len = 0;
  }
  else if (data_length < 0xf01) {
    psdu2_len = data_length - 0xe00;
    psdu1_len = 0x600;
  }
  else if (data_length < 0x1001) {
    psdu2_len = data_length - 0xf00;
    psdu1_len = 0x600;
  }
  else {
    psdu2_len = 0;
    psdu1_len = 0;
    uVar9 = 0;
  }
  if (tx_rate_in == 0xff) {
    tx_rate_in = *rate;
  }
  fill_tx_frame(10,tx_rate_in,data_length,uVar9,psdu1_len,psdu2_len,0,0,0,TXBUF_START,uStack_40,0,0,
                0,0,0,0);
  uVar9 = esp_dport_access_reg_read(puVar1);
  memw();
  *puVar1 = uVar9 & 0xf8ffffff | uVar5;
  uVar5 = esp_dport_access_reg_read(puVar2);
  memw();
  *puVar2 = uVar5 & 0xffc00fff | 0x1000;
  uVar7 = PSDU0_OFFSET;
  if (cmd == 6) {
    uVar9 = addr0hi & 0xffff | uVar3 << 0x10;
    uVar5 = uVar4 << 0x10 | uVar3 >> 0x10;
    uStack_3c = uVar4 & 0xffff | 0x5d800000;
    uVar6 = 0x80;
  }
  else {
    uVar9 = addr0hi & 0xffff | uVar3 << 0x10;
    uVar5 = uVar4 << 0x10 | uVar3 >> 0x10;
    uVar6 = 0xfa0008;
  }
  memw();
  *(undefined4 *)PSDU0_OFFSET = uVar6;
  memw();
  *(uint32_t *)(uVar7 + 4) = addr0lo;
  memw();
  *(uint *)(uVar7 + 8) = uVar9;
  memw();
  *(uint *)(uVar7 + 0xc) = uVar5;
  memw();
  *(uint *)(uVar7 + 0x10) = uVar3;
  memw();
  *(uint *)(uVar7 + 0x14) = uStack_3c;
  memw();
  *(undefined4 *)(uVar7 + 0x18) = 0xa0431;
  memw();
  *(undefined4 *)(uVar7 + 0x1c) = 0;
  memw();
  *(uint32_t *)(uVar7 + 0x20) = key_word;
  if (cmd == 6) {
    uVar3 = esp_dport_access_reg_read(0x60035144);
    uVar4 = esp_dport_access_reg_read(puVar2);
    memw();
    *puVar2 = uVar4 & 0xf0ffffff | 0x1000000;
    uVar4 = esp_dport_access_reg_read(puVar2);
    uVar7 = PSDU0_OFFSET;
    memw();
    *puVar2 = (uVar3 & 0x49) << 0xc | uVar4 & 0xffc00fff;
  }
  return uVar7 + 0x24;
}



// WARNING: Unknown calling convention

void fill_txbeacon(u8 *byte0,u8 *byte1,u8 *byte2,u32 *byte128,u8 *byte_m)

{
  undefined4 *puVar1;
  uint32_t gi_bit;
  uint32_t rate;
  
  fill_txaddr();
  puVar1 = (undefined4 *)fill_txdataframe(6,0xd4,0xffffffff,0xffff,0,&rate,&gi_bit,0xff);
  memw();
  *puVar1 = 0x53450700;
  memw();
  puVar1[1] = 0x36323850;
  memw();
  puVar1[2] = 0x82080136;
  memw();
  puVar1[3] = 0xc968b84;
  memw();
  puVar1[4] = 0x3241812;
  memw();
  puVar1[5] = 0x4050b01;
  memw();
  puVar1[6] = 0x200;
  memw();
  puVar1[7] = 0x48300432;
  memw();
  puVar1[8] = 0x88dd6c60;
  memw();
  puVar1[9] = 0xff34fe18;
  memw();
  puVar1[10] = CONCAT12(*byte2,CONCAT11(*byte1,*byte0)) | 0xff000000;
  memw();
  puVar1[0xb] = *(undefined4 *)byte_m;
  memw();
  puVar1[0xc] = *(undefined4 *)(byte_m + 4);
  memw();
  puVar1[0xd] = *(undefined4 *)(byte_m + 8);
  memw();
  puVar1[0xe] = byte_m[0xc] | 0x55550000 | (uint)byte_m[0xd] << 8;
  memw();
  puVar1[0xf] = 0x55555555;
  memw();
  puVar1[0x10] = *byte128;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void setmacaddr(uint32_t da_lo,uint32_t da_hi)

{
  memw();
  _DAT_60033040 = da_lo;
  memw();
  _DAT_60033044 = da_hi;
  return;
}



// WARNING: Unknown calling convention

void settxframe_chipid(uint32_t txdata_addr,uint32_t chip_id_lo,uint32_t chip_id_hi)

{
  uint uVar1;
  
  memw();
  *(uint32_t *)(txdata_addr - 0x20) = chip_id_lo;
  uVar1 = esp_dport_access_reg_read((uint *)(txdata_addr - 0x1c));
  memw();
  *(uint *)(txdata_addr - 0x1c) = uVar1 & 0xffff0000 | chip_id_hi & 0xffff;
  return;
}



// WARNING: Unknown calling convention

void settxframe_rate(uint32_t plcp1_addr,uint32_t htsig_addr,uint32_t len,uint32_t rate)

{
  uint uVar1;
  
  if (0x10 < rate) {
    uVar1 = esp_dport_access_reg_read(plcp1_addr);
    memw();
    *(uint *)plcp1_addr = uVar1 & 0xf9ffffff | 0x2000000;
    memw();
    *(uint32_t *)htsig_addr = rate & 7 | (len + 0x28) * 0x100;
    return;
  }
  memw();
  *(uint32_t *)plcp1_addr = rate << 0xc | len + 0x28;
  return;
}



// WARNING: Unknown calling convention

void get_macaddr(uint32_t *mac_addr)

{
  uint8 macaddr [6];
  
  read_macaddr_from_otp(macaddr);
  mac_addr[1] = (uint)(ushort)macaddr._4_2_;
  *mac_addr = macaddr._0_4_;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_macrxfilter(bool mac_filter_en)

{
  uint uVar1;
  
  if (mac_filter_en) {
    _DAT_600330d8 = esp_dport_access_reg_read(&DAT_600330d8);
    _DAT_600330d8 = _DAT_600330d8 | 0xd;
    memw();
    _DAT_600330dc = esp_dport_access_reg_read(&DAT_600330dc);
    _DAT_600330dc = _DAT_600330dc | 0xd;
    memw();
    _DAT_600330e0 = esp_dport_access_reg_read(&DAT_600330e0);
    _DAT_600330e0 = _DAT_600330e0 | 0xd;
    memw();
    _DAT_600330e4 = esp_dport_access_reg_read(&DAT_600330e4);
    _DAT_600330e4 = _DAT_600330e4 | 0xd;
    memw();
  }
  else {
    _DAT_600330d8 = esp_dport_access_reg_read();
    _DAT_600330d8 = _DAT_600330d8 & 0xfffffff2;
    memw();
    _DAT_600330dc = esp_dport_access_reg_read(&DAT_600330dc);
    _DAT_600330dc = _DAT_600330dc & 0xfffffff2;
    memw();
    _DAT_600330e0 = esp_dport_access_reg_read(&DAT_600330e0);
    _DAT_600330e0 = _DAT_600330e0 & 0xfffffff2;
    memw();
    _DAT_600330e4 = esp_dport_access_reg_read(&DAT_600330e4);
    _DAT_600330e4 = _DAT_600330e4 & 0xfffffff2;
    memw();
  }
  _DAT_600330d8 = esp_dport_access_reg_read(&DAT_600330d8);
  _DAT_600330d8 = _DAT_600330d8 & 0xfffff7ff;
  memw();
  _DAT_600330dc = esp_dport_access_reg_read(&DAT_600330dc);
  _DAT_600330dc = _DAT_600330dc & 0xfffff7ff;
  memw();
  _DAT_600330e0 = esp_dport_access_reg_read(&DAT_600330e0);
  _DAT_600330e0 = _DAT_600330e0 & 0xfffff7ff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_600330e4);
  memw();
  _DAT_600330e4 = uVar1 & 0xfffff7ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ate_rxframe_fb(uint8 chan_num,u32 fb_rate,u32 fb_len)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  STATUS SVar6;
  uint32_t gi_bit;
  uint32_t rate;
  undefined4 *puStack_60;
  uint *puStack_5c;
  uint uStack_58;
  uint uStack_54;
  int iStack_50;
  uint *puStack_4c;
  uint *puStack_48;
  int iStack_44;
  int iStack_40;
  int iStack_3c;
  char *pcStack_38;
  uint *puStack_34;
  uint uStack_30;
  uint uStack_2c;
  
  puStack_4c = (uint *)Plcp0AddrGet(10);
  Plcp1AddrGet(10);
  puStack_5c = (uint *)ConfAddrGet(10);
  HTsigAddrGet(10);
  chip_v7_set_chan(chan_num,'\0');
  phy_printf("rx chan=%d, rate=0x%x, len=%d\n",chan_num,fb_rate,fb_len);
  _DAT_60033080 = esp_dport_access_reg_read(&DAT_60033080);
  _DAT_60033080 = _DAT_60033080 & 0xefffffff;
  memw();
  _DAT_60033c40 = esp_dport_access_reg_read(&DAT_60033c40);
  _DAT_60033c40 = _DAT_60033c40 | 0x20;
  memw();
  _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
  _DAT_60033c4c = _DAT_60033c4c | 0x20;
  memw();
  _DAT_60033084 = esp_dport_access_reg_read(&DAT_60033084);
  _DAT_60033084 = _DAT_60033084 & 0x1fffffff;
  memw();
  _DAT_60033084 = esp_dport_access_reg_read();
  _DAT_60033084 = _DAT_60033084 | 0x40000000;
  memw();
  _DAT_60033c40 = esp_dport_access_reg_read(&DAT_60033c40);
  _DAT_60033c40 = _DAT_60033c40 | 2;
  memw();
  _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
  _DAT_60033c4c = _DAT_60033c4c | 2;
  memw();
  set_macrxfilter(true);
  memw();
  _DAT_60033040 = 0x60504030;
  memw();
  _DAT_60033044 = 0x2010;
  _DAT_60033c78 = esp_dport_access_reg_read(&DAT_60033c78);
  _DAT_60033c78 = _DAT_60033c78 | 1;
  memw();
  _DAT_60033cac = esp_dport_access_reg_read(&DAT_60033cac);
  _DAT_60033cac = _DAT_60033cac & 0xfffffff0;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_60033c8c);
  _DAT_60033c8c = uVar2 & 0xfffffff | 0x30000000;
  memw();
  puStack_60 = (undefined4 *)
               fill_txdataframe(4,fb_len,0x10203040,0x5060,0x74657374,&rate,&gi_bit,fb_rate);
  uVar2 = esp_dport_access_reg_read(puStack_5c);
  puStack_34 = puStack_60 + -8;
  puStack_48 = puStack_60 + -7;
  memw();
  *puStack_5c = uVar2 & 0xffc00fff;
  uVar2 = esp_dport_access_reg_read(&DAT_60033080);
  iVar3 = esp_dport_access_reg_read(0x60033098);
  iStack_44 = esp_dport_access_reg_read(iVar3 + 4);
  iStack_44 = (uVar2 & 0xff) + iStack_44;
  iVar3 = esp_dport_access_reg_read(0x60033098);
  iVar3 = esp_dport_access_reg_read(iVar3 + 4);
  uVar4 = esp_dport_access_reg_read(&DAT_60033080);
  uVar2 = 0;
  iStack_40 = iStack_44 + 0x24;
  pcStack_38 = (char *)((uVar4 & 0xff) + iVar3);
  iStack_50 = iStack_44 + 0x28;
  iStack_3c = iStack_44 + 0x40;
  uStack_54 = 0;
  uStack_58 = 0;
  puStack_5c = (uint *)0x0;
  do {
    iVar3 = esp_dport_access_reg_read(&DAT_60033c00);
    _DAT_60033084 = esp_dport_access_reg_read(&DAT_60033084);
    _DAT_60033084 = _DAT_60033084 | 0x40000000;
    memw();
    while( true ) {
      uVar4 = esp_dport_access_reg_read(&DAT_60033c48);
      if ((uVar4 & 0x20) != 0) break;
      iVar5 = esp_dport_access_reg_read(&DAT_60033c00);
      if (2000000 < (uint)(iVar5 - iVar3)) {
        tx_pocket_num = 0;
        memw();
        iVar3 = esp_dport_access_reg_read(&DAT_60033c00);
        uVar2 = 0;
        puStack_5c = (uint *)0x0;
        uStack_58 = 0;
        uStack_54 = 0;
      }
      SVar6 = GetStopCmd();
      if (SVar6 != FAIL) {
        phy_printf("rx stoped!\n");
        tx_pocket_num = 0;
        memw();
        return;
      }
    }
    _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
    _DAT_60033c4c = _DAT_60033c4c | 0x20;
    memw();
    esp_dport_access_reg_read(iStack_3c);
    uStack_2c = esp_dport_access_reg_read(iStack_40);
    iVar3 = esp_dport_access_reg_read(iStack_50);
    uStack_2c = uStack_2c >> 0x10 | iVar3 << 0x10;
    uStack_30 = esp_dport_access_reg_read(iStack_50);
    esp_dport_access_reg_read(iStack_50);
    cVar1 = *pcStack_38;
    memw();
    *puStack_34 = uStack_2c;
    uVar4 = esp_dport_access_reg_read(puStack_48);
    memw();
    *puStack_48 = uStack_30 >> 0x10 | uVar4 & 0xffff0000;
    uVar4 = esp_dport_access_reg_read(iStack_44 + 0x48);
    memw();
    *puStack_60 = 4;
    memw();
    puStack_60[1] = 0;
    if (uVar4 == 0) {
      tx_pocket_num = 0;
      uVar2 = 0;
      puStack_5c = (uint *)0x0;
      uStack_58 = 0;
      uStack_54 = 0;
LAB_0002f97e:
      puStack_5c = (uint *)((uint)puStack_5c | 1 << 0x20 - (0x20 - (uVar4 & 0x1f)));
    }
    else {
      if (uVar4 < 0x20) goto LAB_0002f97e;
      if (uVar4 - 0x20 < 0x20) {
        uStack_58 = uStack_58 | 1 << 0x20 - (0x20 - (uVar4 - 0x20 & 0x1f));
      }
      else if (uVar4 - 0x40 < 0x20) {
        uStack_54 = uStack_54 | 1 << 0x20 - (0x20 - (uVar4 - 0x40 & 0x1f));
      }
      else if (uVar4 - 0x60 < 0x20) {
        uVar2 = uVar2 | 1 << 0x20 - (0x20 - (uVar4 - 0x60 & 0x1f));
      }
    }
    memw();
    puStack_60[3] = (int)cVar1;
    memw();
    puStack_60[2] = uVar4;
    memw();
    puStack_60[4] = puStack_5c;
    memw();
    puStack_60[5] = uStack_58;
    memw();
    puStack_60[6] = uStack_54;
    memw();
    puStack_60[7] = uVar2;
    tx_add_pocketnum();
    uVar4 = esp_dport_access_reg_read(puStack_4c);
    memw();
    *puStack_4c = uVar4 | 0x40000000;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ap_ack_test(uint8 chan_num,u32 fb_rate,u32 fb_len)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  STATUS SVar4;
  uint uVar5;
  uint32_t gi_bit;
  uint32_t rate;
  uint32_t rxaddrhi_chip_id;
  undefined4 *puStack_3c;
  uint *puStack_38;
  uint *puStack_34;
  int iStack_30;
  int iStack_2c;
  uint *puStack_28;
  uint uStack_24;
  
  puStack_38 = (uint *)Plcp0AddrGet(10);
  Plcp1AddrGet(10);
  rxaddrhi_chip_id = ConfAddrGet(10);
  HTsigAddrGet(10);
  chip_v7_set_chan(chan_num,'\0');
  phy_printf("rx chan=%d, rate=0x%x, len=%d\n",chan_num,fb_rate,fb_len);
  _DAT_60033080 = esp_dport_access_reg_read(&DAT_60033080);
  _DAT_60033080 = _DAT_60033080 & 0xefffffff;
  memw();
  _DAT_60033c40 = esp_dport_access_reg_read(&DAT_60033c40);
  _DAT_60033c40 = _DAT_60033c40 | 0x20;
  memw();
  _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
  _DAT_60033c4c = _DAT_60033c4c | 0x20;
  memw();
  _DAT_60033084 = esp_dport_access_reg_read(&DAT_60033084);
  _DAT_60033084 = _DAT_60033084 & 0x1fffffff;
  memw();
  _DAT_60033084 = esp_dport_access_reg_read();
  _DAT_60033084 = _DAT_60033084 | 0x40000000;
  memw();
  _DAT_60033c40 = esp_dport_access_reg_read(&DAT_60033c40);
  _DAT_60033c40 = _DAT_60033c40 | 2;
  memw();
  _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
  _DAT_60033c4c = _DAT_60033c4c | 2;
  memw();
  set_macrxfilter(true);
  memw();
  _DAT_60033040 = 0x60504030;
  memw();
  _DAT_60033044 = 0x2010;
  _DAT_60033c78 = esp_dport_access_reg_read(&DAT_60033c78);
  _DAT_60033c78 = _DAT_60033c78 | 1;
  memw();
  _DAT_60033cac = esp_dport_access_reg_read(&DAT_60033cac);
  _DAT_60033cac = _DAT_60033cac & 0xfffffff0;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_60033c8c);
  _DAT_60033c8c = uVar1 & 0xfffffff | 0x30000000;
  memw();
  puStack_3c = (undefined4 *)
               fill_txdataframe(4,fb_len,0x10203040,0x5060,0x74657374,&rate,&gi_bit,fb_rate);
  uVar1 = esp_dport_access_reg_read(rxaddrhi_chip_id);
  puStack_28 = puStack_3c + -8;
  puStack_34 = puStack_3c + -7;
  memw();
  *(uint *)rxaddrhi_chip_id = uVar1 & 0xffc00fff;
  uVar1 = esp_dport_access_reg_read(&DAT_60033080);
  iVar2 = esp_dport_access_reg_read(0x60033098);
  iVar2 = esp_dport_access_reg_read(iVar2 + 4);
  iVar2 = (uVar1 & 0xff) + iVar2;
  iStack_30 = iVar2;
  iVar3 = esp_dport_access_reg_read(0x60033098);
  esp_dport_access_reg_read(iVar3 + 4);
  esp_dport_access_reg_read(&DAT_60033080);
  iStack_2c = iVar2 + 0x24;
  rxaddrhi_chip_id = iVar2 + 0x28;
  do {
    iVar2 = esp_dport_access_reg_read(&DAT_60033c00);
    _DAT_60033084 = esp_dport_access_reg_read(&DAT_60033084);
    _DAT_60033084 = _DAT_60033084 | 0x40000000;
    memw();
    while (uVar1 = esp_dport_access_reg_read(&DAT_60033c48), (uVar1 & 0x20) == 0) {
      iVar3 = esp_dport_access_reg_read(&DAT_60033c00);
      if (2000000 < (uint)(iVar3 - iVar2)) {
        tx_pocket_num = 0;
        memw();
        iVar2 = esp_dport_access_reg_read(&DAT_60033c00);
      }
      SVar4 = GetStopCmd();
      if (SVar4 != FAIL) {
        phy_printf("rx stoped!\n");
        tx_pocket_num = 0;
        memw();
        return;
      }
    }
    _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
    _DAT_60033c4c = _DAT_60033c4c | 0x20;
    memw();
    uStack_24 = esp_dport_access_reg_read(iStack_2c);
    iVar2 = esp_dport_access_reg_read(rxaddrhi_chip_id);
    uStack_24 = uStack_24 >> 0x10 | iVar2 << 0x10;
    uVar1 = esp_dport_access_reg_read(rxaddrhi_chip_id);
    esp_dport_access_reg_read(rxaddrhi_chip_id);
    memw();
    *puStack_28 = uStack_24;
    uVar5 = esp_dport_access_reg_read(puStack_34);
    memw();
    *puStack_34 = uVar1 >> 0x10 | uVar5 & 0xffff0000;
    memw();
    puStack_3c[-9] = 0xd4;
    uVar1 = esp_dport_access_reg_read(iStack_30 + 0x30);
    memw();
    *puStack_3c = 4;
    memw();
    puStack_3c[1] = 0;
    if (uVar1 >> 0x10 == 0) {
      tx_pocket_num = (u16)(uVar1 >> 0x10);
      memw();
    }
    tx_add_pocketnum();
    uVar1 = esp_dport_access_reg_read(puStack_38);
    memw();
    *puStack_38 = uVar1 | 0x40000000;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint32_t tx_data_frame(uint32_t timelim)

{
  uint *puVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint32_t uVar5;
  uint32_t timer0;
  
  puVar1 = (uint *)Plcp0AddrGet(10);
  tx_add_pocketnum();
  memw();
  _DAT_60033c10 = 0x40000002;
  _DAT_60033c40 = esp_dport_access_reg_read(&DAT_60033c40);
  _DAT_60033c40 = _DAT_60033c40 | 0x80;
  memw();
  _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
  _DAT_60033c4c = _DAT_60033c4c | 0x80;
  memw();
  uVar2 = esp_dport_access_reg_read(puVar1);
  memw();
  *puVar1 = uVar2 | 0xc0000000;
  iVar3 = esp_dport_access_reg_read(&DAT_60033c00);
  do {
    uVar2 = esp_dport_access_reg_read(&DAT_60033c48);
    if ((uVar2 & 0x80) != 0) {
      _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
      _DAT_60033c4c = _DAT_60033c4c | 0x80;
      memw();
      uVar5 = esp_dport_access_reg_read(&DAT_60033c68);
      return uVar5;
    }
    iVar4 = esp_dport_access_reg_read(&DAT_60033c00);
  } while ((uint)(iVar4 - iVar3) < timelim);
  return 0xffffffff;
}



// WARNING: Unknown calling convention

void tx_ack_start(uint16 tx_num,u32 backoff,u32 aifs,u32 delay_ms,u32 *result)

{
  short sVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  uint32_t uVar5;
  char extraout_var;
  uint uVar6;
  int iVar7;
  u32 uVar8;
  int iVar9;
  uint local_50;
  uint uStack_4c;
  int iStack_48;
  uint uStack_44;
  u32 uStack_40;
  u32 uStack_38;
  int iStack_34;
  uint uStack_30;
  
  uVar6 = (uint)tx_num;
  Plcp0AddrGet(10);
  puVar2 = (uint *)ConfAddrGet(10);
  tx_pocket_num = 0;
  memw();
  uVar3 = esp_dport_access_reg_read(&DAT_3ff5c018);
  iVar7 = (int)(short)((short)((uVar3 & 0x7fe0) >> 5) + -0x400);
  iVar9 = iVar7 + 2;
  iVar7 = iVar7 + 5;
  if (-1 < iVar9) {
    iVar7 = iVar9;
  }
  uVar3 = esp_dport_access_reg_read(puVar2);
  memw();
  *puVar2 = (aifs & 0xf) << 0x18 | uVar3 & 0xf0ffffff;
  if (tx_num == 0) {
    uStack_38 = 0xfffffb00;
    uStack_30 = uVar6;
    local_50 = uVar6;
    uStack_4c = uVar6;
  }
  else {
    uStack_4c = 0;
    uVar3 = 0;
    uStack_38 = 0xfffffb00;
    local_50 = 0;
    iStack_34 = 0;
    iStack_48 = 0;
    uStack_30 = 0;
    uStack_40 = 0xfffffb00;
    uStack_44 = 0;
    do {
      if (backoff == 0) {
        uVar4 = esp_dport_access_reg_read(0x60035144);
        backoff = ((uVar4 & 0xf) + 1) * 8;
      }
      uVar4 = esp_dport_access_reg_read(puVar2);
      memw();
      *puVar2 = (backoff & 0x3ff) << 0xc | uVar4 & 0xffc00fff;
      uVar5 = tx_data_frame(50000);
      if ((uVar5 & 0xff000000) == 0) {
        esp_dport_access_reg_read(0x600330a8);
        sVar1 = (short)extraout_var + (short)(iVar7 >> 2);
        iVar9 = (int)sVar1;
        iStack_48 = (int)(short)(sVar1 + (short)iStack_48);
        uStack_44 = ((int)uStack_44 < iVar9) * uStack_44 + (uint)((int)uStack_44 >= iVar9) * iVar9;
        uStack_40 = (uint)((int)uStack_40 < iVar9) * iVar9 + ((int)uStack_40 >= iVar9) * uStack_40;
        if (uVar3 < 0x20) {
          uStack_4c = uStack_4c | 1 << 0x20 - (0x20 - (uVar3 & 0x1f));
        }
        rx_ack_num = rx_ack_num + 1;
        local_50 = local_50 + 1 & 0xffff;
        memw();
        if (4 < local_50) {
          iStack_34 = (int)(short)(sVar1 + (short)iStack_34);
          uStack_30 = ((int)uStack_30 < iVar9) * uStack_30 + (uint)((int)uStack_30 >= iVar9) * iVar9
          ;
          uStack_38 = (uint)((int)uStack_38 < iVar9) * iVar9 + ((int)uStack_38 >= iVar9) * uStack_38
          ;
        }
      }
      uVar8 = 0;
      if (delay_ms != 0) {
        do {
          uVar8 = uVar8 + 1;
          ets_delay_us(1000);
        } while (delay_ms != uVar8);
      }
      uVar3 = uVar3 + 1;
    } while (uVar3 != uVar6);
    if (local_50 < 10) {
      if (local_50 == 0) {
        uStack_38 = 0xfffffb00;
        uVar6 = 0;
        uStack_30 = 0;
      }
      else {
        uVar6 = (uint)(short)((iStack_48 * 10) / (int)local_50);
        uStack_38 = uStack_40;
        uStack_30 = uStack_44;
      }
    }
    else {
      uVar6 = (uint)(short)((iStack_34 * 10) / (int)(local_50 - 4));
    }
  }
  result[1] = local_50;
  *result = uStack_4c;
  result[2] = uVar6;
  result[3] = uStack_38;
  result[4] = uStack_30;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void tx_ack_init(u32 ap_addr0,u32 ap_addr1,uint8 tx_rate,u32 tx_length,bool tx_cbw40)

{
  uint *puVar1;
  uint uVar2;
  uint32_t mac_addr [2];
  uint32_t gi_bit;
  uint32_t rate;
  u32 uStack_30;
  
  uStack_30 = ap_addr0;
  puVar1 = (uint *)HTsigAddrGet(10);
  set_macrxfilter(true);
  get_macaddr(mac_addr);
  memw();
  _DAT_60033040 = mac_addr[0];
  memw();
  _DAT_60033044 = mac_addr[1];
  _DAT_60033c78 = esp_dport_access_reg_read(&DAT_60033c78);
  _DAT_60033c78 = _DAT_60033c78 | 2;
  memw();
  test_tx_rate = (uint)tx_rate;
  fill_txdataframe(1,tx_length,uStack_30,ap_addr1,0x74657373,&rate,&gi_bit,0xff);
  uVar2 = esp_dport_access_reg_read(puVar1);
  memw();
  *puVar1 = (tx_cbw40 & 1) << 7 | uVar2 & 0xffffff7f;
  _DAT_60033084 = esp_dport_access_reg_read(&DAT_60033084);
  _DAT_60033084 = _DAT_60033084 & 0x1fffffff;
  memw();
  _DAT_60033080 = esp_dport_access_reg_read(&DAT_60033080);
  _DAT_60033080 = _DAT_60033080 & 0xefffffff;
  memw();
  _DAT_60033084 = esp_dport_access_reg_read(&DAT_60033084);
  _DAT_60033084 = _DAT_60033084 | 0x80000000;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_60033c50);
  _DAT_60033c50 = uVar2 & 0xffff00ff | 0x4000;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_60033c50);
  memw();
  _DAT_60033c50 = uVar2 & 0xffffff00 | 0x40;
  return;
}



// WARNING: Unknown calling convention

void tx_ack_test(u32 ap_addr0,u32 ap_addr1,uint8 tx_rate,uint16 tx_num,u32 tx_length,u32 backoff,
                u32 aifs,u32 delay_ms,bool tx_cbw40)

{
  u32 uVar1;
  u32 result [5];
  
  uVar1 = PSDU0_OFFSET;
  tx_pocket_num = 0;
  memw();
  tx_ack_init(ap_addr0,ap_addr1,tx_rate,tx_length,tx_cbw40);
  *(undefined *)uVar1 = 0x40;
  memw();
  tx_ack_start(tx_num,backoff,aifs,delay_ms,result);
  phy_printf("\nflag: 0x%x tx_num: %d ack_num: %d rssi: %02d rssi_max: %02d rssi_min: %02d\n",
             result[0],tx_num,(undefined2)result[1],result[2],result[3],result[4]);
  return;
}



// WARNING: Control flow encountered bad instruction data
// WARNING: Unknown calling convention

pm_sw_reject_t
pm_set_sleep_mode_local(PM_SLEEP_MODE sleep_mode,_func_void_varargs *pmac_save_params)

{
  bool bVar1;
  
  pm_mac_deinit();
  bVar1 = pm_check_mac_idle();
  if (bVar1) {
    pm_mac_init();
    return PM_SW_REJECT;
  }
  if (sleep_mode != PM_LIGHT_SLEEP) {
    if (sleep_mode != PM_LIGHT_SLEEP_NO_WIFIPD) {
      __assert_func("bb_common.c",0x908,"pm_set_sleep_mode_local","0 && \"unsupported sleep mode\"")
      ;
                    // WARNING: Bad instruction - Truncating control flow here
      halt_baddata();
    }
    rtc_sleep_init(0x1004000);
    return PM_SW_NOREJECT;
  }
  rtc_sleep_init(0x1004100);
  return PM_SW_NOREJECT;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void light_sleep(u8 sleep_mode,u32 sleep_time)

{
  PM_SLEEP_MODE sleep_mode_00;
  undefined4 uVar1;
  u32 slp_cycles;
  u32 slp_cycles_h;
  
  sleep_mode_00 = (PM_SLEEP_MODE)sleep_mode;
  phy_close_rf();
  pm_set_sleep_mode_local(sleep_mode_00,(_func_void_varargs *)0x0);
  uVar1 = rtc_slowck_cali(0,0x80);
  rtc_usec2rtc(0,sleep_time,uVar1,&slp_cycles_h,&slp_cycles);
  pm_set_sleep_cycles(slp_cycles);
  pm_wakeup_opt(8,0);
  pm_goto_sleep(sleep_mode_00);
  rtc_set_cpu_freq(1);
  rtc_uart_div_modify(0);
  if (sleep_mode_00 == PM_MODEM_SLEEP_WIFI_PD) {
    _DAT_3ff48084 = esp_dport_access_reg_read(&DAT_3ff48084);
    _DAT_3ff48084 = _DAT_3ff48084 & 0xfffdffff;
    memw();
    ets_delay_us(5);
    _DAT_3ff48088 = esp_dport_access_reg_read(&DAT_3ff48088);
    _DAT_3ff48088 = _DAT_3ff48088 & 0xefffffff;
    memw();
  }
  _DAT_3ff000cc = esp_dport_access_reg_read(&DAT_3ff000cc);
  _DAT_3ff000cc = _DAT_3ff000cc | 0x87cf;
  memw();
  pm_open_rf();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void sleep_proc_test(u8 sleep_mode,u8 wakeup,u32 sleep_time)

{
  int iVar1;
  rwip_rf_api api;
  
  if (sleep_mode == '\x01') {
    if (wakeup == '\0') {
      phy_close_rf();
      rtc_set_cpu_freq(4);
      rtc_uart_div_modify(0);
      return;
    }
    rtc_set_cpu_freq(1);
    rtc_uart_div_modify(0);
    pm_wakeup_init(2,0);
  }
  else {
    if (sleep_mode == '\x03') {
      light_sleep('\x04',sleep_time);
    }
    else if (sleep_mode == '\x04') {
      light_sleep('\b',sleep_time);
    }
    if (wakeup == '\0') {
      return;
    }
  }
  iVar1 = _DAT_60033c00;
  memw();
  pm_wakeup_init(sleep_mode,0);
  memw();
  phy_printf("wakeup_init=%dus\n",_DAT_60033c00 - iVar1);
  coex_bt_high_prio();
  rf_rw_init(&api);
  mac_init();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void wifi_ack_test(u32 ap_addr0,u32 ap_addr1,uint8 tx_rate,u32 tx_length,u32 chan_org,
                  u32 chan_cfg_org,u16 tx_num,u8 test_num,u8 backoff,u8 test_mode,u32 delay_ms)

{
  bool bVar1;
  int iVar2;
  u32 uVar3;
  uint uVar4;
  uint uVar5;
  u32 *puVar6;
  int *piVar7;
  u32 *puVar8;
  u32 *puVar9;
  u32 *puVar10;
  u8 sleep_mode;
  u32 uVar11;
  u32 rx_flag_m [20];
  u32 ack_num_m [20];
  int rssi_m [20];
  u32 result [5];
  
  puVar8 = rx_flag_m;
  uVar4 = (uint)test_num;
  tx_ack_init(ap_addr0,ap_addr1,tx_rate,tx_length,false);
  if (uVar4 == 0) {
    phy_printf("ack_num,");
    phy_printf("rssi,");
    phy_printf("flag,");
  }
  else {
    uVar5 = 0;
    bVar1 = true;
    do {
      iVar2 = _DAT_60033c00;
      if (test_mode != '\0') {
        if (test_mode == '\x01') {
          chip_v7_set_chan_nomac('\x0e','\0');
          chip_v7_set_chan_nomac((int8)chan_org,(int8)chan_cfg_org);
        }
        else if (test_mode == '\x02') {
          sleep_proc_test('\x01','\0',1000);
          sleep_proc_test('\x01','\x01',1000);
        }
        else {
          if (test_mode == '\x03') {
            sleep_mode = '\x04';
          }
          else {
            if (test_mode != '\x04') {
              if ((test_mode == '\x05') && (memw(), coex_test_enable != false)) {
                do {
                  if (phy_force_wifi_chan_en == false) {
                    bVar1 = false;
                  }
                  else {
                    if (!bVar1) {
                      bVar1 = true;
                      break;
                    }
                    bVar1 = true;
                  }
                  memw();
                  if ((200000 < (uint)(_DAT_60033c00 - iVar2)) ||
                     (ets_delay_us(10), coex_test_enable == false)) break;
                } while( true );
              }
              goto LAB_00030784;
            }
            sleep_mode = '\x03';
          }
          sleep_proc_test(sleep_mode,'\0',1000);
          tx_ack_init(ap_addr0,ap_addr1,tx_rate,tx_length,false);
        }
      }
LAB_00030784:
      tx_ack_start(tx_num,(uint)backoff,3,0,result);
      uVar3 = result[2];
      uVar11 = result[1];
      puVar9 = ack_num_m + uVar5;
      puVar10 = rx_flag_m + uVar5;
      puVar6 = (u32 *)(rssi_m + uVar5);
      uVar5 = uVar5 + 1;
      *puVar10 = result[0];
      *puVar9 = uVar11;
      *puVar6 = uVar3;
    } while (uVar5 != uVar4);
    phy_printf("ack_num,");
    puVar6 = ack_num_m;
    uVar5 = 0;
    do {
      uVar5 = uVar5 + 1;
      uVar11 = *puVar6;
      puVar6 = puVar6 + 1;
      phy_printf(&DAT_0005513c,uVar11);
    } while (uVar5 != uVar4);
    phy_printf("rssi,");
    piVar7 = rssi_m;
    uVar5 = 0;
    do {
      uVar5 = uVar5 + 1;
      phy_printf(&DAT_0005513c,*piVar7);
      piVar7 = piVar7 + 1;
    } while (uVar5 != uVar4);
    phy_printf("flag,");
    uVar5 = 0;
    do {
      uVar5 = uVar5 + 1;
      phy_printf("0x%x,",*puVar8);
      puVar8 = puVar8 + 1;
    } while (uVar5 != uVar4);
  }
  phy_printf(&DAT_0005507c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

S16 ram_get_power_db(uint16 pw_offset)

{
  S16 SVar1;
  S16 SVar2;
  S16 vref_dc;
  S16 vsig_dc;
  
  _DAT_3ff460b8 = esp_dport_access_reg_read(&DAT_3ff460b8);
  _DAT_3ff460b8 = _DAT_3ff460b8 | 0x40000;
  memw();
  (*g_phyFuns->get_fm_sar_dout_)(&vsig_dc,&vref_dc);
  _DAT_3ff460b8 = esp_dport_access_reg_read(&DAT_3ff460b8);
  _DAT_3ff460b8 = _DAT_3ff460b8 & 0xfffbffff;
  memw();
  SVar1 = (*g_phyFuns->linear_to_db_)((int)vsig_dc,'\x03');
  SVar2 = (*g_phyFuns->linear_to_db_)((int)vref_dc,'\x03');
  return (pw_offset + SVar1) - SVar2;
}



// WARNING: Unknown calling convention

sint32 test_txtone_pwr(int tone_atten,int loop_num,int mode,S16 step)

{
  S16 SVar1;
  int iVar2;
  int iVar3;
  
  txcal_debuge_mode(false);
  if (mode == 0) {
    (*g_phyFuns->start_tx_tone_step_)(true,step,(uint8)tone_atten,false,0,'\0');
    iVar2 = 0;
    iVar3 = 0;
    if (0 < loop_num) {
      do {
        iVar3 = iVar3 + 1;
        SVar1 = (*g_phyFuns->get_power_db_)(pwrdet_offset);
        iVar2 = iVar2 + SVar1;
      } while (loop_num != iVar3);
      goto LAB_000309b1;
    }
  }
  else if (mode == 1) {
    if (loop_num < 1) {
      iVar2 = 0;
    }
    else {
      iVar3 = 0;
      iVar2 = 0;
      do {
        iVar3 = iVar3 + 1;
        (*g_phyFuns->start_tx_tone_step_)(true,step,(uint8)tone_atten,false,0,'\0');
        SVar1 = (*g_phyFuns->get_power_db_)(pwrdet_offset);
        iVar2 = iVar2 + SVar1;
        (*g_phyFuns->stop_tx_tone_)(1);
      } while (loop_num != iVar3);
    }
    (*g_phyFuns->txcal_work_mode_)();
    goto LAB_000309b1;
  }
  iVar2 = 0;
LAB_000309b1:
  phy_printf(&DAT_00055164,iVar2);
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void get_rx_buffer(uint8 chan,uint8 mac_sel,u32 mac_id)

{
  undefined uVar1;
  sint16 sVar2;
  uint uVar3;
  int iVar4;
  STATUS SVar5;
  uint uVar6;
  RxControl *rxctrl;
  uint *puVar7;
  uint *puVar8;
  u32 uVar9;
  uint uVar10;
  u8 rssi;
  
  chip_v7_set_chan(chan,'\0');
  _DAT_60033084 = esp_dport_access_reg_read(&DAT_60033084);
  _DAT_60033084 = _DAT_60033084 & 0x1fffffff;
  memw();
  _DAT_60033080 = esp_dport_access_reg_read(&DAT_60033080);
  _DAT_60033080 = _DAT_60033080 & 0xefffffff;
  memw();
  do {
    _DAT_60033084 = esp_dport_access_reg_read(&DAT_60033084);
    _DAT_60033084 = _DAT_60033084 | 0x40000000;
    memw();
    do {
      uVar3 = esp_dport_access_reg_read(&DAT_60033084);
    } while ((uVar3 & 0x40000000) != 0);
    iVar4 = esp_dport_access_reg_read(0x60033098);
    iVar4 = esp_dport_access_reg_read(iVar4 + 4);
    uVar3 = esp_dport_access_reg_read(&DAT_60033080);
    puVar7 = (uint *)((uVar3 & 0xff) + iVar4);
    uVar1 = *(undefined *)puVar7;
    uVar3 = *puVar7;
    if ((uVar3 & 0xc000) == 0) {
      uVar9 = puVar7[4];
      uVar6 = uVar3 >> 8 & 0x1f;
      uVar3 = uVar3 >> 0x10 & 0xfff;
    }
    else {
      uVar6 = (uVar3 >> 0xe & 3) * 0x10 + (puVar7[1] & 0x7f);
      uVar9 = puVar7[4];
      uVar3 = puVar7[1] >> 8 & 0xffff;
    }
    sVar2 = phy_get_rx_freq((u8)uVar6,uVar9);
    if (mac_sel == '\x01') {
      uVar10 = puVar7[10];
      uVar9 = uVar10 << 0x18 | uVar10 >> 0x18 | (uVar10 >> 8 & 0xff) << 0x10 |
              (uVar10 >> 0x10 & 0xff) << 8;
LAB_00030b2c:
      if (uVar9 == mac_id) goto LAB_00030b2f;
    }
    else {
      if (mac_sel == '\x02') {
        uVar10 = puVar7[10];
        uVar9 = (puVar7[9] >> 0x10) << 0x18 | (puVar7[9] >> 0x18) << 0x10 | (uVar10 & 0xff) << 8;
        goto LAB_00030b2c;
      }
      uVar10 = puVar7[10];
LAB_00030b2f:
      phy_printf("SA:%02x:%02x:%02x:%02x:%02x:%02x, ",puVar7[9] >> 0x10 & 0xff,puVar7[9] >> 0x18,
                 uVar10 & 0xff,uVar10 >> 8 & 0xff,uVar10 >> 0x10 & 0xff,uVar10 >> 0x18);
      puVar8 = puVar7 + 0x20;
      phy_printf("rssi:%02d, rate:%02d, len:%03d, freq:%02d",uVar1,uVar6,uVar3,(int)sVar2);
      do {
        uVar3 = *puVar8;
        puVar8 = puVar8 + 1;
        phy_printf(&DAT_000551b8,uVar3);
      } while (puVar7 + 0x25 != puVar8);
      phy_printf(&DAT_0005507c);
    }
    SVar5 = GetStopCmd();
    if (SVar5 == OK) {
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void test_noise_floor(u8 channel,u32 delay)

{
  sint16 sVar1;
  u32 uVar2;
  STATUS SVar3;
  
  chip_v7_set_chan(channel,'\0');
  do {
    uVar2 = 0;
    if (delay != 0) {
      do {
        uVar2 = uVar2 + 1;
        ets_delay_us(1000);
      } while (delay != uVar2);
    }
    noise_check_loop('\x01',true);
    sVar1 = read_hw_noisefloor();
    phy_printf("noise: %d\n",(int)sVar1);
    SVar3 = GetStopCmd();
  } while (SVar3 != OK);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void oneblock_buf_init(void)

{
  mac_write(RX_ampdu_buff0_start + 0x40,0x80000020);
  mac_write(RX_ampdu_buff0_start + 0x44,RX_ampdu_buff0_start);
  mac_write(RX_ampdu_buff0_start + 0x48,RX_ampdu_buff0_start + 0x40);
  mac_write(0x60033088,RX_ampdu_buff0_start + 0x40);
  phy_printf("set one block ok !\n");
  return;
}



// WARNING: Unknown calling convention

void clear_mem(U32 mem_start_addr,uint depth)

{
  if (depth != 0) {
    do {
      memw();
      *(undefined4 *)mem_start_addr = 0x5aa55aa5;
      mem_start_addr = mem_start_addr + 4;
      depth = depth - 1;
    } while (depth != 0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void clear_txdumpmem(void)

{
  memw();
  _DAT_3ffe8000 = 0x5aa55aa5;
  return;
}



// WARNING: Unknown calling convention

int link_dscr_check(int buf_start,int buf_end,int size,int dscr_start,int dscr_end,int dscr_cnt,
                   int last_len,int checklastlen)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  uint32_t val;
  int iVar4;
  uint uVar5;
  
  iVar3 = dscr_end;
  do {
    uVar2 = esp_dport_access_reg_read(iVar3);
    iVar4 = iVar3 + 0xc;
    uVar5 = size * -0x7fffefff + 0x80000000;
    if ((iVar3 == dscr_end) && (uVar5 = last_len * 0x1000 + size + 0xc0000000, checklastlen == 0)) {
      if (((uVar2 & 0xc0000000) != 0xc0000000) || ((uVar2 & 0xfff000) == 0)) {
        return 0;
      }
    }
    else if (uVar2 != uVar5) {
      return 0;
    }
    bVar1 = iVar3 != buf_end + -0xc;
    iVar3 = buf_start;
    if (bVar1) {
      iVar3 = iVar4;
    }
  } while (iVar3 != dscr_end);
  return 1;
}



void rxlink_count(void)

{
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void get_encapaddr(void)

{
  return;
}



// WARNING: Unknown calling convention

void get_txdumpaddr(uint32 *txdump_addr,int32 *plcp_11g_len)

{
  *txdump_addr = (uint32)&DAT_3ffe8000;
  *plcp_11g_len = 0xc;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void crypto_disable(void)

{
  memw();
  _DAT_60033800 = 0;
  memw();
  _DAT_60033814 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void crypto_encap(uint que_no,uint32 location,uint32 keyentry_mask,uint32 amsdu_valid)

{
  uint uVar1;
  int iVar2;
  
  iVar2 = 0x110;
  if ((amsdu_valid & 0xf) != 0) {
    iVar2 = 0x310;
  }
  uVar1 = amsdu_valid >> 0x10 & 0xf;
  memw();
  _DAT_60033000 = 0x23222120;
  memw();
  _DAT_60033004 = 0x2524;
  memw();
  _DAT_60033044 = 0x506;
  memw();
  _DAT_60033040 = 0x1020304;
  memw();
  _DAT_60033008 = 0;
  memw();
  _DAT_6003300c = 0;
  memw();
  _DAT_6003304c = 0x506;
  memw();
  _DAT_60033048 = 0x1020304;
  if ((keyentry_mask == 0) || (uVar1 != 0)) {
    memw();
    _DAT_60033800 = 0;
    memw();
    _DAT_60033804 = 0;
    if (uVar1 == 1) {
      if ((location & 1) == 0) {
        _DAT_60033800 = esp_dport_access_reg_read(&DAT_60033800);
        _DAT_60033800 = _DAT_60033800 | 0x20;
        memw();
      }
      else {
        _DAT_60033804 = esp_dport_access_reg_read(&DAT_60033804);
        _DAT_60033804 = _DAT_60033804 | 0x20;
        memw();
      }
    }
  }
  else {
    uVar1 = location & 0xffff;
    if (uVar1 == 0) {
      _DAT_60033800 = iVar2 + 0x30003;
      memw();
    }
    else if (uVar1 == 1) {
      _DAT_60033804 = iVar2 + 0x30003;
      memw();
    }
    else if (uVar1 == 2) {
      _DAT_60033800 = iVar2 + 0x70003;
      memw();
    }
    else {
      _DAT_60033804 = iVar2 + 0x70003;
      memw();
    }
  }
  memw();
  memw();
  _DAT_3ff00024 = 2;
  memw();
  memw();
  _DAT_60033dc0 = 0x80007fff;
  _DAT_60033814 = keyentry_mask;
  tx_a_frame(que_no);
  memw();
  _DAT_60033dc0 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void do_decryto_poll(int32 match_mask)

{
  undefined uVar1;
  uint uVar2;
  STATUS SVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  int iStack_50;
  uint uStack_48;
  int iStack_44;
  undefined4 uStack_3c;
  int iStack_38;
  
  rx_buffer_ena();
  memw();
  _DAT_60033c78 = 0;
  _DAT_600330d8 = esp_dport_access_reg_read(&DAT_600330d8);
  _DAT_600330d8 = _DAT_600330d8 | 7;
  memw();
  _DAT_600330dc = esp_dport_access_reg_read(&DAT_600330dc);
  _DAT_600330dc = _DAT_600330dc | 7;
  memw();
  _DAT_600330e0 = esp_dport_access_reg_read(&DAT_600330e0);
  _DAT_600330e0 = _DAT_600330e0 | 7;
  memw();
  _DAT_600330e4 = esp_dport_access_reg_read(&DAT_600330e4);
  _DAT_600330e4 = _DAT_600330e4 | 7;
  memw();
  _DAT_60033c0c = esp_dport_access_reg_read(&DAT_60033c0c);
  _DAT_60033c0c = _DAT_60033c0c | 0x80000000;
  memw();
  _DAT_60033c40 = esp_dport_access_reg_read(&DAT_60033c40);
  _DAT_60033c40 = _DAT_60033c40 | 4;
  memw();
  _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
  _DAT_60033c4c = _DAT_60033c4c | 0xc;
  memw();
  phy_printf("amsdu rx ready!\n");
  uVar2 = esp_dport_access_reg_read(&DAT_60033080);
  iVar7 = 0;
  uStack_48 = 0;
  iStack_38 = 0;
  iStack_50 = 0;
  iStack_44 = 0;
  uStack_3c = 0;
  uVar1 = 0;
  do {
    while (uVar4 = esp_dport_access_reg_read(&DAT_60033c48), (uVar4 & 4) == 0) {
      SVar3 = GetStopCmd();
      if (SVar3 != FAIL) {
        iVar5 = esp_dport_access_reg_read(0x60033098);
        esp_dport_access_reg_read(iVar5 + 4);
        iVar5 = esp_dport_access_reg_read(&DAT_60009c44);
        if (iVar5 != 0) {
          memw();
          _DAT_60009c44 = 0;
        }
        phy_printf("Correct: %d Desired: %d RSSI: %d gain: %d noise: %d err: %d err_fcs: %d rxpmd: 0x%x rx_state: 0x%x keyid_match: 0x%x"
                   ,iVar7,iStack_44,0,0,0,iStack_50,iStack_38,uStack_48,uVar1,uStack_3c);
        phy_printf(" valid_count: 0");
        phy_printf(" rxhung_int_cnt: %d rxhung_status: 0x%x\n",0,iVar5);
        return;
      }
    }
    iVar7 = iVar7 + 1;
    iVar5 = esp_dport_access_reg_read(0x60033098);
    iVar5 = esp_dport_access_reg_read(iVar5 + 4);
    uVar4 = esp_dport_access_reg_read(&DAT_60033c48);
    _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
    _DAT_60033c4c = _DAT_60033c4c | 0xc;
    memw();
    uVar6 = esp_dport_access_reg_read(0x600330a4);
    if ((uVar6 & 0xf0000) == match_mask) {
      if ((uVar6 & 0xff) != 0) {
        if ((uVar6 & 0xff) == 0x41) {
          iStack_38 = iStack_38 + 1;
          rx_link_des();
        }
        goto LAB_0003110a;
      }
      iVar5 = (uVar2 & 0xff) + iVar5;
      uVar1 = esp_dport_access_reg_read(iVar5 + 8);
      rx_link_des();
      esp_dport_access_reg_read(iVar5);
      iStack_44 = iStack_44 + 1;
      uStack_3c = esp_dport_access_reg_read(0x60033830);
      uStack_48 = uVar6;
    }
    else if ((uVar6 & 0xff) != 0) {
LAB_0003110a:
      iStack_50 = iStack_50 + 1;
    }
    if ((uVar4 & 8) != 0) {
      esp_dport_access_reg_read(0x3ff5c04c);
      esp_dport_access_reg_read(0x3ff5c050);
      _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
      _DAT_60033c4c = _DAT_60033c4c | 8;
      memw();
    }
  } while( true );
}



// WARNING: Unknown calling convention

void do_ampdu_rx_poll(int32 match_mask)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void crypto_decap(int valid_entry_mask,int location,int addr_lo,int addr_hi,int bssid_lo,
                 int bssid_hi,int force_keysrch,int amsdu_valid)

{
  int iVar1;
  int32 match_mask;
  uint32 fc_qos_valid_bit;
  
  iVar1 = 0x100;
  if ((amsdu_valid & 0xfU) == 1) {
    iVar1 = 0x300;
  }
  mac_write(0x60033814,valid_entry_mask);
  memw();
  _DAT_60033060 = 0xffffffff;
  memw();
  _DAT_60033068 = 0xffffffff;
  memw();
  _DAT_60033020 = 0xffffffff;
  memw();
  _DAT_60033028 = 0xffffffff;
  _DAT_60033064 = esp_dport_access_reg_read(&DAT_60033064);
  _DAT_60033064 = _DAT_60033064 | 0xffff;
  memw();
  _DAT_6003306c = esp_dport_access_reg_read(&DAT_6003306c);
  _DAT_6003306c = _DAT_6003306c | 0xffff;
  memw();
  _DAT_60033024 = esp_dport_access_reg_read(&DAT_60033024);
  _DAT_60033024 = _DAT_60033024 | 0xffff;
  memw();
  _DAT_6003302c = esp_dport_access_reg_read(&DAT_6003302c);
  _DAT_6003302c = _DAT_6003302c | 0xffff;
  memw();
  if ((location & 0xfffdU) == 0) {
    if (valid_entry_mask == 0) {
      mac_write(0x60033800,0);
    }
    else {
      mac_write(0x60033800,iVar1 + 0x10030003);
      if (force_keysrch == 1) {
        _DAT_60033800 = esp_dport_access_reg_read(&DAT_60033800);
        _DAT_60033800 = _DAT_60033800 | 0x100000;
        memw();
      }
      if ((location & 0xffffU) == 2) {
        _DAT_60033800 = esp_dport_access_reg_read(&DAT_60033800);
        _DAT_60033800 = _DAT_60033800 | 0x40000;
        memw();
      }
    }
    mac_write(0x60033000,bssid_lo);
    mac_write(0x60033004,bssid_hi);
    mac_write(0x60033040,addr_lo);
    mac_write(0x60033044,addr_hi);
    _DAT_60033064 = esp_dport_access_reg_read(&DAT_60033064);
    _DAT_60033064 = _DAT_60033064 | 0x10000;
    memw();
    if ((uint)location >> 0x10 == 1) {
      _DAT_6003306c = esp_dport_access_reg_read(&DAT_6003306c);
      _DAT_6003306c = _DAT_6003306c | 0x10000;
      memw();
      _DAT_60033024 = esp_dport_access_reg_read(&DAT_60033024);
      _DAT_60033024 = _DAT_60033024 | 0x10000;
      memw();
      _DAT_6003302c = esp_dport_access_reg_read(&DAT_6003302c);
      _DAT_6003302c = _DAT_6003302c | 0x10000;
      memw();
      match_mask = 0x50000;
    }
    else {
      _DAT_6003306c = esp_dport_access_reg_read();
      _DAT_6003306c = _DAT_6003306c & 0xfffeffff;
      memw();
      _DAT_60033024 = esp_dport_access_reg_read(&DAT_60033024);
      _DAT_60033024 = _DAT_60033024 | 0x10000;
      memw();
      _DAT_6003302c = esp_dport_access_reg_read(&DAT_6003302c);
      _DAT_6003302c = _DAT_6003302c & 0xfffeffff;
      memw();
      match_mask = 0x50000;
    }
  }
  else {
    if (valid_entry_mask == 0) {
      mac_write(0x60033804,0);
    }
    else {
      mac_write(0x60033804,iVar1 + 0x10030003);
      if (force_keysrch == 1) {
        _DAT_60033804 = esp_dport_access_reg_read(&DAT_60033804);
        _DAT_60033804 = _DAT_60033804 | 0x100000;
        memw();
      }
      if ((location & 0xffffU) == 3) {
        _DAT_60033804 = esp_dport_access_reg_read(&DAT_60033804);
        _DAT_60033804 = _DAT_60033804 | 0x40000;
        memw();
      }
    }
    mac_write(0x60033008,bssid_lo);
    mac_write(0x6003300c,bssid_hi);
    mac_write(0x60033048,addr_lo);
    mac_write(0x6003304c,addr_hi);
    if ((uint)location >> 0x10 == 1) {
      _DAT_60033064 = esp_dport_access_reg_read(&DAT_60033064);
      _DAT_60033064 = _DAT_60033064 | 0x10000;
      memw();
      _DAT_6003306c = esp_dport_access_reg_read(&DAT_6003306c);
      _DAT_6003306c = _DAT_6003306c | 0x10000;
      memw();
      _DAT_60033024 = esp_dport_access_reg_read(&DAT_60033024);
      _DAT_60033024 = _DAT_60033024 | 0x10000;
      memw();
    }
    else {
      _DAT_60033064 = esp_dport_access_reg_read();
      _DAT_60033064 = _DAT_60033064 & 0xfffeffff;
      memw();
      _DAT_6003306c = esp_dport_access_reg_read(&DAT_6003306c);
      _DAT_6003306c = _DAT_6003306c | 0x10000;
      memw();
      _DAT_60033024 = esp_dport_access_reg_read(&DAT_60033024);
      _DAT_60033024 = _DAT_60033024 & 0xfffeffff;
      memw();
    }
    _DAT_6003302c = esp_dport_access_reg_read(&DAT_6003302c);
    _DAT_6003302c = _DAT_6003302c | 0x10000;
    match_mask = 0xa0000;
    memw();
  }
  if (((uint)amsdu_valid >> 0x10 & 0xf) != 1) {
    do_decryto_poll(match_mask);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void get_micaddr(void)

{
  phy_printf("0x%x 0x%x\n",0x60034800,PSDU0_OFFSET);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void crypto_enmic(int32 data_len,int32 start_offset)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  
  uVar1 = start_offset + data_len;
  if ((uVar1 & 3) == 0) {
    if ((int)uVar1 < 0) {
      uVar1 = uVar1 + 3;
    }
    iVar2 = (int)uVar1 >> 2;
  }
  else {
    uVar3 = uVar1 + 3;
    if (-1 < (int)uVar1) {
      uVar3 = uVar1;
    }
    iVar2 = ((int)uVar3 >> 2) + 1;
  }
  mac_write(0x6003480c,0x20);
  uVar1 = esp_dport_access_reg_read(&DAT_6003480c);
  _DAT_6003480c = start_offset * -3 + 0x10U & 0x1f | uVar1 & 0xffffffe0;
  memw();
  uVar1 = mac_read(PSDU0_OFFSET);
  mac_write(0x60034808,uVar1);
  uVar1 = esp_dport_access_reg_read(&DAT_6003480c);
  _DAT_6003480c = uVar1 & 0xffffffe0 | 0x10;
  memw();
  if (2 < iVar2) {
    iVar4 = 0;
    do {
      uVar1 = mac_read(PSDU0_OFFSET + 4 + iVar4);
      iVar4 = iVar4 + 4;
      mac_write(0x60034808,uVar1);
    } while ((iVar2 + 0x3ffffffe) * 4 != iVar4);
  }
  uVar1 = esp_dport_access_reg_read(&DAT_6003480c);
  _DAT_6003480c = uVar1 & 0xffffffe0 | 0x10;
  memw();
  uVar1 = mac_read(iVar2 * 4 + (PSDU0_OFFSET - 4));
  mac_write(0x60034808,uVar1);
  mac_write(0x6003480c,0);
  uVar1 = mac_read(0x60034810);
  phy_printf("0x%x 0x%x 0x%x 0x%x ",uVar1 & 0xff,uVar1 >> 8 & 0xff,uVar1 >> 0x10 & 0xff,
             uVar1 >> 0x18);
  uVar1 = mac_read(0x60034814);
  phy_printf("0x%x 0x%x 0x%x 0x%x\n",uVar1 & 0xff,uVar1 >> 8 & 0xff,uVar1 >> 0x10 & 0xff,
             uVar1 >> 0x18);
  return;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_wr_reg(u32 addr,u32 high_bit,u32 low_bit,u32 data)

{
  return data << 10 | addr | 0x10000000 | low_bit << 0x12 | high_bit << 0x17;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_rd_reg(u32 addr,u32 high_bit,u32 low_bit)

{
  return low_bit << 0x12 | addr | 0x20000000 | high_bit << 0x17;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_wr_i2c(u32 wr_en,u32 i2c_sel,u32 addr,u32 high_bit,u32 low_bit,u32 data)

{
  return data << 8 | addr | 0x30000000 | low_bit << 0x10 | high_bit << 0x13 | i2c_sel << 0x16 |
         wr_en << 0x1b;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_wait_delay(u32 delay)

{
  return delay | 0x40000000;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_meas_tsens(u32 meas_cyc,u32 delay)

{
  return meas_cyc << 0x10 | delay | 0xa0000000;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_meas_saradc(u32 meas_cyc,u32 sar_sel,u32 sar_mux,u32 dreg)

{
  return sar_mux << 2 | dreg | 0x50000000 | sar_sel << 6 | meas_cyc << 8;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_write_mem(u32 write_way,u32 result_mux,u32 dreg)

{
  return result_mux << 2 | dreg | 0x60000000 | write_way << 7;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_reg0_alu(u32 mask,u32 alu,u32 dreg)

{
  return alu << 2 | dreg | 0x70000000 | mask << 6;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_stage_alu(u32 flag,u32 alu)

{
  return alu << 2 | 0x72000000 | flag << 6;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_force_branch(u32 branch)

{
  return branch << 0x11 | 0x80000000;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_reg0_branch(u32 branch,u32 judge,u32 thres)

{
  return judge << 0x10 | thres | 0x82000000 | branch << 0x11;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_stage_branch(u32 branch,u32 judge,u32 thres)

{
  return judge << 0xf | thres | 0x84000000 | branch << 0x11;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_cpu_wakeup(u32 wake)

{
  return wake | 0x90000000;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_sleep_cyc_sel(u32 cyc_sel)

{
  return cyc_sel | 0x92000000;
}



// WARNING: Unknown calling convention

u32 rtc_cmd_meas_end(void)

{
  return 0xb0000000;
}



// WARNING: Unknown calling convention

void read_rtc_mem(u32 start,u32 num)

{
  int iVar1;
  uint uVar2;
  u32 uVar3;
  u32 uVar4;
  
  if (num != 0) {
    iVar1 = (start + 0x18008600) * 4;
    uVar3 = 0;
    do {
      uVar2 = esp_dport_access_reg_read(iVar1);
      uVar4 = uVar3 + 1;
      phy_printf("%d: %d, mux=%d, data=%d\n",uVar3,uVar2 >> 0x15,uVar2 >> 0x10 & 0x1f,uVar2 & 0xffff
                );
      iVar1 = iVar1 + 4;
      uVar3 = uVar4;
    } while (num != uVar4);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 test_rtc_cmd(u32 sar1_en_pad,u32 sar2_en_pad)

{
  uint uVar1;
  int iVar2;
  uint *puVar3;
  
  _DAT_3ff48890 = esp_dport_access_reg_read(&DAT_3ff48890);
  _DAT_3ff48890 = _DAT_3ff48890 & 0xf7ffffff;
  memw();
  _DAT_3ff48018 = esp_dport_access_reg_read(&DAT_3ff48018);
  iVar2 = 1;
  _DAT_3ff48018 = _DAT_3ff48018 & 0xfeffffff;
  memw();
  puVar3 = (uint *)&DAT_60021000;
  do {
    switch(iVar2) {
    case 1:
      uVar1 = 0x19c80e03;
      break;
    case 2:
      uVar1 = 0xa0001000;
      goto LAB_00031a62;
    case 3:
      uVar1 = 0x60000000;
      break;
    case 4:
      uVar1 = 0xa0004000;
      break;
    case 5:
      uVar1 = 0x60000004;
      break;
    case 6:
      uVar1 = 0x19c80203;
      break;
    case 7:
      uVar1 = 0x50000000;
      break;
    case 8:
      uVar1 = 0x60000008;
      break;
    case 9:
    case 0xb:
      uVar1 = sar1_en_pad << 2 | 0x50000000;
      break;
    case 10:
      uVar1 = 0x6000000c;
      break;
    case 0xc:
      uVar1 = 0x60000010;
      break;
    case 0xd:
    case 0xf:
      uVar1 = sar2_en_pad << 2 | 0x50000040;
      break;
    case 0xe:
      uVar1 = 0x60000014;
      break;
    case 0x10:
      uVar1 = 0x60000018;
      break;
    case 0x11:
      uVar1 = 0x92000000;
      break;
    case 0x12:
      uVar1 = 0x90000001;
      break;
    case 0x13:
      uVar1 = 0xb0000000;
      break;
    default:
      uVar1 = 0;
LAB_00031a62:
      memw();
      *puVar3 = uVar1;
      if (iVar2 == 0x14) {
        _DAT_3ff48018 = esp_dport_access_reg_read(&DAT_3ff48018);
        _DAT_3ff48018 = _DAT_3ff48018 | 0x1000000;
        iVar2 = 5000;
        memw();
        do {
          iVar2 = iVar2 + -1;
          ets_delay_us(1000);
        } while (iVar2 != 0);
        read_rtc_mem(0,100);
        return 0;
      }
      goto LAB_000319fa;
    }
    memw();
    *puVar3 = uVar1;
LAB_000319fa:
    iVar2 = iVar2 + 1;
    puVar3 = puVar3 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void mac_write(uint addr,uint value)

{
  memw();
  *(uint *)addr = value;
  return;
}



// WARNING: Unknown calling convention

uint mac_read(uint addr)

{
  memw();
  return *(uint *)addr;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void mac_buffer_get(void)

{
  TXBUF_START = (u32)txbuffer;
  PSDU0_OFFSET = 0x6112c;
  PSDU1_OFFSET = 0x6192c;
  PSDU2_OFFSET = 0x61f2c;
  PSDU3_OFFSET = 0x6202c;
  RX_ampdu_entry0_start = (u32)RX_ampdu_entry0_buf;
  RX_ampdu_entrysd0_start = (u32)RX_ampdu_entrysd0_buf;
  RX_ampdu_buff0_start = (u32)RX_ampdu_buff0_buf;
  RX_aplenbk_start = (u32)RX_aplenbk;
  RX_aplkbk_start = (u32)RX_aplkbk;
  RX_bufflk_start = (u32)RX_bufflk;
  return;
}



// WARNING: Unknown calling convention

uint32 DurAddrGet(uint queue)

{
  uint32 uVar1;
  
  uVar1 = 0x60034268;
  if (queue - 0xb < 7) {
    uVar1 = *(uint32 *)(CSWTCH_41 + (queue - 0xb) * 4);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

uint32 RealQGet(uint queue)

{
  uint32 uVar1;
  
  uVar1 = 0;
  if (queue - 1 < 0x1b) {
    uVar1 = *(uint32 *)(CSWTCH_43 + (queue - 1) * 4);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

uint32 Plcp0AddrGet(uint queue)

{
  uint32 uVar1;
  
  uVar1 = 0x60033d20;
  if (queue - 1 < 0x1b) {
    uVar1 = *(uint32 *)(CSWTCH_45 + (queue - 1) * 4);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

uint32 Plcp1AddrGet(uint queue)

{
  uint32 uVar1;
  
  uVar1 = 0x60034258;
  if (queue - 1 < 0x1b) {
    uVar1 = *(uint32 *)(CSWTCH_47 + (queue - 1) * 4);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

uint32 HTsigAddrGet(uint queue)

{
  uint32 uVar1;
  
  uVar1 = 0x60034260;
  if (queue - 1 < 0x1b) {
    uVar1 = *(uint32 *)(CSWTCH_49 + (queue - 1) * 4);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

uint32 ConfAddrGet(uint queue)

{
  undefined *puVar1;
  
  puVar1 = &DAT_60033d1c;
  if (queue - 0xb < 7) {
    puVar1 = *(undefined **)(CSWTCH_51 + (queue - 0xb) * 4);
  }
  return (uint32)puVar1;
}



// WARNING: Unknown calling convention

uint32 BackOffCountGet(uint queue)

{
  uint uVar1;
  uint32_t val;
  
  switch(queue) {
  default:
    uVar1 = esp_dport_access_reg_read(&DAT_60033d1c);
    return uVar1 & 0xfff;
  case 0xb:
  case 0x15:
    uVar1 = esp_dport_access_reg_read(0x60033d14);
    return uVar1 & 0xfff;
  case 0xc:
  case 0x16:
    uVar1 = esp_dport_access_reg_read(0x60033d0c);
    return uVar1 & 0xfff;
  case 0xd:
  case 0x17:
    uVar1 = esp_dport_access_reg_read(0x60033d04);
    return uVar1 & 0xfff;
  case 0xe:
  case 0x18:
    uVar1 = esp_dport_access_reg_read(0x60033cfc);
    return uVar1 & 0xfff;
  case 0xf:
  case 0x19:
    uVar1 = esp_dport_access_reg_read(0x60033cf4);
    return uVar1 & 0xfff;
  case 0x10:
  case 0x1a:
    uVar1 = esp_dport_access_reg_read(&DAT_60033cec);
    return uVar1 & 0xfff;
  case 0x11:
  case 0x1b:
    uVar1 = esp_dport_access_reg_read(0x60033ce4);
    return uVar1 & 0xfff;
  }
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void fill_tx_frame(uint tx_queue,uint tx_rate,uint length,uint psdu0_len,uint psdu1_len,
                  uint psdu2_len,uint psdu3_len,uint32 key_entry_no,uint32 bssid_no,
                  uint32 link_start_addr,uint32 gi_bit,uint32 ap_mac_5,uint32 ap_mac_4,
                  uint32 ap_mac_3,uint32 ap_mac_2,uint32 ap_mac_1,uint32 ap_mac_0)

{
  undefined uVar1;
  uint uVar2;
  int iVar3;
  U32 *pUVar4;
  int iVar5;
  undefined *puVar6;
  int iVar7;
  uint *puVar8;
  int iVar9;
  int *piVar10;
  undefined *puVar11;
  undefined4 *puVar12;
  undefined *puVar13;
  uint *puVar14;
  undefined *puVar15;
  U32 mac_data [44];
  
  pUVar4 = mac_data;
  crypto_disable();
  uVar2 = tx_queue & 0xff;
  if (uVar2 - 1 < 0x1b) {
    iVar7 = (uVar2 - 1) * 4;
    puVar14 = *(uint **)(CSWTCH_47 + iVar7);
    puVar8 = *(uint **)(CSWTCH_45 + iVar7);
    piVar10 = *(int **)(CSWTCH_49 + iVar7);
  }
  else {
    piVar10 = (int *)0x60034260;
    puVar8 = (uint *)0x60033d20;
    puVar14 = (uint *)0x60034258;
  }
  puVar12 = (undefined4 *)&DAT_60033d1c;
  if (uVar2 - 0xb < 7) {
    puVar12 = *(undefined4 **)(CSWTCH_51 + (uVar2 - 0xb) * 4);
  }
  memw();
  *puVar12 = 0;
  if (tx_rate < 0x10) {
    memw();
    *puVar14 = bssid_no * 0x800000 + key_entry_no * 0x20000 + tx_rate * 0x1000 + (length & 0xfff);
    memw();
    *piVar10 = (gi_bit >> 2 & 1) * 0x40000000 + tx_rate + gi_bit * -0x80000000 + length * 0x100;
  }
  else {
    memw();
    *puVar14 = key_entry_no << 0x11 | 0x200b000 | bssid_no << 0x17 | length & 0xfff;
    if (uVar2 < 0x14) {
      if ((tx_queue >> 8 & 0xff) != 0) {
        memw();
        *piVar10 = (gi_bit >> 2 & 1) * 0x40000000 + gi_bit * -0x80000000 + 0xf000000 +
                   (tx_rate & 0xf) + length * 0x100;
        memw();
        _DAT_60033c6c = 0x10;
        goto code_r0x00031eeb;
      }
      iVar7 = 0x7000000;
    }
    else {
      iVar7 = 0xf000000;
    }
    memw();
    *piVar10 = (gi_bit >> 2 & 1) * 0x40000000 + gi_bit * -0x80000000 + iVar7 + (tx_rate & 0xf) +
               length * 0x100;
    _DAT_60033c6c = esp_dport_access_reg_read(&DAT_60033c6c);
    _DAT_60033c6c = _DAT_60033c6c & 0xffffffef;
    memw();
  }
code_r0x00031eeb:
  if (((psdu2_len == 0 && psdu3_len == 0) && psdu1_len == 0) && psdu0_len == 0) {
    memw();
    *puVar8 = link_start_addr & 0xfffff;
    return;
  }
  memw();
  *puVar8 = TXBUF_START & 0xfffff;
  if (psdu3_len == 0) {
    if (psdu2_len == 0) {
      if (psdu1_len == 0) {
        iVar7 = 1;
        iVar5 = -0x40000000;
        goto LAB_00031f24;
      }
      iVar7 = 2;
    }
    else {
      iVar7 = 3;
    }
  }
  else {
    iVar7 = 4;
  }
  iVar5 = -0x80000000;
LAB_00031f24:
  memw();
  *(uint *)TXBUF_START = psdu0_len * 0x1001 + iVar5;
  memw();
  *(u32 *)(TXBUF_START + 4) = PSDU0_OFFSET;
  iVar5 = -0x40000000;
  if (iVar7 != 2) {
    iVar5 = -0x80000000;
  }
  iVar3 = -0x40000000;
  if (iVar7 != 3) {
    iVar3 = -0x80000000;
  }
  memw();
  *(u32 *)(TXBUF_START + 8) = TXBUF_START + 0x10;
  iVar9 = -0x40000000;
  if (iVar7 != 4) {
    iVar9 = -0x80000000;
  }
  uVar2 = 0;
  memw();
  *(uint *)(TXBUF_START + 0x10) = psdu1_len * 0x1001 + iVar5;
  memw();
  *(u32 *)(TXBUF_START + 0x14) = PSDU1_OFFSET;
  memw();
  *(u32 *)(TXBUF_START + 0x18) = TXBUF_START + 0x20;
  memw();
  *(uint *)(TXBUF_START + 0x20) = psdu2_len * 0x1001 + iVar3;
  memw();
  *(u32 *)(TXBUF_START + 0x24) = PSDU2_OFFSET;
  memw();
  *(u32 *)(TXBUF_START + 0x28) = TXBUF_START + 0x30;
  memw();
  *(uint *)(TXBUF_START + 0x30) = psdu3_len * 0x1001 + iVar9;
  memw();
  *(u32 *)(TXBUF_START + 0x34) = PSDU3_OFFSET;
  memw();
  *(undefined4 *)(TXBUF_START + 0x38) = 0;
  mac_data[0] = 0x48;
  mac_data[2] = 0x3a;
  mac_data[5] = ap_mac_1;
  mac_data[7] = ap_mac_3;
  mac_data[4] = ap_mac_0;
  mac_data[9] = ap_mac_5;
  mac_data[6] = ap_mac_2;
  mac_data[10] = 0x14;
  mac_data[0xb] = 0x15;
  mac_data[8] = ap_mac_4;
  mac_data[0xc] = 0x16;
  mac_data[1] = 1;
  mac_data[3] = 1;
  mac_data[0xd] = 0x17;
  mac_data[0xe] = 0x18;
  mac_data[0xf] = 0x19;
  mac_data[0x11] = ap_mac_1;
  mac_data[0x10] = ap_mac_0;
  mac_data[0x13] = ap_mac_3;
  mac_data[0x1d] = 5;
  mac_data[0x12] = ap_mac_2;
  mac_data[0x15] = ap_mac_5;
  mac_data[0x1e] = 100;
  mac_data[0x16] = 0x60;
  mac_data[0x1f] = 0x6c;
  mac_data[0x14] = ap_mac_4;
  mac_data[0x17] = 0x47;
  mac_data[0x20] = 0x69;
  mac_data[0x18] = 0x31;
  mac_data[0x19] = 4;
  mac_data[0x21] = 0x6e;
  mac_data[0x1a] = 10;
  mac_data[0x22] = 0x6b;
  mac_data[0x1b] = 0;
  mac_data[0x1c] = 0;
  mac_data[0x23] = 1;
  mac_data[0x24] = 8;
  mac_data[0x25] = 2;
  mac_data[0x26] = 4;
  mac_data[0x27] = 0xb;
  mac_data[0x28] = 0;
  mac_data[0x29] = 0;
  mac_data[0x2a] = 0;
  mac_data[0x2b] = 0;
  puVar6 = (undefined *)PSDU0_OFFSET;
  puVar11 = (undefined *)PSDU1_OFFSET;
  puVar13 = (undefined *)PSDU2_OFFSET;
  puVar15 = (undefined *)PSDU3_OFFSET;
  if (length != 0) {
    do {
      if (uVar2 < psdu0_len) {
        *puVar6 = (char)*pUVar4;
        memw();
        puVar6 = puVar6 + 1;
      }
      else {
        uVar1 = (undefined)uVar2;
        if (uVar2 < psdu0_len + psdu1_len) {
          *puVar11 = uVar1;
          memw();
          puVar11 = puVar11 + 1;
        }
        else if (uVar2 < psdu2_len + psdu0_len + psdu1_len) {
          *puVar13 = uVar1;
          memw();
          puVar13 = puVar13 + 1;
        }
        else {
          *puVar15 = uVar1;
          memw();
          puVar15 = puVar15 + 1;
        }
      }
      uVar2 = uVar2 + 1;
      pUVar4 = pUVar4 + 1;
      length = length - 1;
    } while (length != 0);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rx_buffer_init(uint rx_buff_start,uint rx_buff_size)

{
  uint uVar1;
  
  uVar1 = rx_buff_size >> 8;
  memw();
  *(undefined4 *)RX_bufflk_start = 0x80000100;
  memw();
  *(uint *)(RX_bufflk_start + 4) = rx_buff_start;
  memw();
  *(u32 *)(RX_bufflk_start + 8) = RX_bufflk_start + 0xc;
  memw();
  *(u32 *)(((uint)(uVar1 == 0) + (uVar1 != 0) * uVar1) * 0xc + RX_bufflk_start + -4) =
       RX_bufflk_start;
  memw();
  _DAT_60033088 = RX_bufflk_start;
  memw();
  _DAT_60033084 = 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rx_link_des(void)

{
  esp_dport_access_reg_read(&DAT_60033084);
  memw();
  memw();
  _DAT_60033084 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rx_buffer_ena(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_60033084);
  memw();
  _DAT_60033084 = uVar1 | 0x80000000;
  return;
}



// WARNING: Unknown calling convention

void rx_ampdu_buffer_fresh(uint rx_ampdu_buff_start,uint rx_ampdu_buff_size)

{
  uint uVar1;
  
  uVar1 = rx_ampdu_buff_size >> 8;
  memw();
  *(undefined4 *)RX_bufflk_start = 0x80100100;
  memw();
  *(uint *)(RX_bufflk_start + 4) = rx_ampdu_buff_start;
  memw();
  *(u32 *)(RX_bufflk_start + 8) = RX_bufflk_start + 0xc;
  memw();
  *(u32 *)(((uint)(uVar1 == 0) + (uVar1 != 0) * uVar1) * 0xc + RX_bufflk_start + -4) =
       RX_bufflk_start;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rx_ampdu_buffer_init(uint rx_ampdu_buff_start,uint rx_ampdu_buff_size)

{
  rx_ampdu_buffer_fresh(rx_ampdu_buff_start,rx_ampdu_buff_size);
  memw();
  _DAT_60033088 = RX_bufflk_start;
  return;
}



// WARNING: Unknown calling convention

void rx_ampdu_entry_fresh(uint rx_ampdu_entry_start,uint rx_ampdu_entry_size)

{
  uint uVar1;
  
  uVar1 = rx_ampdu_entry_size >> 3;
  memw();
  *(undefined4 *)RX_aplkbk_start = 0x80008008;
  memw();
  *(uint *)(RX_aplkbk_start + 4) = rx_ampdu_entry_start;
  memw();
  *(u32 *)(RX_aplkbk_start + 8) = RX_aplkbk_start + 0xc;
  memw();
  *(u32 *)(((uint)(uVar1 == 0) + (uVar1 != 0) * uVar1) * 0xc + RX_aplkbk_start + -4) =
       RX_aplkbk_start;
  return;
}



// WARNING: Unknown calling convention

void rx_ampdu_entry_init(uint rx_ampdu_entry_start,uint rx_ampdu_entry_size)

{
  rx_ampdu_entry_fresh(rx_ampdu_entry_start,rx_ampdu_entry_size);
  return;
}



// WARNING: Unknown calling convention

void rx_ampdu_entrysd_fresh(uint rx_ampdu_entrysd_start,uint rx_ampdu_entrysd_size)

{
  uint uVar1;
  
  uVar1 = rx_ampdu_entrysd_size >> 3;
  memw();
  *(undefined4 *)RX_aplenbk_start = 0x80008008;
  memw();
  *(uint *)(RX_aplenbk_start + 4) = rx_ampdu_entrysd_start;
  memw();
  *(u32 *)(RX_aplenbk_start + 8) = RX_aplenbk_start + 0xc;
  memw();
  *(u32 *)(((uint)(uVar1 == 0) + (uVar1 != 0) * uVar1) * 0xc + RX_aplenbk_start + -4) =
       RX_aplenbk_start;
  return;
}



// WARNING: Unknown calling convention

void rx_ampdu_entrysd_init(uint rx_ampdu_entrysd_start,uint rx_ampdu_entrysd_size)

{
  rx_ampdu_entrysd_fresh(rx_ampdu_entrysd_start,rx_ampdu_entrysd_size);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void mac_init(void)

{
  uint uVar1;
  
  TXBUF_START = (u32)txbuffer;
  PSDU0_OFFSET = 0x6112c;
  PSDU1_OFFSET = 0x6192c;
  PSDU2_OFFSET = 0x61f2c;
  PSDU3_OFFSET = 0x6202c;
  RX_ampdu_entry0_start = (u32)RX_ampdu_entry0_buf;
  RX_ampdu_entrysd0_start = (u32)RX_ampdu_entrysd0_buf;
  RX_ampdu_buff0_start = (u32)RX_ampdu_buff0_buf;
  RX_aplenbk_start = (u32)RX_aplenbk;
  RX_aplkbk_start = (u32)RX_aplkbk;
  RX_bufflk_start = (u32)RX_bufflk;
  _DAT_60033d24 = esp_dport_access_reg_read(&DAT_60033d24);
  _DAT_60033d24 = _DAT_60033d24 | 2;
  memw();
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_60033d24);
  } while ((uVar1 & 1) == 0);
  _DAT_600330d8 = esp_dport_access_reg_read(&DAT_600330d8);
  _DAT_600330d8 = _DAT_600330d8 & 0xfffffff8;
  memw();
  _DAT_600330dc = esp_dport_access_reg_read(&DAT_600330dc);
  _DAT_600330dc = _DAT_600330dc & 0xfffffff8;
  memw();
  _DAT_600330e0 = esp_dport_access_reg_read(&DAT_600330e0);
  _DAT_600330e0 = _DAT_600330e0 & 0xfffffff8;
  memw();
  _DAT_600330e4 = esp_dport_access_reg_read(&DAT_600330e4);
  _DAT_600330e4 = _DAT_600330e4 & 0xfffffff8;
  memw();
  _DAT_60033c6c = esp_dport_access_reg_read(&DAT_60033c6c);
  _DAT_60033c6c = _DAT_60033c6c & 0xfffffffd;
  memw();
  _DAT_60033c6c = esp_dport_access_reg_read(&DAT_60033c6c);
  _DAT_60033c6c = _DAT_60033c6c & 0xffffffef;
  memw();
  _DAT_60033c6c = esp_dport_access_reg_read(&DAT_60033c6c);
  _DAT_60033c6c = _DAT_60033c6c & 0x7fffffff;
  memw();
  _DAT_60033080 = esp_dport_access_reg_read(&DAT_60033080);
  _DAT_60033080 = _DAT_60033080 | 0x30000000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_60033080);
  _DAT_60033080 = uVar1 & 0xffffff00 | 0xc;
  memw();
  memw();
  _DAT_60033c40 = 0x1f;
  memw();
  _DAT_60033040 = 0x7060504;
  memw();
  _DAT_60033044 = 0x908;
  memw();
  _DAT_60033d1c = 0x4013000;
  memw();
  _DAT_60033dc4 = 0x3020100;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff000a8);
  _DAT_3ff000a8 = uVar1 & 0xffffff9f | 0x40;
  memw();
  _DAT_60033c24 = esp_dport_access_reg_read(&DAT_60033c24);
  _DAT_60033c24 = _DAT_60033c24 & 0x7fffffff;
  memw();
  _DAT_60033c6c = esp_dport_access_reg_read(&DAT_60033c6c);
  _DAT_60033c6c = _DAT_60033c6c | 0x800000;
  memw();
  _DAT_600330d8 = esp_dport_access_reg_read(&DAT_600330d8);
  _DAT_600330d8 = _DAT_600330d8 | 0x20;
  memw();
  _DAT_60033080 = esp_dport_access_reg_read(&DAT_60033080);
  _DAT_60033080 = _DAT_60033080 & 0xefffffff;
  memw();
  rx_ampdu_buffer_fresh(RX_ampdu_buff0_start,0x1000);
  memw();
  _DAT_60033088 = RX_bufflk_start;
  _DAT_60033080 = esp_dport_access_reg_read(&DAT_60033080);
  _DAT_60033080 = _DAT_60033080 | 0x10000000;
  memw();
  rx_ampdu_entry_fresh(RX_ampdu_entry0_start,300);
  rx_ampdu_entrysd_fresh(RX_ampdu_entrysd0_start,100);
  uVar1 = esp_dport_access_reg_read(&DAT_60033084);
  memw();
  _DAT_60033084 = uVar1 | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void adctrig(int32 smp_num_aft_trig,int32 trigmode,int32 trigcase,int32 sample_88m,int32 dump_trig,
            int32 rx_gain_mode,int32 rx_gain,int32 rx_gain0,int32 rx_gain0_wait_us)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  
  esp_dport_access_reg_read(&DAT_60033d90);
  iVar2 = 0;
  if ((sample_88m & 1U) == 0) {
    iVar2 = 0x10000;
  }
  _DAT_60033d90 =
       iVar2 + (dump_trig & 1U) * 0x20000 + trigmode * 0x10000000 + trigcase * 0x100000 +
       smp_num_aft_trig + 1;
  memw();
  memw();
  _DAT_60033d90 = esp_dport_access_reg_read(&DAT_60033d90);
  _DAT_60033d90 = _DAT_60033d90 | 0x80000000;
  memw();
  if (rx_gain_mode == 1) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = uVar1 & 0xffffff | rx_gain << 0x18;
    memw();
    _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = _DAT_3ff5c02c | 0x800000;
    memw();
    if (trigmode != 0) goto LAB_00032a06;
LAB_0003293a:
    _DAT_60033d90 = esp_dport_access_reg_read(&DAT_60033d90);
    _DAT_60033d90 = _DAT_60033d90 | 0x80000;
    memw();
    _DAT_60033d90 = esp_dport_access_reg_read(&DAT_60033d90);
    _DAT_60033d90 = _DAT_60033d90 & 0xfff7ffff;
    memw();
LAB_000329f4:
    if (1 < rx_gain_mode - 2U) goto LAB_00032a06;
  }
  else {
    if (rx_gain_mode != 3) {
      if (trigmode == 0) goto LAB_0003293a;
      goto LAB_000329f4;
    }
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = uVar1 & 0xffffff | rx_gain0 << 0x18;
    memw();
    _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = _DAT_3ff5c02c | 0x800000;
    memw();
    ets_delay_us(rx_gain0_wait_us & 0xffff);
    if (trigmode == 0) goto LAB_0003293a;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = uVar1 & 0xffffff | rx_gain << 0x18;
  memw();
  _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = _DAT_3ff5c02c | 0x800000;
  memw();
LAB_00032a06:
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_60033d90);
  } while ((uVar1 & 0x40000) == 0);
  ets_delay_us(10000);
  uVar1 = esp_dport_access_reg_read(0x60033d94);
  uVar3 = uVar1 >> 0xe & 1;
  uVar1 = esp_dport_access_reg_read(0x60033d94);
  if (((uVar3 << 0xe | uVar1 & 0x3fff) != smp_num_aft_trig + 1U) && (dump_trig == 0)) {
    phy_printf("fail: 0x%x,0x%x,0x%x,0x%x,0x%x\n",smp_num_aft_trig,trigmode,trigcase,sample_88m,0);
    return;
  }
  uVar1 = esp_dport_access_reg_read(0x60033d94);
  _DAT_60033d90 = esp_dport_access_reg_read(&DAT_60033d90);
  _DAT_60033d90 = _DAT_60033d90 & 0x7fffffff;
  memw();
  phy_printf("0x%x,0x%x,0x%x,0x%x\n",uVar1 & 0x3fff,uVar3,&DAT_3ffe8000,0x10000);
  return;
}



// WARNING: Unknown calling convention

void module_test_cal_print(bool print_en)

{
  uint16 *puVar1;
  uint32 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  sint16 *psVar5;
  sleep_param_t *psVar6;
  uint32 *puVar7;
  sleep_param_t *psVar8;
  uint32 *puVar9;
  sint8 *psVar10;
  sleep_param_t *psVar11;
  char cVar12;
  char cVar14;
  uint uStack_30;
  ushort uVar13;
  ushort uVar15;
  
  if (print_en) {
    uVar2 = phy_get_rf_cal_version();
    phy_printf("phy_version: %d, %s, %s, %s\n",uVar2,"02e0d70","Sep  2 2024","19:39:14");
    uVar3 = esp_dport_access_reg_read(0x3ff5a008);
    uVar4 = esp_dport_access_reg_read(0x3ff5a004);
    phy_printf("CHIP_ID: 0x%x, 0x%x\n\n",uVar3,uVar4);
    uVar2 = chip7_sleep_params.vdd33_code;
    phy_printf("param_flag: 0x%x\n",chip7_sleep_params.param_flag);
    uStack_30 = uVar2 >> 0x10;
    phy_printf("vdd33=%d, temp_code=%d, offset=%d\n",uStack_30,uVar2 & 0xff,(int)(char)(uVar2 >> 8))
    ;
    phy_printf("rc_dout, %d; wifi: %d, %d, %d, %d, bt: %d, %d\n",chip7_sleep_params.rc_dout,
               chip7_sleep_params.filter_dcap_wifi[0],chip7_sleep_params.filter_dcap_wifi[1],
               chip7_sleep_params.filter_dcap_wifi[2],chip7_sleep_params.filter_dcap_wifi[3],
               chip7_sleep_params.filter_dcap_bt[0],chip7_sleep_params.filter_dcap_bt[1]);
    phy_printf("cal_rf_ana_gain, rf_gain=0x%x, ana_gain=0x%x\n",tx_rf_ana_gain[0],tx_rf_ana_gain[1])
    ;
  }
  else {
    uStack_30 = chip7_sleep_params.vdd33_code >> 0x10;
  }
  psVar6 = &chip7_sleep_params;
  psVar5 = noise_array;
  do {
    if (print_en) {
      phy_printf("RX_NOISEFLOOR, %d\n",(int)*psVar5);
    }
    psVar5 = psVar5 + 1;
  } while (psVar5 != (sint16 *)&wifi_bbgain_max);
  psVar8 = psVar6;
  if (print_en) {
    phy_printf("TXCAP_TMX2G_CCT_LOAD, ");
  }
  do {
    if (print_en) {
      phy_printf(&DAT_00055450,psVar8->para_txcap[0]);
    }
    psVar8 = (sleep_param_t *)((int)&psVar8->param_flag + 3);
  } while (psVar8 != (sleep_param_t *)chip7_sleep_params.txdc_table);
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("TXCAP_PA2G_CCT_STG1, ");
  }
  do {
    if (print_en) {
      phy_printf(&DAT_00055450,psVar8->para_txcap[1]);
    }
    psVar8 = (sleep_param_t *)((int)&psVar8->param_flag + 3);
  } while (psVar8 != (sleep_param_t *)chip7_sleep_params.txdc_table);
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("TXCAP_PA2G_CCT_STG2, ");
  }
  do {
    if (print_en) {
      phy_printf(&DAT_00055450,psVar8->para_txcap[2]);
    }
    psVar8 = (sleep_param_t *)((int)&psVar8->param_flag + 3);
  } while (psVar8 != (sleep_param_t *)chip7_sleep_params.txdc_table);
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("TX_POWER_BACKOFF, ");
  }
  do {
    if (print_en) {
      phy_printf(&DAT_00055450,(int)psVar8->target_power_chan_backoff[0]);
    }
    psVar8 = (sleep_param_t *)((int)&psVar8->param_flag + 2);
  } while (psVar8 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("TX_PWRCTRL_ATTEN, ");
  }
  psVar10 = chip7_sleep_params.tx_pwctrl_atten;
  do {
    if (print_en) {
      phy_printf(&DAT_00055450,(int)*psVar10);
    }
    psVar10 = psVar10 + 1;
  } while ((uint8 *)psVar10 != chip7_sleep_params.bt_pa_gain);
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("TXIQ,");
  }
  do {
    psVar11 = (sleep_param_t *)((int)&psVar8->param_flag + 2);
    uVar13 = psVar8->wifi_txiq[0] >> 6 & 0x1f;
    cVar12 = (char)uVar13;
    uVar15 = psVar8->wifi_txiq[0] & 0x3f;
    cVar14 = (char)uVar15;
    if (0xf < uVar13) {
      cVar12 = cVar12 + -0x20;
    }
    if (0x1f < uVar15) {
      cVar14 = cVar14 + -0x40;
    }
    if (print_en) {
      phy_printf("%d, %d; ",(int)cVar12,(int)cVar14);
    }
    psVar8 = psVar11;
  } while (psVar11 != (sleep_param_t *)chip7_sleep_params.target_power_chan_backoff);
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("TXDC, ");
  }
  do {
    if (print_en) {
      phy_printf("%d, %d, %d, %d; ",psVar8->txdc_table[0],psVar8->txdc_table[1],
                 psVar8->txdc_table[2],psVar8->txdc_table[3]);
    }
    psVar5 = psVar8->target_power_chan_backoff;
    psVar8 = (sleep_param_t *)(psVar5 + 2);
  } while ((sleep_param_t *)(psVar5 + 2) != (sleep_param_t *)(chip7_sleep_params.txdc_table + 0xe));
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("BT_PA_GAIN, ");
  }
  do {
    if (print_en) {
      phy_printf("0x%x, ",psVar8->bt_pa_gain[0]);
    }
    psVar8 = (sleep_param_t *)((int)&psVar8->param_flag + 1);
  } while (psVar8 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("BT_DIG_ATTEN, ");
  }
  do {
    if (print_en) {
      phy_printf(&DAT_00055450,(int)psVar8->bt_dig_atten[0]);
    }
    psVar8 = (sleep_param_t *)((int)&psVar8->param_flag + 1);
  } while (psVar8 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("BT_TX_BB, 0x%x\n",chip7_sleep_params.bt_bb_gain);
    phy_printf("delta_bt_atten, ");
  }
  do {
    if (print_en) {
      phy_printf(&DAT_00055450,(int)psVar8->delta_bt_atten[0]);
    }
    psVar8 = (sleep_param_t *)((int)&psVar8->param_flag + 1);
  } while (psVar8 != (sleep_param_t *)((int)chip7_sleep_params.target_power_chan_backoff + 1));
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("BT_TXIQ,");
  }
  do {
    psVar11 = (sleep_param_t *)((int)&psVar8->param_flag + 2);
    uVar13 = psVar8->bt_txiq[0] >> 6 & 0x1f;
    cVar12 = (char)uVar13;
    uVar15 = psVar8->bt_txiq[0] & 0x3f;
    cVar14 = (char)uVar15;
    if (0xf < uVar13) {
      cVar12 = cVar12 + -0x20;
    }
    if (0x1f < uVar15) {
      cVar14 = cVar14 + -0x40;
    }
    if (print_en) {
      phy_printf("%d, %d; ",(int)cVar12,(int)cVar14);
    }
    psVar8 = psVar11;
  } while (psVar11 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 1));
  psVar8 = psVar6;
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("BT_TXDC, ");
  }
  do {
    if (print_en) {
      phy_printf("%d, %d, %d, %d; ",psVar8->bt_txdc_table[0],psVar8->bt_txdc_table[1],
                 psVar8->bt_txdc_table[2],psVar8->bt_txdc_table[3]);
    }
    psVar5 = psVar8->target_power_chan_backoff;
    psVar8 = (sleep_param_t *)(psVar5 + 2);
  } while ((sleep_param_t *)(psVar5 + 2) != (sleep_param_t *)(chip7_sleep_params.txdc_table + 6));
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("RXIQ, ");
  }
  do {
    puVar1 = psVar6->wifi_rxiq;
    psVar6 = (sleep_param_t *)((int)&psVar6->param_flag + 2);
    uVar13 = *puVar1 >> 6 & 0x1f;
    cVar12 = (char)uVar13;
    uVar15 = *puVar1 & 0x3f;
    cVar14 = (char)uVar15;
    if (0xf < uVar13) {
      cVar12 = cVar12 + -0x20;
    }
    if (0x1f < uVar15) {
      cVar14 = cVar14 + -0x40;
    }
    if (print_en) {
      phy_printf("%d, %d; ",(int)cVar12,(int)cVar14);
    }
  } while (psVar6 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("RXDC_RFRX_BT, ");
  }
  puVar9 = phy_rxrf_dc;
  puVar7 = phy_rxrf_dc + 9;
  do {
    if (print_en) {
      phy_printf("%d, %d; ",(int)*puVar9 >> 0x10,(int)(short)*puVar9);
    }
    puVar9 = puVar9 + 1;
  } while (puVar9 != phy_rxrf_dc + 9);
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("RXDC_RFRX_WIFI, ");
  }
  do {
    puVar7 = puVar7 + 1;
    if (print_en) {
      phy_printf("%d, %d; ");
    }
  } while (puVar7 != (uint32 *)&para_num);
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("RXDC_RXBB_WIFI, ");
  }
  puVar7 = phy_rxbb_dc;
  do {
    if (print_en) {
      phy_printf("%d, %d; ",(int)*puVar7 >> 0x10,(int)(short)*puVar7);
    }
    puVar7 = (uint32 *)((int)puVar7 + 4);
  } while ((code *)puVar7 != ets_isr_attach);
  if (print_en) {
    phy_printf(&DAT_00055458);
    phy_printf("TX_VDD33=%d\n",uStack_30);
    return;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0003306f)
// WARNING: Removing unreachable block (ram,0x000330ae)

S16 linear_to_db_64bits(uint64 power_sig,uint8 frac_bits)

{
  uint in_a3;
  uint uVar1;
  uint in_a4;
  uint uVar2;
  short sVar3;
  uint uVar4;
  uint uVar5;
  U8 db_table [16];
  
  uVar2 = in_a4 & 0xff;
  memcpy(db_table,&DAT_000527e4,0x10);
  if (uVar2 < 3) {
    uVar2 = 3 - uVar2;
    uVar4 = (uint)frac_bits << 0x20 - (0x20 - (uVar2 & 0x1f));
    uVar1 = in_a3 << 0x20 - (0x20 - (uVar2 & 0x1f));
    uVar5 = uVar4;
    if ((uVar2 & 0x20) != 0) {
      uVar5 = 0;
      uVar1 = uVar4;
    }
  }
  else {
    uVar2 = uVar2 - 3;
    uVar4 = in_a3 >> (uVar2 & 0x1f);
    uVar1 = uVar4;
    uVar5 = (in_a3 << 1) << 0x20 - (0x20 - ((uVar2 ^ 0xffffffff) & 0x1f)) |
            (uint)(frac_bits >> (uVar2 & 0x1f));
    if ((uVar2 & 0x20) != 0) {
      uVar1 = 0;
      uVar5 = uVar4;
    }
  }
  if ((int)uVar1 < 0) {
    sVar3 = 0x3c;
    uVar5 = uVar1 >> 0x1b;
  }
  else {
    sVar3 = -1;
  }
  return (ushort)db_table[uVar5 & 0xf] + sVar3 * 0x30;
}



// WARNING: Unknown calling convention

S16 get_iq_est_snr(uint64 *get_power,uint8 shift_bits,bool print_en)

{
  uint uVar1;
  uint uVar2;
  longlong lVar3;
  S16 SVar4;
  S16 SVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  int iVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  uint uVar26;
  ulonglong uVar27;
  ulonglong uVar28;
  ulonglong uVar29;
  ulonglong uVar30;
  ulonglong uVar31;
  ulonglong uVar32;
  uint in_stack_ffffffa0;
  uint in_stack_ffffffa4;
  
  iVar6 = esp_dport_access_reg_read(0x3ff46080);
  iVar7 = esp_dport_access_reg_read(0x3ff4608c);
  uVar16 = iVar6 + iVar7;
  uVar27 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar6 = (int)uVar27;
  iVar7 = esp_dport_access_reg_read(0x3ff46084);
  iVar8 = esp_dport_access_reg_read(0x3ff46088);
  uVar16 = iVar7 - iVar8;
  uVar28 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar7 = (int)uVar28;
  iVar8 = esp_dport_access_reg_read(0x3ff460cc);
  iVar9 = esp_dport_access_reg_read(0x3ff460d8);
  uVar16 = iVar8 + iVar9;
  uVar29 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar8 = (int)uVar29;
  iVar9 = esp_dport_access_reg_read(0x3ff460d0);
  iVar10 = esp_dport_access_reg_read(0x3ff460d4);
  uVar16 = iVar9 - iVar10;
  uVar30 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar9 = (int)uVar30;
  uVar16 = iVar6 * iVar6 + iVar7 * iVar7;
  uVar13 = uVar16 + iVar8 * iVar8;
  uVar22 = uVar13 + iVar9 * iVar9;
  iVar17 = (uint)(uVar22 < uVar13) +
           (uint)(uVar13 < uVar16) +
           (uint)(uVar16 < (uint)(iVar6 * iVar6)) +
           (int)(uVar27 >> 0x20) * iVar6 * 2 +
           (int)((uVar27 & 0xffffffff) * (uVar27 & 0xffffffff) >> 0x20) +
           (int)(uVar28 >> 0x20) * iVar7 * 2 +
           (int)((uVar28 & 0xffffffff) * (uVar28 & 0xffffffff) >> 0x20) +
           (int)(uVar29 >> 0x20) * iVar8 * 2 +
           (int)((uVar29 & 0xffffffff) * (uVar29 & 0xffffffff) >> 0x20) +
           (int)(uVar30 >> 0x20) * iVar9 * 2 +
           (int)((uVar30 & 0xffffffff) * (uVar30 & 0xffffffff) >> 0x20);
  *(uint *)(get_power + 4) = uVar22;
  *(int *)((int)get_power + 0x24) = iVar17;
  iVar6 = esp_dport_access_reg_read(0x3ff46080);
  iVar7 = esp_dport_access_reg_read(0x3ff4608c);
  uVar16 = iVar6 - iVar7;
  uVar29 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar6 = (int)uVar29;
  iVar7 = esp_dport_access_reg_read(0x3ff46084);
  iVar8 = esp_dport_access_reg_read(0x3ff46088);
  uVar16 = iVar7 + iVar8;
  uVar30 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar7 = (int)uVar30;
  iVar8 = esp_dport_access_reg_read(0x3ff460cc);
  iVar9 = esp_dport_access_reg_read(0x3ff460d8);
  uVar16 = iVar8 - iVar9;
  uVar31 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar8 = (int)uVar31;
  iVar9 = esp_dport_access_reg_read(0x3ff460d0);
  iVar10 = esp_dport_access_reg_read(0x3ff460d4);
  uVar16 = iVar9 + iVar10;
  uVar32 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar9 = (int)uVar32;
  uVar16 = iVar6 * iVar6 + iVar7 * iVar7;
  uVar14 = uVar16 + iVar8 * iVar8;
  uVar13 = uVar14 + iVar9 * iVar9;
  iVar6 = (uint)(uVar13 < uVar14) +
          (uint)(uVar14 < uVar16) +
          (uint)(uVar16 < (uint)(iVar6 * iVar6)) +
          (int)(uVar29 >> 0x20) * iVar6 * 2 +
          (int)((uVar29 & 0xffffffff) * (uVar29 & 0xffffffff) >> 0x20) +
          (int)(uVar30 >> 0x20) * iVar7 * 2 +
          (int)((uVar30 & 0xffffffff) * (uVar30 & 0xffffffff) >> 0x20) +
          (int)(uVar31 >> 0x20) * iVar8 * 2 +
          (int)((uVar31 & 0xffffffff) * (uVar31 & 0xffffffff) >> 0x20) +
          (int)(uVar32 >> 0x20) * iVar9 * 2 +
          (int)((uVar32 & 0xffffffff) * (uVar32 & 0xffffffff) >> 0x20);
  uVar11 = uVar22 + uVar13;
  *(uint *)(get_power + 3) = uVar13;
  *(int *)((int)get_power + 0x1c) = iVar6;
  uVar13 = (uint)(uVar27 * uVar29);
  uVar14 = (uint)(uVar11 < uVar22) + iVar17 + iVar6;
  uVar16 = uVar13 - (int)(uVar28 * uVar30);
  lVar3 = uVar29 * uVar28 + uVar30 * uVar27;
  *(uint *)(get_power + 5) = uVar16;
  *(uint *)((int)get_power + 0x2c) =
       ((int)(uVar27 * uVar29 >> 0x20) - (int)(uVar28 * uVar30 >> 0x20)) - (uint)(uVar13 < uVar16);
  *(int *)(get_power + 6) = (int)lVar3;
  *(int *)((int)get_power + 0x34) = (int)((ulonglong)lVar3 >> 0x20);
  iVar6 = esp_dport_access_reg_read(0x3ff460dc);
  iVar6 = iVar6 >> 4;
  iVar7 = esp_dport_access_reg_read(0x3ff460e0);
  iVar7 = iVar7 >> 4;
  uVar15 = iVar6 * iVar6 + iVar7 * iVar7;
  uVar22 = (uint)(uVar15 < (uint)(iVar6 * iVar6)) +
           (int)((ulonglong)((longlong)iVar6 * (longlong)iVar6) >> 0x20) +
           (int)((ulonglong)((longlong)iVar7 * (longlong)iVar7) >> 0x20);
  uVar16 = esp_dport_access_reg_read(0x3ff460e4);
  uVar23 = shift_bits + 7;
  uVar12 = uVar16 << 0x20 - (0x20 - (uVar23 & 0x1f));
  uVar13 = uVar12;
  uVar16 = (uVar16 >> 1) >> ((uVar23 & 0xff ^ 0xffffffff) & 0x1f) |
           ((int)uVar16 >> 0x1f) << 0x20 - (0x20 - (uVar23 & 0x1f));
  if ((uVar23 & 0x20) != 0) {
    uVar13 = 0;
    uVar16 = uVar12;
  }
  uVar19 = uVar13 - uVar15;
  uVar12 = uVar19 - uVar11;
  iVar6 = (((uVar16 - uVar22) - (uint)(uVar13 < uVar19)) - uVar14) - (uint)(uVar19 < uVar12);
  if (iVar6 < 0) {
    uVar12 = 0;
    iVar6 = 0;
  }
  if (print_en) {
    uVar24 = (uVar23 & 0xff) + 0xb;
    uVar18 = uVar24 ^ 0xffffffff;
    uVar21 = uVar16 >> (uVar24 & 0x1f);
    uVar26 = uVar14 >> (uVar24 & 0x1f);
    uVar20 = iVar6 >> (uVar24 & 0x1f);
    uVar25 = uVar22 >> (uVar24 & 0x1f);
    in_stack_ffffffa4 = uVar25;
    uVar23 = uVar21;
    in_stack_ffffffa0 = uVar22 * 2 << 0x20 - (0x20 - (uVar18 & 0x1f)) | uVar15 >> (uVar24 & 0x1f);
    uVar19 = uVar26;
    uVar1 = (uVar16 << 1) << 0x20 - (0x20 - (uVar18 & 0x1f)) | uVar13 >> (uVar24 & 0x1f);
    uVar2 = uVar14 * 2 << 0x20 - (0x20 - (uVar18 & 0x1f)) | uVar11 >> (uVar24 & 0x1f);
    uVar18 = (iVar6 << 1) << 0x20 - (0x20 - (uVar18 & 0x1f)) | uVar12 >> (uVar24 & 0x1f);
    if ((uVar24 & 0x20) != 0) {
      uVar19 = 0;
      uVar23 = 0;
      in_stack_ffffffa4 = 0;
      in_stack_ffffffa0 = uVar25;
      uVar1 = uVar21;
      uVar2 = uVar26;
      uVar18 = uVar20;
      uVar20 = iVar6 >> 0x1f;
    }
    phy_printf("total_power=%lld, sig_power=%lld, dc_power=%lld, noise_power=%lld\n",
               in_stack_ffffffa4,uVar1,uVar23,uVar2,uVar19,in_stack_ffffffa0,in_stack_ffffffa4,
               uVar18,uVar20);
  }
  *(uint *)((int)get_power + 0xc) = uVar14;
  *(uint *)get_power = uVar13;
  *(uint *)(get_power + 2) = uVar15;
  *(uint *)((int)get_power + 4) = uVar16;
  *(uint *)(get_power + 1) = uVar11;
  *(uint *)((int)get_power + 0x14) = uVar22;
  SVar4 = linear_to_db_64bits(CONCAT44(in_stack_ffffffa4,in_stack_ffffffa0),(uint8)uVar11);
  SVar5 = linear_to_db_64bits(CONCAT44(in_stack_ffffffa4,in_stack_ffffffa0),(uint8)uVar12);
  return SVar4 - SVar5;
}



// WARNING: Variable defined which should be unmapped: get_power
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void freq_offset_get_pwr(U8 loop_bits,S16 tone_step,U8 corr_cycle_bits,uint64 *pwr_sum,
                        S16 *rxiq_remain,bool rxiq_sign,bool print_en)

{
  S16 SVar1;
  S16 SVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  int iVar10;
  uint uVar11;
  uint uVar12;
  short sVar13;
  _func_void_varargs *p_Var14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint64 get_power [7];
  uint uStack_70;
  uint uStack_6c;
  uint uStack_60;
  uint uStack_5c;
  
  uVar3 = (uint)loop_bits;
  uVar8 = (uint)tone_step;
  (*g_phyFuns->set_txclk_en_)(true);
  uVar4 = esp_dport_access_reg_read(&DAT_3ff450a8);
  _DAT_3ff450a8 = uVar4 & 0xfffffffc | uVar8 & 3;
  memw();
  uVar5 = esp_dport_access_reg_read(&DAT_3ff460b8);
  uVar4 = 0;
  _DAT_3ff460b8 = (int)uVar8 >> 2 & 0xfdbffffU | 0x240000 | uVar5 & 0xf0000000;
  iVar10 = 1 << 0x20 - (0x20 - (uVar3 & 0x1f));
  memw();
  *(undefined4 *)pwr_sum = 0;
  *(undefined4 *)((int)pwr_sum + 4) = 0;
  *(undefined4 *)(pwr_sum + 1) = 0;
  *(undefined4 *)((int)pwr_sum + 0xc) = 0;
  *(undefined4 *)(pwr_sum + 2) = 0;
  *(undefined4 *)((int)pwr_sum + 0x14) = 0;
  *(undefined4 *)(pwr_sum + 3) = 0;
  *(undefined4 *)((int)pwr_sum + 0x1c) = 0;
  *(undefined4 *)(pwr_sum + 4) = 0;
  *(undefined4 *)((int)pwr_sum + 0x24) = 0;
  *(undefined4 *)(pwr_sum + 5) = 0;
  *(undefined4 *)((int)pwr_sum + 0x2c) = 0;
  *(undefined4 *)(pwr_sum + 6) = 0;
  *(undefined4 *)((int)pwr_sum + 0x34) = 0;
  if (iVar10 < 1) {
    uVar15 = 0;
    uVar16 = 0;
    uStack_60 = 0;
    uVar11 = 0;
    uVar7 = 0;
    uVar9 = 0;
    uVar17 = 0;
    uStack_5c = 0;
    uVar18 = 0;
    uVar5 = 0;
    uVar8 = 0;
    uStack_70 = 0;
    uStack_6c = 0;
  }
  else {
    do {
      (*g_phyFuns->iq_est_enable_)(true,(uint16)(1 << 0x20 - (0x20 - (corr_cycle_bits & 0x1f))));
      get_iq_est_snr(get_power,corr_cycle_bits,print_en);
      uVar5 = *(uint *)pwr_sum + (int)get_power[1];
      uVar18 = *(uint *)(pwr_sum + 1) + (int)get_power[0];
      *(uint *)((int)pwr_sum + 4) =
           (uint)(uVar5 < *(uint *)pwr_sum) + *(int *)((int)pwr_sum + 4) + get_power[1]._4_4_;
      *(uint *)pwr_sum = uVar5;
      uVar5 = *(uint *)(pwr_sum + 2) + (int)get_power[2];
      *(uint *)((int)pwr_sum + 0xc) =
           (uint)(uVar18 < *(uint *)(pwr_sum + 1)) +
           *(int *)((int)pwr_sum + 0xc) + get_power[0]._4_4_;
      *(uint *)(pwr_sum + 1) = uVar18;
      uVar18 = *(uint *)(pwr_sum + 3) + (int)get_power[3];
      *(uint *)((int)pwr_sum + 0x14) =
           (uint)(uVar5 < *(uint *)(pwr_sum + 2)) +
           *(int *)((int)pwr_sum + 0x14) + get_power[2]._4_4_;
      *(uint *)(pwr_sum + 2) = uVar5;
      uVar5 = *(uint *)(pwr_sum + 4) + (int)get_power[4];
      *(uint *)((int)pwr_sum + 0x1c) =
           (uint)(uVar18 < *(uint *)(pwr_sum + 3)) +
           *(int *)((int)pwr_sum + 0x1c) + get_power[3]._4_4_;
      *(uint *)(pwr_sum + 3) = uVar18;
      uVar18 = *(uint *)(pwr_sum + 5) + (int)get_power[5];
      *(uint *)((int)pwr_sum + 0x24) =
           (uint)(uVar5 < *(uint *)(pwr_sum + 4)) +
           *(int *)((int)pwr_sum + 0x24) + get_power[4]._4_4_;
      *(uint *)(pwr_sum + 4) = uVar5;
      uVar17 = *(uint *)(pwr_sum + 6);
      uVar5 = uVar17 + (int)get_power[6];
      *(uint *)((int)pwr_sum + 0x2c) =
           (uint)(uVar18 < *(uint *)(pwr_sum + 5)) +
           *(int *)((int)pwr_sum + 0x2c) + get_power[5]._4_4_;
      *(uint *)(pwr_sum + 5) = uVar18;
      p_Var14 = g_phyFuns->iq_est_disable_;
      *(uint *)(pwr_sum + 6) = uVar5;
      *(uint *)((int)pwr_sum + 0x34) =
           (uint)(uVar5 < uVar17) + *(int *)((int)pwr_sum + 0x34) + get_power[6]._4_4_;
      (*p_Var14)();
      if (print_en) {
        phy_printf("step=%d, %d\n",uVar8,uVar4);
      }
      uVar4 = uVar4 + 1 & 0xff;
    } while ((int)uVar4 < iVar10);
    uVar8 = *(uint *)((int)pwr_sum + 4) >> (uVar3 & 0x1f);
    uVar5 = (*(uint *)((int)pwr_sum + 4) << 1) << 0x20 - (0x20 - ((uVar3 ^ 0xffffffff) & 0x1f)) |
            *(uint *)pwr_sum >> (uVar3 & 0x1f);
    if ((loop_bits & 0x20) != 0) {
      uVar5 = uVar8;
    }
    if ((loop_bits & 0x20) != 0) {
      uVar8 = 0;
    }
    uVar17 = *(uint *)(pwr_sum + 1) - *(uint *)(pwr_sum + 2);
    uVar6 = *(uint *)((int)pwr_sum + 0x14);
    uVar4 = (*(int *)((int)pwr_sum + 0xc) - uVar6) - (uint)(*(uint *)(pwr_sum + 1) < uVar17);
    uVar12 = uVar3 ^ 0xffffffff;
    uVar18 = uVar4 >> (uVar3 & 0x1f);
    uStack_6c = uVar6 >> (uVar3 & 0x1f);
    uVar17 = uVar4 * 2 << 0x20 - (0x20 - (uVar12 & 0x1f)) | uVar17 >> (uVar3 & 0x1f);
    if ((loop_bits & 0x20) != 0) {
      uVar17 = uVar18;
    }
    uVar9 = *(uint *)((int)pwr_sum + 0x1c) >> (uVar3 & 0x1f);
    uVar11 = *(uint *)((int)pwr_sum + 0x24) >> (uVar3 & 0x1f);
    uVar4 = (*(int *)((int)pwr_sum + 0x24) << 1) << 0x20 - (0x20 - (uVar12 & 0x1f)) |
            *(uint *)(pwr_sum + 4) >> (uVar3 & 0x1f);
    if ((loop_bits & 0x20) != 0) {
      uVar4 = uVar11;
    }
    uStack_5c = *(uint *)((int)pwr_sum + 0x2c) >> (uVar3 & 0x1f);
    uVar7 = (*(int *)((int)pwr_sum + 0x1c) << 1) << 0x20 - (0x20 - (uVar12 & 0x1f)) |
            *(uint *)(pwr_sum + 3) >> (uVar3 & 0x1f);
    if ((loop_bits & 0x20) != 0) {
      uVar7 = uVar9;
    }
    uVar16 = *(uint *)((int)pwr_sum + 0x34) >> (uVar3 & 0x1f);
    uVar15 = (*(int *)((int)pwr_sum + 0x34) << 1) << 0x20 - (0x20 - (uVar12 & 0x1f)) |
             *(uint *)(pwr_sum + 6) >> (uVar3 & 0x1f);
    if ((loop_bits & 0x20) != 0) {
      uVar15 = uVar16;
    }
    uStack_70 = uStack_6c;
    if ((loop_bits & 0x20) == 0) {
      uStack_70 = (uVar6 << 1) << 0x20 - (0x20 - (uVar12 & 0x1f)) |
                  *(uint *)(pwr_sum + 2) >> (uVar3 & 0x1f);
    }
    uStack_60 = uStack_5c;
    if ((loop_bits & 0x20) == 0) {
      uStack_60 = (*(int *)((int)pwr_sum + 0x2c) << 1) << 0x20 - (0x20 - (uVar12 & 0x1f)) |
                  *(uint *)(pwr_sum + 5) >> (uVar3 & 0x1f);
    }
    if ((loop_bits & 0x20) != 0) {
      uStack_6c = 0;
      uVar18 = 0;
      uVar9 = 0;
    }
    if ((loop_bits & 0x20) != 0) {
      uVar11 = 0;
      uVar16 = 0;
    }
    if ((loop_bits & 0x20) != 0) {
      uStack_5c = 0;
    }
  }
  *(uint *)(pwr_sum + 1) = uVar17;
  *(uint *)((int)pwr_sum + 0xc) = uVar18;
  *(uint *)((int)pwr_sum + 0x2c) = uStack_5c;
  *(uint *)(pwr_sum + 2) = uStack_70;
  *(uint *)pwr_sum = uVar5;
  *(uint *)((int)pwr_sum + 4) = uVar8;
  *(uint *)((int)pwr_sum + 0x14) = uStack_6c;
  *(uint *)(pwr_sum + 3) = uVar7;
  *(uint *)((int)pwr_sum + 0x1c) = uVar9;
  *(uint *)(pwr_sum + 4) = uVar4;
  *(uint *)((int)pwr_sum + 0x24) = uVar11;
  *(uint *)(pwr_sum + 5) = uStack_60;
  *(uint *)(pwr_sum + 6) = uVar15;
  *(uint *)((int)pwr_sum + 0x34) = uVar16;
  if (rxiq_sign) {
    SVar1 = linear_to_db_64bits(CONCAT44(get_power[0]._4_4_,(int)get_power[0]),(uint8)uVar4);
    SVar2 = linear_to_db_64bits(CONCAT44(get_power[0]._4_4_,(int)get_power[0]),
                                (char)uVar5 - (uint8)uVar4);
    sVar13 = SVar1 - SVar2;
  }
  else {
    SVar1 = linear_to_db_64bits(CONCAT44(get_power[0]._4_4_,(int)get_power[0]),(uint8)uVar7);
    SVar2 = linear_to_db_64bits(CONCAT44(get_power[0]._4_4_,(int)get_power[0]),
                                (char)uVar5 - (uint8)uVar7);
    sVar13 = SVar1 - SVar2;
  }
  *rxiq_remain = (S16)(sVar13 + 8 >> 4);
  memw();
  _DAT_3ff460b8 = esp_dport_access_reg_read(&DAT_3ff460b8);
  _DAT_3ff460b8 = _DAT_3ff460b8 & 0xfffbffff;
  memw();
  (*g_phyFuns->set_txclk_en_)(false);
  return;
}



// WARNING: Unknown calling convention

void get_corr_power(int *power,U8 shift_bits,bool print_en)

{
  int iVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int dc_q;
  int dc_i;
  int iVar7;
  uint uVar8;
  
  uVar4 = (uint)shift_bits;
  iVar1 = esp_dport_access_reg_read(0x3ff46080);
  iVar2 = esp_dport_access_reg_read(0x3ff4608c);
  iVar7 = (iVar1 >> 9) + (iVar2 >> 9);
  iVar1 = esp_dport_access_reg_read(0x3ff46084);
  iVar2 = esp_dport_access_reg_read(0x3ff46088);
  iVar6 = (iVar1 >> 9) - (iVar2 >> 9);
  iVar1 = esp_dport_access_reg_read(0x3ff460dc);
  iVar1 = iVar1 >> (uVar4 + 6 & 0x1f);
  iVar2 = esp_dport_access_reg_read(0x3ff460e0);
  iVar2 = iVar2 >> (uVar4 + 6 & 0x1f);
  iVar3 = esp_dport_access_reg_read(0x3ff460e4);
  iVar3 = iVar3 >> (uVar4 - 3 & 0x1f);
  uVar8 = iVar7 * iVar7 + iVar6 * iVar6;
  *power = iVar3;
  uVar5 = (uVar4 - 2) * 2;
  iVar6 = (uint)(uVar8 < (uint)(iVar7 * iVar7)) +
          (int)((ulonglong)((longlong)iVar7 * (longlong)iVar7) >> 0x20) +
          (int)((ulonglong)((longlong)iVar6 * (longlong)iVar6) >> 0x20);
  uVar4 = iVar6 * 2 << 0x20 - (0x20 - ((uVar5 ^ 0xffffffff) & 0x1f)) | uVar8 >> (uVar5 & 0x1f);
  if ((uVar5 >> 5 & 1) != 0) {
    uVar4 = iVar6 >> (uVar5 & 0x1f);
  }
  power[1] = uVar4;
  power[2] = iVar1 * iVar1 + iVar2 * iVar2;
  if (print_en) {
    phy_printf("tot_p=%d, sig_pwr=%d, dc_i=%d, dc_q=%d\n",iVar3,uVar4,iVar1,iVar2);
  }
  return;
}



// WARNING: Unknown calling convention

void test_set_rf_freq_offset(uint8 crystal_select,uint16 freq,sint16 freq_offset)

{
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\a','\a','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x02','\a','\a','\0');
  (*g_phyFuns->set_rf_freq_offset_)(crystal_select,freq,freq_offset);
  chip_v7_rxmax_ext_ana('\0');
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ate_rxdc_remain_check(void)

{
  uint uVar1;
  int iVar2;
  sint32 *psVar3;
  sint32 dc_est [9];
  int aiStack_3c [3];
  int iStack_30;
  
  iStack_30 = 1;
  do {
    chip_v7_set_chan((int8)iStack_30,'\0');
    _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = _DAT_3ff5c02c | 0x800000;
    iVar2 = 0x33;
    memw();
    do {
      uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
      _DAT_3ff5c02c = uVar1 & 0xffffff | iVar2 << 0x18;
      memw();
      (*g_phyFuns->dc_iq_est_)(true,4000,dc_est);
      (*g_phyFuns->dc_iq_est_)(true,4000,dc_est + 3);
      (*g_phyFuns->dc_iq_est_)(true,4000,dc_est + 6);
      psVar3 = dc_est;
      do {
        if (*psVar3 < 0x80) {
          if (*psVar3 < -0x7f) {
            *psVar3 = -0x7f;
          }
        }
        else {
          *psVar3 = 0x7f;
        }
        if (psVar3[1] < 0x80) {
          if (psVar3[1] < -0x7f) {
            psVar3[1] = -0x7f;
          }
        }
        else {
          psVar3[1] = 0x7f;
        }
        psVar3 = psVar3 + 3;
      } while (psVar3 != aiStack_3c);
      iVar2 = iVar2 + 3;
    } while (iVar2 != 0x3f);
    _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = _DAT_3ff5c02c & 0xff7fffff;
    iStack_30 = iStack_30 + 2;
    memw();
  } while (iStack_30 != 0xf);
  return;
}



// WARNING: Unknown calling convention

void txdc_delta_max(sint16 *delta,sint16 *delta_max)

{
  sint32 sVar1;
  sint32 sVar2;
  
  sVar1 = (*g_phyFuns->abs_temp_)((int)*delta);
  sVar2 = (*g_phyFuns->abs_temp_)((int)delta[1]);
  if (sVar2 < sVar1) {
    sVar1 = (*g_phyFuns->abs_temp_)((int)*delta_max);
    sVar2 = (*g_phyFuns->abs_temp_)((int)*delta);
    if (sVar2 <= sVar1) {
      return;
    }
  }
  else {
    sVar1 = (*g_phyFuns->abs_temp_)((int)delta_max[1]);
    sVar2 = (*g_phyFuns->abs_temp_)((int)delta[1]);
    if (sVar2 <= sVar1) {
      return;
    }
  }
  *delta_max = *delta;
  memw();
  delta_max[1] = delta[1];
  memw();
  return;
}



// WARNING: Unknown calling convention

void txdc_stable_sub(bool bt_mode,sint16 *txdc)

{
  short sVar1;
  short sVar2;
  char cVar3;
  u16 uVar4;
  short in_a5;
  short in_a6;
  _func_void_u8_u8_u16 *p_Var5;
  sint16 txdc_cal [4];
  sint16 delta_max [2];
  sint16 delta [2];
  
  delta_max[0] = 0;
  delta_max[1] = 0;
  memw();
  (*g_phyFuns->pbus_debugmode_)();
  (*g_phyFuns->pbus_xpd_tx_on_)((ushort)bt_mode << 8,0x20);
  if (bt_mode) {
    p_Var5 = g_phyFuns->pbus_force_test_;
    uVar4 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
    (*p_Var5)('\x01','\x01',uVar4 | 2);
  }
  cVar3 = '\x01';
  do {
    (*g_phyFuns->txdc_cal_v70_)(txdc_cal);
    ets_delay_us(10);
    sVar1 = txdc_cal[0];
    sVar2 = txdc_cal[1];
    if (cVar3 != '\x01') {
      delta[0] = txdc_cal[0] - in_a5;
      delta[1] = txdc_cal[1] - in_a6;
      memw();
      txdc_delta_max(delta,delta_max);
      sVar1 = in_a5;
      sVar2 = in_a6;
      if (cVar3 == '\x14') {
        (*g_phyFuns->pbus_xpd_rx_on_)(0);
        (*g_phyFuns->pbus_workmode_)();
        *txdc = delta_max[0];
        memw();
        txdc[1] = delta_max[1];
        memw();
        return;
      }
    }
    in_a6 = sVar2;
    in_a5 = sVar1;
    cVar3 = cVar3 + '\x01';
  } while( true );
}



// WARNING: Unknown calling convention

void txdc_stable_test(bool print_en)

{
  int iVar1;
  sint16 *txdc;
  sint16 dc_delta [8];
  sint16 delta_max [2];
  
  txdc = dc_delta;
  iVar1 = 0;
  delta_max[0] = 0;
  delta_max[1] = 0;
  do {
    txdc_stable_sub(true,txdc);
    txdc_delta_max(txdc,delta_max);
    if (iVar1 != 3) {
      ets_delay_us(1000);
    }
    iVar1 = iVar1 + 1;
    txdc = txdc + 2;
  } while (iVar1 != 4);
  if (print_en) {
    phy_printf("txdc_stable,%d,%d\n",(int)delta_max[0],(int)delta_max[1]);
  }
  return;
}



// WARNING: Unknown calling convention

void rxspur_test(bool print_en)

{
  uint32 uVar1;
  uint32 uVar2;
  uint8 uVar3;
  uint8 uVar4;
  uint8 uVar5;
  uint8 dac_org;
  uint32 rx_pwr2 [2];
  uint32 rx_pwr1 [2];
  uint8 set_dac1;
  
  uVar3 = (*g_phyFuns->i2c_readReg_)('h','\x03','\0');
  uVar4 = (*g_phyFuns->i2c_readReg_)('f','\x04','\x05');
  (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\a','\x06','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\n','\x05','\x04','\0');
  set_chan_freq_sw_start('T',0,chip7_phy_init_ctrl.crystal_select);
  uVar5 = rx_spur_cal(false,false,rx_pwr1);
  get_spur4m_pwr(rx_pwr2);
  if (rx_pwr1[0] < rx_pwr2[0]) {
    rx_pwr1[0] = rx_pwr2[0];
    rx_pwr1[1] = rx_pwr2[1];
  }
  uVar2 = rx_pwr1[1];
  uVar1 = rx_pwr1[0];
  (*g_phyFuns->i2c_writeReg_)('h','\x03','\0',uVar3);
  (*g_phyFuns->i2c_writeReg_)('f','\x04','\x05',uVar4);
  (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\n','\x05','\x04','\x01');
  if (print_en) {
    phy_printf("2480,%d,%d,%d,%d\n",uVar5,rx_pwr1[0],rx_pwr1[1],(uVar1 * 100) / uVar2 & 0xff);
  }
  return;
}



// WARNING: Unknown calling convention

void ate_rfpll_cap_sign(bool print_en_in)

{
  byte bVar1;
  uint8 uVar2;
  uint8 *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  short sVar10;
  int8 channel;
  uint uVar11;
  uint uVar12;
  uint8 sign_num [8];
  ushort uVar3;
  
  puVar4 = sign_num;
  iVar8 = 0;
  sign_num[0] = '\0';
  sign_num[1] = '\0';
  sign_num[2] = '\0';
  sign_num[3] = '\0';
  sign_num[4] = '\0';
  sign_num[5] = '\0';
  sign_num[6] = '\0';
  sign_num[7] = '\0';
  do {
    channel = '\x01';
    if (iVar8 != 0) {
      channel = '\x0e';
    }
    chip_v7_set_chan(channel,'\0');
    bVar1 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\x01','\a','\0');
    uVar3 = (ushort)bVar1;
    sVar10 = uVar3 - 10;
    do {
      (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x01','\a','\0',(uint8)sVar10);
      ets_delay_us(0x14);
      uVar2 = (*g_phyFuns->i2c_readReg_)('b','\x01','\x05');
      if (uVar2 == '\x01') {
        if ((((char *)puVar4)[1] == '\0') && (((char *)puVar4)[2] == '\0')) {
          *puVar4 = *puVar4 + '\x01';
          memw();
        }
      }
      else if (uVar2 == '\0') {
        if ((*puVar4 != '\0') && (((char *)puVar4)[2] == '\0')) {
          ((char *)puVar4)[1] = ((char *)puVar4)[1] + '\x01';
          memw();
        }
      }
      else if (((uVar2 == '\x02') && (*puVar4 != '\0')) && (((char *)puVar4)[1] != '\0')) {
        ((char *)puVar4)[2] = ((char *)puVar4)[2] + '\x01';
        memw();
      }
      if (print_en_in) {
        phy_printf("i:%d,cap:%d,cap_set:%d,cap_sign:%d\n",iVar8,uVar3,sVar10,uVar2);
      }
      sVar10 = sVar10 + 1;
    } while ((ushort)(uVar3 + 0xb) != sVar10);
    iVar8 = iVar8 + 1;
    puVar4 = (uint8 *)((char *)puVar4 + 4);
  } while (iVar8 != 2);
  uVar11 = (uint)sign_num._0_4_ >> 8 & 0xff;
  uVar9 = sign_num._0_4_ & 0xff;
  uVar12 = (uint)sign_num._0_4_ >> 0x10 & 0xff;
  uVar5 = sign_num._4_4_ & 0xff;
  uVar6 = (uint)sign_num._4_4_ >> 8 & 0xff;
  uVar7 = (uint)sign_num._4_4_ >> 0x10 & 0xff;
  phy_printf("cap_sign_num: ");
  phy_printf("%d,%d,%d,%d; ",uVar9,uVar11,uVar12,uVar12 + uVar9 + uVar11 & 0xff);
  phy_printf("%d,%d,%d,%d\n",uVar5,uVar6,uVar7,uVar7 + uVar5 + uVar6 & 0xff);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rftest_init(void)

{
  u8 rf_cal_data [2048];
  rwip_rf_api api;
  
  memw();
  _DAT_3ff000c0 = 0xffffffff;
  memw();
  _DAT_3ff000cc = 0xffffffff;
  memw();
  _DAT_3ff4808c = 0;
  memw();
  _DAT_3ff5f048 = 0;
  re_entry = '\0';
  memw();
  register_chipv7_phy((u8 *)init_param_default,rf_cal_data,'\x02');
  coex_bt_high_prio();
  rf_rw_init(&api);
  mac_init();
  tx_rf_ana_gain_init[0] = tx_rf_ana_gain[0];
  tx_rf_ana_gain_init[1] = tx_rf_ana_gain[1];
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void esp_en_reboot(void)

{
  uint uVar1;
  
  esp_dport_access_reg_read(&DAT_3ff48090);
  memw();
  _DAT_3ff48090 = 0;
  esp_dport_access_reg_read(&DAT_3ff48094);
  memw();
  _DAT_3ff48094 = 0;
  esp_dport_access_reg_read(&DAT_3ff48098);
  memw();
  _DAT_3ff48098 = 0;
  esp_dport_access_reg_read(&DAT_3ff4809c);
  memw();
  _DAT_3ff4809c = 0;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4808c);
  _DAT_3ff4808c = uVar1 & 0x8fffffff | 0x40000000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4808c);
  memw();
  _DAT_3ff4808c = uVar1 | 0x80000000;
  return;
}



// WARNING: Unknown calling convention

void cbw40m_en(bool en)

{
  memw();
  tx_cbw40m_en = en;
  phy_printf("cbw40m_en: %d\n",en);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void wifitxout_func(uint32 *para_array,uint32 para_num)

{
  bool bVar1;
  bool bVar2;
  u32 uVar3;
  undefined uVar4;
  uint uVar5;
  u32 rate;
  u32 rate_00;
  uint32 uVar6;
  int iVar7;
  int8 sub_chan_cfg;
  uint uStack_28;
  
  uVar3 = short_gi_enable;
  uVar6 = *para_array;
  iVar7 = 0;
  rate_00 = para_array[1];
  if (2 < para_num) {
    iVar7 = (int)(char)para_array[2];
  }
  change_data_rate(rate_00);
  bVar2 = phy_tx_pwr_track_en;
  bVar1 = phy_tx_pwr_correct_en;
  fcc_mode_flag = '\x01';
  memw();
  phy_printf("Wifi tx out: channel=%d, rate=0x%x, BK=%d, length=%d, delay=%d\n",uVar6,rate_00,iVar7,
             0xfff,0);
  sub_chan_cfg = '\x02';
  if (tx_cbw40m_en == false) {
    sub_chan_cfg = '\0';
  }
  RFChannelSel((int8)uVar6,sub_chan_cfg);
  if (uVar6 == 0xe) {
    tx_cont_cfg('\0');
    uVar5 = esp_dport_access_reg_read(&DAT_3ff5c400);
    uStack_28 = (uVar5 & 0x6000) >> 0xd;
    uVar5 = esp_dport_access_reg_read(&DAT_3ff5c400);
    _DAT_3ff5c400 = uVar5 & 0xffff9fff | 0x2000;
    memw();
  }
  else if (rc_cal_en == false) {
    tx_cont_cfg('\x01');
  }
  remove_11b_4p8G_spur('\x01','\x02','\x14');
  target_power_backoff((S8)iVar7);
  FillTxPacket(0xa0fff,0x1c,0,0,0,uVar3 << 0x1c,1,2,3,4,5,6);
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\a','\a','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x02','\x03','\0','\0');
  WifiTxStart(rate_00 + 0xa0000,0,0,(uint)tx_cbw40m_en,0,1);
  if (uVar6 == 0xe) {
    uVar5 = esp_dport_access_reg_read(&DAT_3ff5c400);
    _DAT_3ff5c400 = uVar5 & 0xffff9fff | uStack_28 << 0xd;
    memw();
  }
  remove_11b_4p8G_spur('\0','\0','\0');
  memw();
  phy_tx_pwr_correct_en = bVar1;
  phy_tx_pwr_track_en = bVar2;
  uVar4 = esp_dport_access_reg_read(&DAT_60033c68);
  phy_printf("Tx Over\n",uVar4,rate_00,0xfff,uVar3);
  return;
}



// WARNING: Unknown calling convention

void esp_tx_func_org(uint32 *para_array,uint32 para_num)

{
  u32 uVar1;
  undefined uVar2;
  u32 uVar3;
  uint frame_delay;
  int iVar4;
  int iVar5;
  u32 rate;
  uint rate_00;
  char cVar6;
  int iVar7;
  uint32 uVar8;
  int8 sub_chan_cfg;
  int iVar9;
  uint32 uStack_30;
  uint32 uStack_2c;
  
  uVar1 = short_gi_enable;
  uVar8 = *para_array;
  rate_00 = para_array[1];
  if (para_num < 3) {
    iVar4 = 0;
    uStack_30 = 0;
    iVar7 = iVar4;
  }
  else {
    iVar4 = (int)(short)para_array[2];
    cVar6 = (char)para_array[2];
    if (para_num < 6) {
      iVar7 = (int)cVar6;
      uStack_30 = 0;
    }
    else {
      uStack_30 = para_array[5];
      iVar7 = (int)cVar6;
    }
  }
  uVar3 = change_data_rate(rate_00);
  iVar9 = 200;
  if ((3 < rate_00) && (iVar9 = 0x28, rate_00 < 8)) {
    iVar9 = 100;
  }
  iVar5 = 200;
  if (uVar3 < 0x14) {
    iVar5 = 600;
  }
  if (para_num < 4) {
    uStack_2c = (iVar5 - iVar9) * uVar3 >> 3;
  }
  else {
    uStack_2c = para_array[3];
    if (para_num != 4) {
      frame_delay = para_array[4];
      goto LAB_000346ec;
    }
  }
  frame_delay = 2000;
  if (uVar3 < 0x14) {
    frame_delay = 6000;
  }
LAB_000346ec:
  sub_chan_cfg = '\x02';
  if (tx_cbw40m_en == false) {
    sub_chan_cfg = '\0';
  }
  RFChannelSel((int8)uVar8,sub_chan_cfg);
  target_power_backoff((S8)iVar7);
  phy_printf("Wifi tx out: channel=%d, rate=0x%x, BK=%d, length=%d, delay=%d,packet_num=%d\n",uVar8,
             rate_00,iVar4,uStack_2c,frame_delay,uStack_30);
  FillTxPacket(uStack_2c + 0xa0000,0x1c,0,0,0,uVar1 << 0x1c,3,2,1,0x34,0xfe,0x18);
  WifiTxStart(rate_00 + 0xa0000,uStack_30,frame_delay,(uint)tx_cbw40m_en,0,1);
  uVar2 = esp_dport_access_reg_read(&DAT_60033c68);
  phy_printf("Tx Over 0x%x\n",uVar2);
  return;
}



// WARNING: Unknown calling convention

void esp_tx_func_notxon(u32 chan,u32 rate,u32 backoff,u32 pocket_len,u32 delay_time)

{
  u32 uVar1;
  undefined uVar2;
  int8 sub_chan_cfg;
  
  uVar1 = short_gi_enable;
  sub_chan_cfg = '\0';
  if (tx_cbw40m_en) {
    sub_chan_cfg = '\x02';
  }
  RFChannelSel((int8)chan,sub_chan_cfg);
  target_power_backoff((S8)backoff);
  phy_printf("Wifi tx out: channel=%d, rate=0x%x, BK=%d, length=%d, delay=%d\n",chan,rate,backoff,
             pocket_len,delay_time);
  FillTxPacket(pocket_len + 0xa0000,0x1c,0,0,0,uVar1 << 0x1c,1,2,3,4,5,6);
  WifiTxStart(rate + 0xa0000,0,delay_time,(uint)tx_cbw40m_en,0,1);
  uVar2 = esp_dport_access_reg_read(&DAT_60033c68);
  phy_printf("Tx Over 0x%x\n",uVar2);
  return;
}



// WARNING: Unknown calling convention

void esp_tx_func_duty(u32 chan,u32 rate,u32 backoff,u8 duty)

{
  u32 uVar1;
  undefined uVar2;
  u32 uVar3;
  uint frame_delay;
  int iVar4;
  uint uVar5;
  int8 sub_chan_cfg;
  int iVar6;
  
  uVar1 = short_gi_enable;
  uVar3 = change_data_rate(rate);
  phy_tx_pwr_track_en = true;
  memw();
  phy_tx_pwr_correct_en = true;
  memw();
  if (rate < 4) {
    iVar4 = 400;
    iVar6 = 200;
  }
  else if (rate < 8) {
    iVar4 = 500;
    iVar6 = 100;
  }
  else {
    iVar4 = 0xa0;
    iVar6 = 0x28;
  }
  uVar5 = uVar3 * iVar4 >> 3;
  iVar6 = (uVar5 << 3) / uVar3 + iVar6;
  sub_chan_cfg = '\x02';
  if (tx_cbw40m_en == false) {
    sub_chan_cfg = '\0';
  }
  frame_delay = ((100 - (uint)duty) * iVar6) / (uint)duty;
  RFChannelSel((int8)chan,sub_chan_cfg);
  target_power_backoff((S8)backoff);
  phy_printf("Wifi tx out: channel=%d, rate=0x%x, BK=%d, length=%d, delay=%d\n",chan,rate,backoff,
             iVar6,frame_delay);
  FillTxPacket(uVar5 + 0xa0000,0x1c,0,0,0,uVar1 << 0x1c,1,2,3,4,5,6);
  WifiTxStart(rate + 0xa0000,0,frame_delay,(uint)tx_cbw40m_en,0,1);
  uVar2 = esp_dport_access_reg_read(&DAT_60033c68);
  phy_printf("Tx Over 0x%x\n",uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void tx_contin_en(u8 contin_en)

{
  uint uVar1;
  
  memw();
  fcc_mode_sel = contin_en;
  if (contin_en == '\x01') {
    flash_test_enable = false;
    memw();
    psram_test_enable = false;
    memw();
    phy_printf("wifi tx continuous test!\n");
    uVar1 = esp_dport_access_reg_read(&DAT_600312e0);
    memw();
    _DAT_600312e0 = uVar1 & 0xfff87fff | 0x8000;
    return;
  }
  _DAT_600312e0 = esp_dport_access_reg_read(&DAT_600312e0);
  _DAT_600312e0 = _DAT_600312e0 & 0xfff87fff;
  memw();
  phy_printf("wifi tx packet test!\n");
  return;
}



// WARNING: Unknown calling convention

void wifitxout(uint32 *para_array,uint32 para_num)

{
  if (fcc_mode_sel == '\x01') {
    wifitxout_func(para_array,para_num);
    return;
  }
  esp_tx_func_org(para_array,para_num);
  return;
}



// WARNING: Unknown calling convention

void esp_tx_func(int *para_array,int para_num)

{
  if (fcc_mode_sel == '\x01') {
    wifitxout_func((uint32 *)para_array,para_num);
    return;
  }
  esp_tx_func_org((uint32 *)para_array,para_num);
  return;
}



// WARNING: Unknown calling convention

void esp_tx_func_5p(u32 chan,u32 rate,u32 backoff,u32 pocket_len,u32 delay_time)

{
  u32 para_array [5];
  
  para_array[0] = chan;
  para_array[1] = rate;
  para_array[2] = backoff;
  para_array[3] = pocket_len;
  para_array[4] = delay_time;
  if (fcc_mode_sel == '\x01') {
    wifitxout_func(para_array,5);
    return;
  }
  esp_tx_func_org(para_array,5);
  return;
}



// WARNING: Unknown calling convention

void wifiscwout(uint32 en,uint32 chan,uint32 backoff)

{
  char cVar1;
  uint uVar2;
  undefined4 uVar3;
  
  uVar2 = backoff & 3;
  uVar3 = 0;
  if (((uVar2 != 0) && (uVar3 = 0x19, uVar2 != 1)) && (uVar3 = 0x4b, uVar2 == 2)) {
    uVar3 = 0x32;
  }
  if (en != 0) {
    if (short_log_en) {
      phy_printf("wifi single carrier tx start: chan=%d, pwr=20-%d.%d\n",para_array[1],
                 para_array[2] >> 2,uVar3);
    }
    else {
      phy_printf(" wifi single carrier tx out, single carrier is in %d channel, power is about (20-%d.%d)dBm\n"
                 ,para_array[1],para_array[2] >> 2,uVar3);
    }
    RFChannelSel((int8)chan,'\0');
    txcal_debuge_mode(false);
    cVar1 = esp_dport_access_reg_read(&DAT_3ff46004);
    cVar1 = ((char)backoff + '+') - cVar1;
    (*g_phyFuns->start_tx_tone_step_)(true,0,(-1 < cVar1) * cVar1,false,0,'\0');
    return;
  }
  phy_printf(" wifi single carrier tx stop\n");
  (*g_phyFuns->start_tx_tone_step_)(false,0,'\0',false,0,'\0');
  (*g_phyFuns->txcal_work_mode_)();
  return;
}



// WARNING: Unknown calling convention

void esp_rx_func(uint32 chan,uint32 rate)

{
  int8 sub_chan_cfg;
  
  set_macrxfilter(mac_filter_en);
  setmacaddr(0x134fe18,0x5040302);
  if (rate < 8) {
    rx_gain_level(true);
  }
  sub_chan_cfg = '\0';
  if (tx_cbw40m_en != false) {
    sub_chan_cfg = '\x02';
  }
  RFChannelSel((int8)chan,sub_chan_cfg);
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\a','\a','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x02','\x03','\0','\0');
  (*g_phyFuns->set_noise_floor_)(-0x180);
  phy_printf("wifi rx start: channel is %d, rate is 0x%x\n",chan,rate);
  WifiRxStart(rate);
  if (rate < 8) {
    rx_gain_level(false);
  }
  return;
}



// WARNING: Unknown calling convention

void fcc_bt_tx_func(u32 txpwr,u32 hoppe,u32 chan,u32 rate,u32 DH_type,u32 data_type)

{
  u8 uVar1;
  
  uVar1 = fcc_mode_sel;
  if (hoppe != 0) {
    phy_printf("fcc_bt_tx: txpwr=%d, hoppe=%d, chan=%d, rate=%d, DH_type=%d, data_type=%d\n",txpwr,
               hoppe,chan,rate,DH_type,data_type);
    fcc_tx(txpwr,hoppe,chan,rate,DH_type,data_type,0);
    return;
  }
  if (fcc_mode_sel == '\x01') {
    set_chan_freq_sw_start((char)chan + '\x02',0,chip7_phy_init_ctrl.crystal_select);
    phy_dis_hw_set_freq();
    force_hw_set_freq_flag = (bool)uVar1;
    memw();
    bt_3200_opt(true);
  }
  phy_printf("fcc_bt_tx: txpwr=%d, hoppe=%d, chan=%d, rate=%d, DH_type=%d, data_type=%d\n",txpwr,0,
             chan,rate,DH_type,data_type);
  fcc_tx(txpwr,0,chan,rate,DH_type,data_type,0);
  if (fcc_mode_sel == '\x01') {
    bt_3200_opt(false);
    force_hw_set_freq_flag = false;
    memw();
    phy_en_hw_set_freq();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void fcc_le_tx_func(u32 txpwr,u32 chan,u32 len,u32 data_type)

{
  u8 uVar1;
  
  uVar1 = fcc_mode_sel;
  if (fcc_mode_sel == '\x01') {
    set_chan_freq_sw_start(((char)chan + '\x01') * '\x02',0,chip7_phy_init_ctrl.crystal_select);
    phy_dis_hw_set_freq();
    force_hw_set_freq_flag = (bool)uVar1;
    memw();
    bt_3200_opt(true);
  }
  phy_printf("fcc_le_tx: txpwr=%d, chan=%d, length=%d, data_type=%d\n",txpwr,chan,len,data_type);
  fcc_le_tx(txpwr,chan,len,data_type,0);
  if (fcc_mode_sel == '\x01') {
    bt_3200_opt(false);
    force_hw_set_freq_flag = false;
    memw();
    phy_en_hw_set_freq();
  }
  return;
}



// WARNING: Unknown calling convention

void fcc_le_tx_syncw_func(u32 txpwr,u32 chan,u32 len,u32 data_type,u32 syncw,u32 tx_num_in)

{
  u8 uVar1;
  
  uVar1 = fcc_mode_sel;
  if (fcc_mode_sel == '\x01') {
    set_chan_freq_sw_start(((char)chan + '\x01') * '\x02',0,chip7_phy_init_ctrl.crystal_select);
    phy_dis_hw_set_freq();
    force_hw_set_freq_flag = (bool)uVar1;
    memw();
    bt_3200_opt(true);
  }
  phy_printf("fcc_le_tx_syncw: txpwr=%d, chan=%d, length=%d, data_type=%d,syncword=0x%x\n",txpwr,
             chan,len,data_type,syncw);
  fcc_le_tx_syncw(txpwr,chan,len,data_type,syncw,tx_num_in);
  if (fcc_mode_sel == '\x01') {
    bt_3200_opt(false);
    force_hw_set_freq_flag = false;
    memw();
    phy_en_hw_set_freq();
  }
  return;
}



// WARNING: Unknown calling convention

void rw_rx_per_func(u32 edr,u32 chan,u32 ulap,u32 ltaddr)

{
  u8 uVar1;
  uint8 uVar2;
  _func_void_uint8_uint8_uint8_uint8 *p_Var3;
  
  uVar1 = fcc_mode_sel;
  if (fcc_mode_sel == '\x01') {
    bt_set_freq_cal(true,(uint8)chan,false);
    phy_dis_hw_set_freq();
    force_hw_set_freq_flag = (bool)uVar1;
    memw();
    bt_3200_opt(true);
    p_Var3 = g_phyFuns->i2c_writeReg_;
    uVar2 = get_rfrx_dcap_bt('\x04');
    (*p_Var3)('d','\0','\x04',uVar2);
    p_Var3 = g_phyFuns->i2c_writeReg_;
    uVar2 = get_rfrx_dcap_bt('\a');
    (*p_Var3)('d','\0','\a',uVar2);
  }
  bt_2480_opt_enter(chan);
  phy_printf("rw_rx_per:type=%d,chan=%d,ulap=0x%x,ltaddr=%d\n",edr,chan,ulap,ltaddr);
  rw_rx_per_ulap(edr,chan,ulap,ltaddr);
  bt_2480_opt_exit();
  if (fcc_mode_sel == '\x01') {
    bt_3200_opt(false);
    force_hw_set_freq_flag = false;
    memw();
    phy_en_hw_set_freq();
  }
  return;
}



// WARNING: Unknown calling convention

void rw_le_rx_per_func(u32 chan,u32 syncw)

{
  u8 uVar1;
  uint8 uVar2;
  uint32 chan_00;
  _func_void_uint8_uint8_uint8_uint8 *p_Var3;
  
  uVar1 = fcc_mode_sel;
  if (fcc_mode_sel == '\x01') {
    bt_set_freq_cal(false,(uint8)chan,false);
    phy_dis_hw_set_freq();
    force_hw_set_freq_flag = (bool)uVar1;
    memw();
    bt_3200_opt(true);
    p_Var3 = g_phyFuns->i2c_writeReg_;
    uVar2 = get_rfrx_dcap_bt('\x04');
    (*p_Var3)('d','\0','\x04',uVar2);
    p_Var3 = g_phyFuns->i2c_writeReg_;
    uVar2 = get_rfrx_dcap_bt('\a');
    (*p_Var3)('d','\0','\a',uVar2);
  }
  chan_00 = 0x13;
  if (chan != 0x11) {
    chan_00 = chan;
  }
  bt_2480_opt_enter(chan_00);
  phy_printf("rw_le_per_syncw:chan=%d,syncw=0x%x\n",chan,syncw);
  rw_le_rx_per_syncw(chan,syncw);
  bt_2480_opt_exit();
  if (fcc_mode_sel == '\x01') {
    bt_3200_opt(false);
    force_hw_set_freq_flag = false;
    memw();
    phy_en_hw_set_freq();
  }
  return;
}



// WARNING: Unknown calling convention

void bt_tx_tone(u32 start,u32 bt_chan,u32 backoff)

{
  fcc_bt_force_tx_tone(start,bt_chan,backoff);
  return;
}



// WARNING: Unknown calling convention

void esp_ble_tx_func(u32 txpwr,u32 chan,u32 len,u32 data_type,u32 syncw,u32 rate,u32 tx_num_in)

{
  fcc_le_tx_syncw_func(txpwr,chan,len,data_type,syncw,tx_num_in);
  return;
}



// WARNING: Unknown calling convention

void esp_ble_rx_func(u32 chan,u32 syncw,u32 rate)

{
  rw_le_rx_per_func(chan,syncw);
  return;
}



// WARNING: Unknown calling convention

void RF_init_sel(bool init_bin_sel,u32 flash_addr)

{
  bool bVar1;
  s8 *psVar2;
  s8 *psVar3;
  s8 sVar4;
  s8 init_params_define [128];
  
  memset(init_params_define,0,0x80);
  init_params_define[0x20] = -4;
  init_params_define[0x21] = -4;
  init_params_define[0x22] = -2;
  init_params_define[0x2c] = 'N';
  init_params_define[0] = '\x06';
  builtin_memcpy(init_params_define + 2,"\x05\t\x06\x05\x03\x06\x05\x04\x06\x04\x05",0xb);
  builtin_memcpy(init_params_define + 0x11,"\x05\t\x06\x05\x03\x06\x05",7);
  init_params_define[0x23] = -0x10;
  init_params_define[0x24] = -0x10;
  init_params_define[0x25] = -0x10;
  init_params_define[0x26] = -0x20;
  init_params_define[0x27] = -0x20;
  init_params_define[0x28] = -0x20;
  init_params_define[0x29] = '\x18';
  init_params_define[0x2a] = '\x18';
  init_params_define[0x2b] = '\x18';
  init_params_define[0x2d] = 'H';
  init_params_define[0x2e] = 'B';
  init_params_define[0x2f] = '<';
  init_params_define[0x30] = '8';
  init_params_define[0x31] = '4';
  init_params_define[0x32] = '\x01';
  init_params_define[0x33] = '\x01';
  init_params_define[0x34] = '\x01';
  init_params_define[0x35] = '\x02';
  init_params_define[0x36] = '\x02';
  init_params_define[0x37] = '\x03';
  init_params_define[0x38] = '\x04';
  init_params_define[0x39] = '\x05';
  init_params_define[0x3a] = '\x01';
  memw();
  if (init_bin_sel) {
    read_flash_init_para(flash_addr + 8,(u8 *)init_param_default);
    bVar1 = esp_crc8((bool *)init_param_default,0x7f);
    phy_printf("crc8_init:0x%x,0x%x\n",(int)init_param_default[0x7f],(int)bVar1);
    if ((int)init_param_default[0x7f] != (int)bVar1) {
      phy_printf("esp init data is from flash,init bin crc error! err_code=%d\n",1);
      goto LAB_000352d3;
    }
    if (init_param_default[0] < '\x04') {
      phy_printf("phy init bin version error!must greater than v04 err_code=%d\n",4);
      goto LAB_000352d3;
    }
    phy_printf("esp init data is from flash,RF_init_sel:%d,flash_addr:0x%x\n",init_bin_sel,
               flash_addr);
  }
  else {
    psVar3 = init_params_define;
    sVar4 = '\x06';
    psVar2 = init_param_default;
    while( true ) {
      psVar3 = psVar3 + 1;
      *psVar2 = sVar4;
      memw();
      psVar2 = psVar2 + 1;
      if (psVar2 == init_param_default + 0x80) break;
      sVar4 = *psVar3;
    }
    phy_printf("esp init data is from factory bin,RF_init_sel:%d\n",0);
  }
  register_chipv7_phy_init_param(init_param_default);
  chip7_sleep_params.param_flag = 0;
  phy_freq_offset = 0;
  memw();
  rfpll_offset_delta = 0;
  memw();
  rf_init();
  bb_init();
  chip_v7_set_chan_offset(0);
  phy_printf("v=%d,c=%d, p=%d,%d,%d,%d,%d,%d, %d,%d,%d,%d,%d,%d,%d,%d, f=%d,%d,crc=%d\n",
             (int)init_param_default[0],(int)init_param_default[1],(int)init_param_default[0x2c],
             (int)init_param_default[0x2d],(int)init_param_default[0x2e],
             (int)init_param_default[0x2f],(int)init_param_default[0x30],
             (int)init_param_default[0x31],(int)init_param_default[0x32],
             (int)init_param_default[0x33],(int)init_param_default[0x34],
             (int)init_param_default[0x35],(int)init_param_default[0x36],
             (int)init_param_default[0x37],(int)init_param_default[0x38],
             (int)init_param_default[0x39],(int)init_param_default[0x69],
             (int)init_param_default[0x6a],(int)init_param_default[0x7f]);
LAB_000352d3:
  tx_rf_ana_gain_init[0] = tx_rf_ana_gain[0];
  tx_rf_ana_gain_init[1] = tx_rf_ana_gain[1];
  memw();
  return;
}



// WARNING: Unknown calling convention

void esp_chg_freqoff(s8 ppm,u32 init_params_addr)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  s8 init_data_all [144];
  s8 param_default [144];
  
  read_flash_init_para(init_params_addr,(u8 *)init_data_all);
  init_param_default[0] = init_data_all[8];
  memw();
  bVar1 = esp_crc8((bool *)init_param_default,0x7f);
  if ((bool)init_param_default[0x7f] != bVar1) {
    phy_printf("esp_chg_freqoff fail,init bin crc error! err_code=1\n");
    return;
  }
  if (init_param_default[0] < '\x04') {
    phy_printf("phy init bin version error!must greater than v04 err_code=%4\n");
    return;
  }
  iVar2 = (int)ppm;
  iVar3 = (iVar2 * -0x9b4) / 1000 + 4 >> 3;
  init_param_default[0x6a] = (s8)iVar3;
  memw();
  if (iVar3 != 0) {
    iVar3 = 1;
  }
  init_param_default[0x69] = (s8)iVar3;
  memw();
  init_param_default[0x7f] = esp_crc8((bool *)init_param_default,0x7f);
  memw();
  register_chipv7_phy_init_param(init_param_default);
  chip_v7_set_chan_offset(0);
  init_data_all[8] = init_param_default[0];
  memw();
  write_flash_init_para(init_params_addr,(u8 *)init_data_all);
  read_flash_init_para(init_params_addr,(u8 *)param_default);
  if (init_data_all[0] != param_default[0]) {
    phy_printf("esp_chg_freqoff fail, %dppm, 0x%x,err_code=2\n",iVar2,init_params_addr);
    return;
  }
  phy_printf("esp_chg_freqoff ok, %dppm, %d, %d, 0x%x\n",iVar2,(int)init_param_default[0x69],
             (int)init_param_default[0x6a],init_params_addr);
  return;
}



// WARNING: Unknown calling convention

void esp_set_target_txp(uint32 *para_array)

{
  u8 uVar1;
  u8 uVar2;
  bool bVar3;
  undefined4 uVar4;
  char cVar5;
  char cVar6;
  u8 *data;
  s8 *psVar7;
  s8 sVar8;
  int iVar9;
  uint uVar10;
  u32 addr;
  u8 *puVar11;
  s8 *psVar12;
  uint uVar13;
  s8 init_data_all [144];
  s8 param_default [144];
  s8 init_params_define [128];
  s8 get_param_default [128];
  
  memset(init_params_define,0,0x80);
  init_params_define[0] = '\x06';
  builtin_memcpy(init_params_define + 2,"\x05\t\x06\x05\x03\x06\x05\x04\x06\x04\x05",0xb);
  builtin_memcpy(init_params_define + 0x11,"\x05\t\x06\x05\x03\x06\x05",7);
  init_params_define[0x22] = -2;
  init_params_define[0x23] = -0x10;
  init_params_define[0x24] = -0x10;
  init_params_define[0x25] = -0x10;
  init_params_define[0x26] = -0x20;
  init_params_define[0x27] = -0x20;
  init_params_define[0x28] = -0x20;
  init_params_define[0x29] = '\x18';
  init_params_define[0x2a] = '\x18';
  init_params_define[0x2b] = '\x18';
  init_params_define[0x2c] = 'N';
  init_params_define[0x20] = -4;
  init_params_define[0x21] = -4;
  init_params_define[0x2d] = 'H';
  memw();
  uVar10 = *para_array;
  uVar13 = uVar10 & 0xff;
  init_params_define[0x2e] = 'B';
  init_params_define[0x2f] = '<';
  init_params_define[0x30] = '8';
  init_params_define[0x31] = '4';
  init_params_define[0x32] = '\x01';
  init_params_define[0x33] = '\x01';
  init_params_define[0x34] = '\x01';
  init_params_define[0x35] = '\x02';
  init_params_define[0x36] = '\x02';
  init_params_define[0x37] = '\x03';
  init_params_define[0x38] = '\x04';
  init_params_define[0x39] = '\x05';
  init_params_define[0x3a] = '\x01';
  memw();
  if (((uVar13 - 1 & 0xff) < 2) || (uVar13 == 4)) {
    addr = para_array[7];
    uVar4 = ets_efuse_get_spiconfig();
    spi_flash_attach(uVar4,0);
    read_flash_init_para(addr,(u8 *)init_data_all);
    get_param_default[0] = init_data_all[8];
    bVar3 = esp_crc8((bool *)get_param_default,0x7f);
    if ((bool)get_param_default[0x7f] != bVar3) {
      phy_printf("%d,esp_init_data_bin is error! err_code=1\n",0);
      return;
    }
    if (get_param_default[0] < '\x04') {
      phy_printf("phy init bin version error!must greater than v04 err_code=4\n");
      return;
    }
    if ((uVar13 - 2 & 0xfd) != 0) goto LAB_000358d2;
    cVar6 = *(char *)(para_array + 1);
    cVar5 = *(char *)(para_array + 2);
    get_param_default[0x2c] = cVar6;
    get_param_default[0x2d] = cVar5;
    get_param_default[0x2e] = (s8)para_array[3];
    get_param_default[0x2f] = (s8)para_array[4];
    get_param_default[0x30] = (s8)para_array[5];
    get_param_default[0x31] = (s8)para_array[6];
    memw();
    psVar12 = get_param_default;
    while (cVar5 <= cVar6) {
      if (get_param_default + 5 == psVar12 + 1) {
        if (uVar13 == 2) {
          get_param_default[0x7f] = esp_crc8((bool *)get_param_default,0x7f);
          memw();
          init_data_all[8] = get_param_default[0];
          memw();
          write_flash_init_para(addr,(u8 *)init_data_all);
          data = (u8 *)param_default;
          read_flash_init_para(addr,data);
          iVar9 = 0x90;
          puVar11 = (u8 *)init_data_all;
          do {
            uVar1 = *puVar11;
            puVar11 = puVar11 + 1;
            uVar2 = *data;
            data = data + 1;
            if (uVar1 != uVar2) {
              phy_printf("%d,set init params error! err_code=3\n",0);
              return;
            }
            iVar9 = iVar9 + -1;
          } while (iVar9 != 0);
        }
        goto LAB_000358d2;
      }
      cVar6 = psVar12[0x2d];
      cVar5 = psVar12[0x2e];
      psVar12 = psVar12 + 1;
    }
  }
  else {
    psVar12 = init_params_define;
    sVar8 = '\x06';
    psVar7 = get_param_default;
    while( true ) {
      psVar12 = psVar12 + 1;
      *psVar7 = sVar8;
      memw();
      psVar7 = psVar7 + 1;
      if (get_param_default == psVar12) break;
      sVar8 = *psVar12;
    }
    if (uVar13 != 3) {
LAB_000358d2:
      chip7_sleep_params.param_flag = 0;
      register_chipv7_phy_init_param(get_param_default);
      rf_init();
      bb_init();
      chip_v7_set_chan_offset(0);
      phy_printf("%d,esp_set_default_target_txp ok, pwr: %d, %d, %d, %d, %d, %d, RF_init_sel:%d\n",1
                 ,(int)get_param_default[0x2c],(int)get_param_default[0x2d],
                 (int)get_param_default[0x2e],(int)get_param_default[0x2f],
                 (int)get_param_default[0x30],(int)get_param_default[0x31],uVar10 & 0xff);
      return;
    }
    cVar6 = *(char *)(para_array + 1);
    cVar5 = *(char *)(para_array + 2);
    get_param_default[0x2c] = cVar6;
    get_param_default[0x2d] = cVar5;
    get_param_default[0x2e] = (s8)para_array[3];
    get_param_default[0x2f] = (s8)para_array[4];
    get_param_default[0x30] = (s8)para_array[5];
    get_param_default[0x31] = (s8)para_array[6];
    memw();
    psVar12 = get_param_default;
    while (cVar5 <= cVar6) {
      if (get_param_default + 5 == psVar12 + 1) goto LAB_000358d2;
      cVar6 = psVar12[0x2d];
      cVar5 = psVar12[0x2e];
      psVar12 = psVar12 + 1;
    }
  }
  phy_printf("%d,set init params error! err_code=2\n",0);
  return;
}



// WARNING: Unknown calling convention

void esp_get_target_txp(uint32 *para_array)

{
  bool bVar1;
  uint32 uVar2;
  undefined4 uVar3;
  s8 param_default [128];
  
  uVar2 = *para_array;
  uVar3 = ets_efuse_get_spiconfig();
  spi_flash_attach(uVar3,0);
  read_flash_init_para(uVar2 + 8,(u8 *)param_default);
  bVar1 = esp_crc8((bool *)param_default,0x7f);
  if ((bool)param_default[0x7f] != bVar1) {
    phy_printf("esp_init_data_bin is error! err_code=1\n");
    return;
  }
  if ('\x03' < param_default[0]) {
    phy_printf("esp_get_target_txp:%d,%d,%d,%d,%d,%d\n",(int)param_default[0x2c],
               (int)param_default[0x2d],(int)param_default[0x2e],(int)param_default[0x2f],
               (int)param_default[0x30],(int)param_default[0x31]);
    return;
  }
  phy_printf("phy init bin version error!must greater than v04 err_code=4\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rfpll_1p2_test(void)

{
  uint8 uVar1;
  uint8 uVar2;
  int iVar3;
  int iVar4;
  uint8 *puVar5;
  char cVar6;
  uint8 dreg_1p2;
  uint8 reg [4];
  
  puVar5 = reg;
  reg[0] = '0';
  reg[1] = 0x80;
  reg[2] = '\b';
  reg[3] = 'q';
  memw();
  uVar1 = (*g_phyFuns->i2c_readReg_)('j','\x02','\0');
  _DAT_3ff48030 = esp_dport_access_reg_read(&DAT_3ff48030);
  _DAT_3ff48030 = _DAT_3ff48030 & 0x7fffffff;
  memw();
  _DAT_3ff48030 = esp_dport_access_reg_read(&DAT_3ff48030);
  _DAT_3ff48030 = _DAT_3ff48030 | 0x80000000;
  memw();
  (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\0','\x03','\x02','\x01');
  phy_printf("\npll_1p2,");
  cVar6 = '\0';
  iVar3 = 0;
  do {
    iVar4 = iVar3 + 1;
    uVar2 = (*g_phyFuns->i2c_readReg_)('b','\x01',(uint8)iVar3);
    if (*puVar5 != uVar2) {
      cVar6 = cVar6 + '\x01';
    }
    phy_printf("0x%x,",uVar2);
    puVar5 = puVar5 + 1;
    iVar3 = iVar4;
  } while (iVar4 != 4);
  phy_printf(&DAT_00055d1c,cVar6);
  (*g_phyFuns->i2c_writeReg_)('j','\x02','\0',uVar1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void esp_origin_mac(void)

{
  u32 mac_l;
  uint uVar1;
  uint uVar2;
  
  uVar1 = esp_dport_access_reg_read(0x3ff5a004);
  uVar2 = esp_dport_access_reg_read(0x3ff5a008);
  phy_printf("mac_addr:%02x:%02x:%02x:%02x:%02x:%02x\n",(uVar2 & 0xffffff) >> 8 & 0xff,uVar2 & 0xff,
             uVar1 >> 0x18,uVar1 >> 0x10 & 0xff,uVar1 >> 8 & 0xff,uVar1 & 0xff);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void esp_chk_mac(void)

{
  u8 uVar1;
  char *pcVar2;
  u8 macaddr [6];
  
  uVar1 = check_usermac_from_efuse(macaddr);
  if (uVar1 == '\0') {
    pcVar2 = "%d, 0x%02x%02x%02x%02x%02x%02x,empty efuse!\n";
  }
  else if (uVar1 == '\x01') {
    pcVar2 = "%d, 0x%02x%02x%02x%02x%02x%02x,check crc PASS!\n";
  }
  else {
    if (uVar1 != '\x02') {
      phy_printf("%d,error!\n");
      return;
    }
    pcVar2 = "%d, 0x%02x%02x%02x%02x%02x%02x,check crc FAIL!\n";
  }
  phy_printf(pcVar2,uVar1,macaddr[0],macaddr[1],macaddr[2],macaddr[3],macaddr[4],macaddr[5]);
  return;
}



// WARNING: Unknown calling convention

void esp_set_mac(u32 mac_upper,u32 mac_lower)

{
  u8 uVar1;
  
  uVar1 = write_usermac_to_efuse(mac_upper,mac_lower);
  if (uVar1 == '\x01') {
    phy_printf("%d,Write_efuse PASS!\n",1);
    return;
  }
  if ((byte)(uVar1 - 2) < 2) {
    phy_printf("%d,Write_efuse FAIL!\n");
    return;
  }
  if (uVar1 == '\x04') {
    phy_printf("%d,Coding_efuse FAIL!\n");
    return;
  }
  phy_printf("%d,error!\n");
  return;
}



// WARNING: Unknown calling convention

void ESP_TEST_GPIO_func(uint32 *para_array)

{
  u32 Input_result [3];
  
  ESP_TEST_GPIO(para_array,Input_result);
  phy_printf("Input result:0x%x,0x%x,0x%x\n",Input_result[0],Input_result[1],Input_result[2]);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void pvt_test_func(void)

{
  uint16 uVar1;
  
  pvt_pwr_ctrl('\x01');
  ets_delay_us(600);
  uVar1 = pvt_test(4,false,400);
  phy_printf("pvt=%d\n",uVar1);
  ets_delay_us(600);
  pvt_pwr_ctrl('\0');
  return;
}



// WARNING: Unknown calling convention

bool remove_head_newline(char *strln,char **pnext)

{
  char cVar1;
  
  cVar1 = *strln;
  while (cVar1 == '\n') {
    strln = strln + 1;
    cVar1 = *strln;
  }
  *pnext = strln;
  return false;
}



// WARNING: Unknown calling convention

STATUS esp_phy_getstopcmd(void)

{
  char cVar1;
  STATUS SVar2;
  
  cVar1 = cmdstop_callback();
  SVar2 = OK;
  if (((cVar1 != '\0') && (SVar2 = BUSY, cVar1 != '\x01')) && (SVar2 = FAIL, cVar1 == '\x02')) {
    phy_printf(" Plz run CmdStop to exit current cmd!\n");
    SVar2 = FAIL;
  }
  return SVar2;
}



// WARNING: Unknown calling convention

STATUS GetStopCmd(void)

{
  STATUS SVar1;
  
  SVar1 = esp_phy_getstopcmd();
  return SVar1;
}



// WARNING: Unknown calling convention

uint32_t spi_qe0(uint32_t spi_no)

{
  uint uVar1;
  
  uVar1 = spi_usr_cmd(spi_no,5,8,0,0);
  if ((uVar1 & 0x40) == 0) {
    spi_flash_wren(spi_no);
    spi_usr_cmd(spi_no,1,8,0,1,0x40);
    WaitFlashIdle(spi_no);
    return 0;
  }
  return 1;
}



// WARNING: Unknown calling convention

uint32_t spi_qe1(uint32_t spi_no)

{
  uint uVar1;
  uint uVar2;
  
  spi_flash_wren(spi_no);
  uVar1 = spi_usr_cmd(spi_no,0x35,8,0,0);
  if ((uVar1 & 2) == 0) {
    uVar2 = spi_usr_cmd(spi_no,5,8,0,0,0);
    spi_usr_cmd(1,1,0x10,0,1,(uVar1 & 0xf | 2) << 8 | uVar2 & 0xf);
    WaitFlashIdle(spi_no);
    return 0;
  }
  return 1;
}



// WARNING: Unknown calling convention

uint32_t spi_qe2(uint32_t spi_no)

{
  uint uVar1;
  
  spi_flash_wren(spi_no);
  uVar1 = spi_usr_cmd(spi_no,5,8,0,0);
  if ((uVar1 & 2) == 0) {
    spi_usr_cmd(spi_no,0x31,8,0,1,uVar1 | 2);
    WaitFlashIdle(spi_no);
    return 0;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint32 SPI_get_id(void)

{
  int iVar1;
  uint uVar2;
  uint32_t val;
  
  memw();
  _DAT_3ff42080 = 0;
  memw();
  _DAT_3ff42000 = 0x10000000;
  do {
    iVar1 = esp_dport_access_reg_read(&DAT_3ff42000);
  } while (iVar1 != 0);
  uVar2 = esp_dport_access_reg_read(&DAT_3ff42080);
  return uVar2 & 0xffffff;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void SPI_SET_QE(void)

{
  SPI_get_id();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void gpio_set_flash_drv(u8 clk_drv,u8 cmd_drv,u8 data0_drv,u8 data1_drv,u8 data2_drv,u8 data3_drv)

{
  char cVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  
  uVar9 = (uint)data3_drv;
  uVar8 = (uint)data2_drv;
  uVar7 = (uint)data1_drv;
  uVar6 = (uint)data0_drv;
  uVar5 = (uint)cmd_drv;
  uVar2 = (uint)clk_drv;
  uVar3 = ets_efuse_get_spiconfig();
  memw();
  _DAT_3ff42004 = 0x1001009;
  memw();
  _DAT_3ff42000 = 0x80000000;
  do {
    iVar4 = esp_dport_access_reg_read(&DAT_3ff42000);
  } while (iVar4 < 0);
  cVar1 = esp_dport_access_reg_read(&DAT_3ff42080);
  spi_flash_attach(uVar3,0);
  phy_printf("spiconfig0=%d\n",uVar3);
  if (uVar3 == 0) {
    memw();
    memw();
    _DAT_3ff49060 = (uVar2 & 3) << 10 | _DAT_3ff49060 & 0xfffff3ff;
    memw();
    memw();
    _DAT_3ff4905c = (uVar5 & 3) << 10 | _DAT_3ff4905c & 0xfffff3ff;
    memw();
    memw();
    _DAT_3ff49064 = (uVar6 & 3) << 10 | _DAT_3ff49064 & 0xfffff3ff;
    memw();
    memw();
    _DAT_3ff49068 = (uVar7 & 3) << 10 | _DAT_3ff49068 & 0xfffff3ff;
    memw();
    memw();
    _DAT_3ff49054 = (uVar8 & 3) << 10 | _DAT_3ff49054 & 0xfffff3ff;
    memw();
    memw();
    _DAT_3ff49058 = (uVar9 & 3) << 10 | _DAT_3ff49058 & 0xfffff3ff;
    return;
  }
  if (uVar3 != 1) {
    gpio_pad_set_drv(uVar3 & 0x3f,uVar2);
    gpio_pad_set_drv(uVar3 >> 6 & 0x3f,uVar8);
    gpio_pad_set_drv(uVar3 >> 0xc & 0x3f,uVar9);
    gpio_pad_set_drv(uVar3 >> 0x12 & 0x3f,uVar5);
    if (cVar1 != -0x12) {
      gpio_pad_set_drv(uVar3 >> 0x18 & 0x3f,uVar7);
      gpio_pad_set_drv(cVar1,uVar6);
    }
    return;
  }
  memw();
  memw();
  _DAT_3ff49030 = (uVar2 & 3) << 10 | _DAT_3ff49030 & 0xfffff3ff;
  memw();
  memw();
  _DAT_3ff49034 = (uVar8 & 3) << 10 | _DAT_3ff49034 & 0xfffff3ff;
  memw();
  memw();
  _DAT_3ff49038 = (uVar9 & 3) << 10 | _DAT_3ff49038 & 0xfffff3ff;
  memw();
  memw();
  _DAT_3ff4903c = (uVar5 & 3) << 10 | _DAT_3ff4903c & 0xfffff3ff;
  memw();
  memw();
  _DAT_3ff49040 = (uVar6 & 3) << 10 | _DAT_3ff49040 & 0xfffff3ff;
  memw();
  memw();
  _DAT_3ff49048 = (uVar7 & 3) << 10 | _DAT_3ff49048 & 0xfffff3ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void spi_clk_local(uint8 freqdiv)

{
  uint uVar1;
  
  if (freqdiv < 2) {
    memw();
    _DAT_3ff42018 = 0x80000000;
    return;
  }
  uVar1 = freqdiv - 1;
  memw();
  _DAT_3ff42018 = ((freqdiv >> 1) - 1) * 0x40 | uVar1 * 0x1000 | uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void spi_test_init(uint32 flash_mode,uint32 clk_div,uint32 drv)

{
  u8 clk_drv;
  uint uVar1;
  
  clk_drv = (u8)drv;
  gpio_set_flash_drv(clk_drv,clk_drv,clk_drv,clk_drv,clk_drv,clk_drv);
  SPIReadModeCnfig(flash_mode,0);
  if ((clk_div & 0xff) < 2) {
    memw();
    _DAT_3ff42018 = 0x80000000;
    return;
  }
  uVar1 = (clk_div & 0xff) - 1;
  memw();
  _DAT_3ff42018 = (((clk_div & 0xff) >> 1) - 1) * 0x40 | uVar1 * 0x1000 | uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void SPI_read_local(uint32 spi_addr,sint32 length)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  int iVar4;
  undefined *puVar5;
  
  uVar3 = 0;
  _DAT_3ff42004 = spi_addr & 0xffffff | 0x20000000;
  memw();
  do {
    memw();
    _DAT_3ff42000 = 0x80000000;
    do {
      iVar1 = esp_dport_access_reg_read(&DAT_3ff42000);
    } while (iVar1 < 0);
    if (uVar3 == 0) {
      puVar5 = &DAT_3ff42080;
      iVar1 = 0;
      if (length == 0) {
        do {
          uVar2 = esp_dport_access_reg_read(puVar5);
          iVar4 = iVar1 + 1;
          phy_printf("flash value %d %x \n",iVar1,uVar2);
          puVar5 = puVar5 + 4;
          iVar1 = iVar4;
        } while (iVar4 != 8);
      }
    }
    uVar3 = uVar3 + 1;
  } while (uVar3 < (uint)length);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void SPI_page_program_local(uint32 spi_addr,sint32 length)

{
  uint uVar1;
  uint uVar2;
  uint32_t val;
  
  _DAT_3ff4201c = esp_dport_access_reg_read(&DAT_3ff4201c);
  uVar2 = 0;
  _DAT_3ff42004 = spi_addr << 8;
  _DAT_3ff4201c = _DAT_3ff4201c | 0x48008000;
  memw();
  memw();
  _DAT_3ff42080 = 0x5a5a5a5a;
  memw();
  _DAT_3ff42084 = 0x5a5a5a5a;
  memw();
  _DAT_3ff42088 = 0x5a5a5a5a;
  memw();
  _DAT_3ff4208c = 0x5a5a5a5a;
  memw();
  _DAT_3ff42090 = 0x5a5a5a5a;
  memw();
  _DAT_3ff42094 = 0x5a5a5a5a;
  memw();
  _DAT_3ff42098 = 0x5a5a5a5a;
  memw();
  _DAT_3ff4209c = 0x5a5a5a5a;
  memw();
  memw();
  _DAT_3ff42028 = 0xff;
  do {
    memw();
    _DAT_3ff42000 = 0x40000;
    do {
      uVar1 = esp_dport_access_reg_read(&DAT_3ff42000);
    } while ((uVar1 & 0x40000) != 0);
    uVar2 = uVar2 + 1;
  } while (uVar2 < (uint)length);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void flash_test_init(uint32 clk_div,uint32 drv,u32 flash_mode)

{
  undefined uVar1;
  uint32 uVar2;
  
  uVar1 = DAT_00066169;
  memw();
  _DAT_3ff42018 = 0x3043;
  DAT_00066169 = 0;
  memw();
  uVar2 = SPI_get_id();
  flash_test_enable = uVar2 - 1 < 0xfffffe;
  memw();
  phy_printf("flash test: enable=%d id=0x%x\n",flash_test_enable,uVar2);
  if (flash_test_enable != false) {
    spi_test_init(flash_mode,clk_div,drv);
  }
  DAT_00066169 = uVar1;
  memw();
  return;
}



// WARNING: Unknown calling convention

void gpio_test_init(u32 gpio_en)

{
  if (gpio_en != 0) {
    gpio_test_enable = true;
    memw();
    gpio_test_en = gpio_en;
    test_pad_mode_sel('\x02',gpio_en,0);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpio_test_run(void)

{
  bool level;
  char cVar1;
  
  if (gpio_test_enable) {
    cVar1 = '\b';
    do {
      gpio_output_set(0,0x200000,0x200000,0);
      ets_delay_us(1);
      cVar1 = cVar1 + -1;
      gpio_output_set(0x200000,0,0x200000,0);
    } while (cVar1 != '\0');
  }
  return;
}



// WARNING: Unknown calling convention

void gpio_set_psram_drv(uint32_t spiconfig0,uint8_t spiconfig1,uint8_t drv)

{
  gpio_pad_set_drv(spiconfig0 & 0x3f,drv);
  gpio_pad_set_drv(spiconfig0 >> 6 & 0x3f,drv);
  gpio_pad_set_drv(spiconfig0 >> 0xc & 0x3f,drv);
  gpio_pad_set_drv(spiconfig0 >> 0x12 & 0x3f,drv);
  gpio_pad_set_drv(spiconfig0 >> 0x18 & 0x3f,drv);
  gpio_pad_set_drv(spiconfig1,drv);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void SPIPsramExitQIO(uint8_t div)

{
  uint uVar1;
  uint uVar2;
  
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 | 1;
  memw();
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 & 0xfffffffd;
  memw();
  if (div < 2) {
    uVar1 = 7;
    _DAT_3ff42080 = 0xf5;
  }
  else {
    _DAT_3ff42080 = 0xf500;
    uVar1 = 0xf;
  }
  memw();
  _DAT_3ff42020 = 0;
  memw();
  _DAT_3ff4201c = 0x8008000;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff42028);
  _DAT_3ff42028 = uVar2 & 0xff000000 | uVar1;
  memw();
  _DAT_3ff42000 = esp_dport_access_reg_read(&DAT_3ff42000);
  _DAT_3ff42000 = _DAT_3ff42000 | 0x40000;
  memw();
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff42000);
  } while ((uVar1 & 0x40000) != 0);
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 | 2;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff42034);
  memw();
  _DAT_3ff42034 = uVar1 & 0xfffffffe;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint32_t SPIPsramReadID(uint8_t div)

{
  uint32_t uVar1;
  uint uVar2;
  
  SPIPsramExitQIO(div);
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 | 1;
  memw();
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 & 0xfffffffd;
  memw();
  if (div < 2) {
    memw();
    _DAT_3ff4201c = 0xf0000000;
    _DAT_3ff4201c = esp_dport_access_reg_read(&DAT_3ff4201c);
    _DAT_3ff4201c = _DAT_3ff4201c & 0x7fffffff;
    memw();
    _DAT_3ff42024 = esp_dport_access_reg_read(&DAT_3ff42024);
    _DAT_3ff42024 = _DAT_3ff42024 & 0xfffffff;
    memw();
  }
  else {
    memw();
    _DAT_3ff4201c = 0xf0000000;
    uVar2 = esp_dport_access_reg_read(&DAT_3ff42024);
    _DAT_3ff42024 = uVar2 & 0xfffffff | 0x10000000;
    memw();
    _DAT_3ff42024 = esp_dport_access_reg_read(&DAT_3ff42024);
    _DAT_3ff42024 = _DAT_3ff42024 & 0xffff0000;
    memw();
  }
  uVar2 = esp_dport_access_reg_read(&DAT_3ff42020);
  _DAT_3ff42020 = uVar2 & 0x3ffffff | 0x7c000000;
  memw();
  memw();
  _DAT_3ff42004 = 0x9f000000;
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4202c);
  _DAT_3ff4202c = uVar2 & 0xff000000 | 0x1f;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff42020);
  _DAT_3ff42020 = uVar2 & 0xffffff00 | (uint)(div < 2);
  memw();
  _DAT_3ff42000 = esp_dport_access_reg_read(&DAT_3ff42000);
  _DAT_3ff42000 = _DAT_3ff42000 | 0x40000;
  memw();
  do {
    uVar2 = esp_dport_access_reg_read(&DAT_3ff42000);
  } while ((uVar2 & 0x40000) != 0);
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 | 2;
  memw();
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 & 0xfffffffe;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff42080);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void SPIPsramEnterQIO(uint8_t div)

{
  uint uVar1;
  
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 | 1;
  memw();
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 & 0xfffffffd;
  memw();
  if (div < 2) {
    memw();
    _DAT_3ff4201c = 0xc0000000;
    _DAT_3ff4201c = esp_dport_access_reg_read(&DAT_3ff4201c);
    _DAT_3ff4201c = _DAT_3ff4201c & 0x7fffffff;
    memw();
  }
  else {
    memw();
    _DAT_3ff4201c = 0xc0000000;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff42024);
    _DAT_3ff42024 = uVar1 & 0xfffffff | 0x10000000;
    memw();
    _DAT_3ff42024 = esp_dport_access_reg_read(&DAT_3ff42024);
    _DAT_3ff42024 = _DAT_3ff42024 & 0xffff0000;
    memw();
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff42020);
  _DAT_3ff42020 = uVar1 & 0x3ffffff | 0x1c000000;
  memw();
  memw();
  _DAT_3ff42004 = 0x35000000;
  _DAT_3ff42000 = esp_dport_access_reg_read(&DAT_3ff42000);
  _DAT_3ff42000 = _DAT_3ff42000 | 0x40000;
  memw();
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff42000);
  } while ((uVar1 & 0x40000) != 0);
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 | 2;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff42034);
  memw();
  _DAT_3ff42034 = uVar1 & 0xfffffffe;
  return;
}



// WARNING: Unknown calling convention

void SPIPsramCLK(uint8_t div)

{
  if (div < 2) {
    PsramEnableVspiClk();
    spi_clk_config(1,0);
    return;
  }
  PsramDisableVspiClk();
  spi_clk_config(1,0,div);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int SPIPsramEnable(uint8_t PSRAM_CS_IO,uint8_t PSRAM_CLK_IO,uint8_t div)

{
  _DAT_3ff4201c = esp_dport_access_reg_read(&DAT_3ff4201c);
  _DAT_3ff4201c = _DAT_3ff4201c & 0xff7fffef;
  memw();
  if (div < 2) {
    SPIPsramCLK(div);
    gpio_matrix_out(PSRAM_CS_IO,5,0);
    gpio_matrix_out(PSRAM_CLK_IO,0x3f,0);
  }
  else {
    if (div == '\x02') {
      SPIPsramCLK('\x02');
      gpio_matrix_out(PSRAM_CS_IO,5,0);
      gpio_matrix_out(0x1c,0,0);
      gpio_matrix_in(0x1c,0xe0,0);
      gpio_matrix_out(0x1d,0xe0,0);
      gpio_matrix_in(0x1d,0xe1,0);
      gpio_matrix_out(PSRAM_CLK_IO,0xe1,0);
    }
    SPIPsramCLK(div);
    gpio_matrix_out(PSRAM_CS_IO,5,0);
    gpio_matrix_out(0x1c,0,0);
    gpio_matrix_in(0x1c,0xe0,0);
    gpio_matrix_out(0x1d,0xe0,0);
    gpio_matrix_in(0x1d,0xe1,0);
    gpio_matrix_out(0x1e,0xe1,0);
    gpio_matrix_in(0x1e,0xe2,0);
    gpio_matrix_out(0x1f,0xe2,0);
    gpio_matrix_in(0x1f,0xe3,0);
    gpio_matrix_out(PSRAM_CLK_IO,0xe3,0);
  }
  _DAT_3ff4201c = esp_dport_access_reg_read(&DAT_3ff4201c);
  _DAT_3ff4201c = _DAT_3ff4201c & 0xffffffdf;
  memw();
  gpio_pad_select_gpio(PSRAM_CS_IO);
  gpio_pad_select_gpio(PSRAM_CLK_IO);
  return 0;
}



// WARNING: Unknown calling convention

uint32_t SPIPsramInitCheck(uint8_t PSRAM_CS_IO,uint8_t PSRAM_CLK_IO,uint8_t div)

{
  uint32_t uVar1;
  
  SPIPsramEnable(PSRAM_CS_IO,PSRAM_CLK_IO,div);
  SPIPsramReadID(div);
  uVar1 = SPIPsramReadID(div);
  return -(uint)((uVar1 >> 8 & 0xff) != 0x5d);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint32_t PsramQIOConf(uint8_t PSRAM_CS_IO,uint8_t PSRAM_CLK_IO,uint32_t clk_div,uint32_t drv)

{
  uint32_t uVar1;
  uint32_t uVar2;
  
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 | 1;
  memw();
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 & 0xfffffffd;
  memw();
  gpio_output_set(0x20,0);
  gpio_output_set(0,0x20);
  gpio_output_set(0x20,0);
  uVar1 = SPIPsramInitCheck(PSRAM_CS_IO,PSRAM_CLK_IO,'\x02');
  uVar2 = 0;
  if (uVar1 == 0) {
    SPIPsramEnable(PSRAM_CS_IO,PSRAM_CLK_IO,(uint8_t)clk_div);
    SPIPsramEnterQIO((uint8_t)clk_div);
    if (clk_div < 2) {
      memw();
      _DAT_3ff4201c = 0x70000000;
    }
    else if (clk_div == 2) {
      memw();
      _DAT_3ff4201c = 0xf0000000;
    }
    memw();
    _DAT_3ff42024 = 0x20000000;
    memw();
    _DAT_3ff42020 = 0x7c000005;
    memw();
    _DAT_3ff4202c = 0xff;
    _DAT_3ff42008 = esp_dport_access_reg_read(&DAT_3ff42008);
    _DAT_3ff42008 = _DAT_3ff42008 | 0x1000000;
    memw();
    _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
    _DAT_3ff42034 = _DAT_3ff42034 | 2;
    memw();
    _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
    _DAT_3ff42034 = _DAT_3ff42034 & 0xfffffffe;
    uVar2 = 1;
    memw();
  }
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void PsramQIORead(uint32_t spi_addr,uint32_t length)

{
  uint uVar1;
  uint uVar2;
  
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 | 1;
  memw();
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 & 0xfffffffd;
  uVar2 = 0;
  _DAT_3ff42004 = spi_addr | 0xeb000000;
  memw();
  memw();
  do {
    memw();
    _DAT_3ff42000 = 0x40000;
    do {
      uVar1 = esp_dport_access_reg_read(&DAT_3ff42000);
    } while ((uVar1 & 0x40000) != 0);
    uVar2 = uVar2 + 1;
  } while (uVar2 < length);
  _DAT_3ff42034 = esp_dport_access_reg_read(&DAT_3ff42034);
  _DAT_3ff42034 = _DAT_3ff42034 | 2;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff42034);
  memw();
  _DAT_3ff42034 = uVar2 & 0xfffffffe;
  return;
}



// WARNING: Unknown calling convention

void flash_test_run(u32 length)

{
  if (flash_test_enable) {
    SPI_page_program_local(0x1000,length);
    SPI_read_local(0x1000,length);
  }
  if (psram_test_enable != false) {
    PsramQIORead(0x1000,length);
  }
  if (gpio_test_enable != false) {
    gpio_test_run();
  }
  if (uart_test_enable != false) {
    phy_printf(&DAT_00055ec0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rfpll_cal_time(u8 chan_freq,u8 mode)

{
  int iVar1;
  uint8 uVar2;
  uint8 uVar3;
  uint uVar4;
  int iVar5;
  uint8 *puVar6;
  uint8 *puVar7;
  uint8 uVar8;
  uint8 or_pll_cap [100];
  uint8 ir_cap_ext;
  
  puVar7 = or_pll_cap;
  puVar6 = or_pll_cap;
  if (mode == '\0') {
    uVar2 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\x01','\a','\0');
    uVar8 = uVar2 + 0xfb;
    do {
      (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x01','\a','\0',uVar8);
      iVar5 = _DAT_60033c00;
      memw();
      puVar6 = or_pll_cap;
      do {
        uVar3 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\x05','\a','\0');
        iVar1 = _DAT_60033c00;
        *puVar6 = uVar3;
        memw();
        puVar6 = puVar6 + 1;
      } while (or_pll_cap + 0x32 != puVar6);
      memw();
      uVar3 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\x01','\a','\0');
      phy_printf("ir_cap_ext=%d: ",uVar3);
      puVar6 = or_pll_cap;
      do {
        uVar3 = *puVar6;
        puVar6 = puVar6 + 1;
        phy_printf(&DAT_00055ed4,uVar3);
      } while (or_pll_cap + 0x32 != puVar6);
      uVar8 = uVar8 + '\x01';
      phy_printf(&DAT_00055d1c,iVar1 - iVar5);
    } while ((uint8)(uVar2 + '\x05') != uVar8);
    (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x01','\a','\0',uVar2);
    return;
  }
  write_wifi_chan_data(chan_freq);
  uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = (chan_freq & 0x7f) << 1 | uVar4 & 0xffffff00;
  memw();
  uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = uVar4 & 0xe7ffffff | 0x10000000;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x100;
  memw();
  ets_delay_us(2);
  do {
    iVar5 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    if (iVar5 < 0) break;
    uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  } while ((uVar4 & 0x100) != 0);
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  iVar5 = _DAT_60033c00;
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
  memw();
  memw();
  do {
    uVar2 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\x05','\a','\0');
    iVar1 = _DAT_60033c00;
    *puVar7 = uVar2;
    memw();
    puVar7 = puVar7 + 1;
  } while (or_pll_cap + 0x32 != puVar7);
  memw();
  phy_printf("chan_freq=%d: ",(uint)chan_freq);
  do {
    uVar2 = *puVar6;
    puVar6 = puVar6 + 1;
    phy_printf(&DAT_00055ed4,uVar2);
  } while (puVar6 != or_pll_cap + 0x32);
  phy_printf(&DAT_00055d1c,iVar1 - iVar5);
  return;
}



void flash_init_param_print(bool flash_valid)

{
  uint8 uVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  uint8 *puVar5;
  phy_init_ctrl_t *ppVar6;
  phy_init_ctrl_t *ppVar7;
  u8 contin_en;
  byte *pbVar8;
  undefined *puVar9;
  
  puVar5 = chip7_phy_init_ctrl.target_power_init;
  iVar4 = 0;
  do {
    iVar3 = iVar4 + 1;
    uVar1 = *puVar5;
    puVar5 = puVar5 + 1;
    phy_printf("PWR: %d, %d\n",iVar4,uVar1);
    iVar4 = iVar3;
  } while (iVar3 != 6);
  ppVar6 = &chip7_phy_init_ctrl;
  if (chip7_phy_init_ctrl.fcc_enable == '\x02') {
    puVar5 = chip7_phy_init_ctrl.chan_pwr_limit_cbw20;
    do {
      pbVar8 = puVar5 + -0x604c8;
      bVar2 = *puVar5;
      puVar5 = puVar5 + 1;
      phy_printf("limit_cbw20: %d, %d\n",pbVar8,bVar2 >> 2);
    } while (puVar5 != chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40);
    iVar4 = 0;
    do {
      iVar3 = iVar4 + 1;
      puVar5 = ppVar6->fc_chan_pwr_limit_cbw40;
      ppVar6 = (phy_init_ctrl_t *)&ppVar6->crystal_select;
      phy_printf("limit_cbw40: %d, %d\n",iVar4,*puVar5 >> 2);
      iVar4 = iVar3;
    } while (iVar3 != 5);
  }
  else if (chip7_phy_init_ctrl.fcc_enable == '\x03') {
    puVar5 = chip7_phy_init_ctrl.chan_pwr_limit_cbw20;
    do {
      puVar9 = puVar5 + -0x604c8;
      uVar1 = *puVar5;
      puVar5 = puVar5 + 1;
      phy_printf("limit_cbw20_11b: %d, %d\n",puVar9,uVar1);
    } while (puVar5 != chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40);
    puVar5 = chip7_phy_init_ctrl.chan_pwr_limit_cbw20_gn;
    do {
      puVar9 = puVar5 + -0x604f8;
      uVar1 = *puVar5;
      puVar5 = puVar5 + 1;
      phy_printf("limit_cbw20_11gn: %d, %d\n",puVar9,uVar1);
    } while (puVar5 != &DAT_00060506);
    iVar4 = 0;
    ppVar7 = ppVar6;
    do {
      iVar3 = iVar4 + 1;
      phy_printf("limit_cbw40: %d, %d\n",iVar4,ppVar7->fc_chan_pwr_limit_cbw40[0]);
      ppVar7 = (phy_init_ctrl_t *)&ppVar7->crystal_select;
      iVar4 = iVar3;
    } while (iVar3 != 5);
    iVar4 = 0;
    do {
      iVar3 = iVar4 + 1;
      puVar5 = ppVar6->fc_chan_pwr_limit_cbw40_h;
      ppVar6 = (phy_init_ctrl_t *)&ppVar6->crystal_select;
      phy_printf("limit_cbw40_h: %d, %d\n",iVar4,*puVar5);
      iVar4 = iVar3;
    } while (iVar3 != 4);
  }
  if (freqoff_vaild != false) {
    chip_v7_set_chan_offset(freqoff_val);
    phy_printf("freq: %d khz %d\n",(int)freqoff_val,(int)phy_freq_offset);
  }
  contin_en = fixedfreq_vaild;
  if (fixedfreq_vaild != '\x01') {
    if (fixedfreq_vaild != '\x02') {
      return;
    }
    contin_en = '\0';
  }
  tx_contin_en(contin_en);
  para_array[0] = (int)fixedfreq_chan;
  para_array[1] = (int)fixedfreq_rate;
  wifitxout((uint32 *)para_array,3);
  return;
}



// WARNING: Unknown calling convention

void FillTxPacket(uint32 PacketLen,uint32 PDU0Len,uint32 PDU1Len,uint32 Rate,uint32 key_entry_no,
                 uint32 bssid_no,uint32 ap_mac_5,uint32 ap_mac_4,uint32 ap_mac_3,uint32 ap_mac_2,
                 uint32 ap_mac_1,uint32 ap_mac_0)

{
  uint psdu3_len;
  
  psdu3_len = 0;
  if (PDU0Len != 0 || PDU1Len != 0) {
    psdu3_len = (((PacketLen & 0xffff) - (PDU0Len & 0xffff)) - (PDU1Len & 0xffff)) -
                (PDU0Len >> 0x10);
  }
  fill_tx_frame(PacketLen >> 0x10,Rate,PacketLen & 0xffff,PDU0Len & 0xffff,PDU1Len & 0xffff,
                PDU0Len >> 0x10,psdu3_len,key_entry_no,bssid_no & 0xff,bssid_no >> 8 & 0x3ffff,
                bssid_no >> 0x1c & 1,ap_mac_5,ap_mac_4,ap_mac_3,ap_mac_2,ap_mac_1,ap_mac_0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void dig_gain_rse(u8 rate,u8 clip_val,u8 clip_cmp,s8 backoff,bool cbw40)

{
  code cVar1;
  uint uVar2;
  uint uVar3;
  char cVar4;
  
  if (cbw40) {
    cVar1 = __divdi3[rate];
  }
  else {
    cVar1 = (code)get_target_power_offset(rate,phy_chan_pwr_index);
  }
  uVar3 = (uint)(byte)cVar1;
  if (uVar3 < 4) {
    uVar2 = esp_dport_access_reg_read(&DAT_3ff46004);
    cVar4 = (char)(uVar2 >> ((uVar3 & 3) << 3));
  }
  else {
    uVar2 = esp_dport_access_reg_read(&DAT_3ff46008);
    cVar4 = (char)(uVar2 >> ((uVar3 & 3) << 3));
  }
  uVar3 = esp_dport_access_reg_read(&DAT_3ff46000);
  _DAT_3ff46000 = uVar3 & 0xfffffc03 | (uint)clip_val << 2;
  memw();
  _DAT_3ff46000 = esp_dport_access_reg_read(&DAT_3ff46000);
  _DAT_3ff46000 = _DAT_3ff46000 | 1;
  memw();
  uVar3 = esp_dport_access_reg_read(&DAT_3ff450e8);
  memw();
  _DAT_3ff450e8 =
       ((((uint)clip_cmp - (uint)clip_val) + 0x100) - (int)-cVar4) * 0x100 & 0xffff |
       uVar3 & 0xffff00ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void dig_gain_rse_stop(void)

{
  uint uVar1;
  
  _DAT_3ff46000 = esp_dport_access_reg_read(&DAT_3ff46000);
  _DAT_3ff46000 = _DAT_3ff46000 & 0xfffffffe;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff450e8);
  memw();
  _DAT_3ff450e8 = uVar1 & 0xffff00ff;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void txpwr_track_disable(void)

{
  chip7_sleep_params.loop_pwctrl_correct_atten = (S16)(char)target_power_backoff_qdb;
  tx_rf_ana_gain[0] = tx_rf_ana_gain_init[0];
  tx_rf_ana_gain[1] = tx_rf_ana_gain_init[1];
  chip7_sleep_params.loop_tx_rf_ana_gain[0] = tx_rf_ana_gain_init[0];
  chip7_sleep_params.loop_tx_rf_ana_gain[1] = tx_rf_ana_gain_init[1];
  chip7_sleep_params.loop_pwctrl_correct_power_qdb = '\0';
  chip7_sleep_params.loop_pwctrl_power_qdb_docal = '\0';
  chip7_sleep_params.loop_pwctrl_pwdet_error_accum = 0;
  memw();
  tx_gain_table_set();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void WifiTxStart(uint32 tx_att,uint32 TxPacketNum,uint frame_delay,uint tx_cbw40,uint ht_dup,
                int dis_agc)

{
  STATUS SVar1;
  
  tx_pocket_num = 0;
  memw();
  if (fcc_mode_sel == '\x01') {
    tx_contin_fcc_en = (bool)fcc_mode_sel;
    _DAT_3ff5c458 = esp_dport_access_reg_read(&DAT_3ff5c458);
    _DAT_3ff5c458 = _DAT_3ff5c458 | 0x100000;
    memw();
    _DAT_3ff5c400 = esp_dport_access_reg_read(&DAT_3ff5c400);
    _DAT_3ff5c400 = _DAT_3ff5c400 | 0x200000;
    memw();
    TxPacketNum = 1;
    if (dis_agc == 0) {
      memw();
    }
    else {
      if (adaptive_test_en == false) goto LAB_00037498;
      memw();
    }
  }
  else {
    tx_contin_fcc_en = false;
    _DAT_3ff5c458 = esp_dport_access_reg_read(&DAT_3ff5c458);
    _DAT_3ff5c458 = _DAT_3ff5c458 & 0xffefffff;
    memw();
    _DAT_3ff5c400 = esp_dport_access_reg_read(&DAT_3ff5c400);
    _DAT_3ff5c400 = _DAT_3ff5c400 & 0xffdfffff;
    memw();
    if ((dis_agc != 0) && (adaptive_test_en == false)) {
LAB_00037498:
      (*g_phyFuns->phy_disable_cca_)();
    }
    memw();
    _DAT_60033cc0 = 0;
    if (TxPacketNum == 0) {
      do {
        test_tx_frame(tx_att >> 0x10,tx_att & 0xffff,1,frame_delay,tx_cbw40,ht_dup);
        SVar1 = GetStopCmd();
      } while (SVar1 != OK);
      goto LAB_000374e5;
    }
  }
  _DAT_60033cc0 = 0;
  test_tx_frame(tx_att >> 0x10,tx_att & 0xffff,TxPacketNum,frame_delay,tx_cbw40,ht_dup);
LAB_000374e5:
  if (fcc_mode_flag != '\0') {
    (*g_phyFuns->pbus_workmode_)();
    tx_cont_cfg('\0');
    dig_gain_rse_stop();
    fcc_mode_flag = '\0';
    memw();
  }
  if ((dis_agc != 0) && (adaptive_test_en == false)) {
    (*g_phyFuns->phy_enable_cca_)();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint8 my_temprature_sens_read(u16 delay,u8 clk_div)

{
  uint uVar1;
  uint uVar2;
  uint32_t val;
  
  _DAT_3ff4880c = esp_dport_access_reg_read(&DAT_3ff4880c);
  _DAT_3ff4880c = _DAT_3ff4880c | 0xc0000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = uVar1 & 0xff00ffff | (uint)clk_div << 0x10;
  memw();
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c | 0x2000000;
  memw();
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c & 0xfeffffff;
  memw();
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c | 0x1000000;
  memw();
  ets_delay_us(delay);
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c | 0x4000000;
  memw();
  ets_delay_us(2);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48844);
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c & 0xfbffffff;
  memw();
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c & 0xfeffffff;
  memw();
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c & 0xfdffffff;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4880c);
  memw();
  _DAT_3ff4880c = uVar2 & 0xfff3ffff;
  return (uint8)((uVar1 & 0x3fc00000) >> 0x16);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void write_efuse_dig_reserve(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(0x3ff5a018);
  if ((uVar1 >> 2 & 1) == 0) {
    wr_en[0x18] = '\x04';
    wr_data[0x18] = '\x04';
    memw();
    burn_efuse(wr_data,wr_en);
    wr_data[0x18] = '\0';
    wr_en[0x18] = '\0';
    memw();
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void read_efuse_dig_reserve(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(0x3ff5a018);
  phy_printf("dig_reserve=%d\n",uVar1 >> 2 & 1);
  return;
}



// WARNING: Unknown calling convention

int32 sampledeal(uint32 sample)

{
  uint uVar1;
  
  uVar1 = sample & 0x3ff;
  if (0x1ff < uVar1) {
    uVar1 = uVar1 - 0x400;
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void accumiq(uint32 start_addr,uint32 burst_len)

{
  uint uVar1;
  uint32 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int32 sample_q;
  uint uVar6;
  int32 sample_i;
  
  if (burst_len >> 2 == 0) {
    iVar3 = 0;
    iVar4 = 0;
    iVar5 = 0;
  }
  else {
    iVar3 = 0;
    uVar2 = (burst_len >> 2) * 4 + start_addr;
    iVar5 = 0;
    iVar4 = 0;
    do {
      uVar1 = esp_dport_access_reg_read(start_addr);
      uVar6 = uVar1 & 0x3ff;
      start_addr = start_addr + 4;
      uVar1 = uVar1 >> 10 & 0x3ff;
      if (0x1ff < uVar6) {
        uVar6 = uVar6 - 0x400;
      }
      if (0x1ff < uVar1) {
        uVar1 = uVar1 - 0x400;
      }
      iVar4 = iVar4 + uVar1;
      iVar5 = iVar5 + uVar6;
      iVar3 = iVar3 + uVar1 * uVar1 + uVar6 * uVar6;
    } while (start_addr != uVar2);
  }
  phy_printf("%d %d %d\n",iVar4,iVar5,iVar3);
  return;
}



// WARNING: Unknown calling convention

void dc_iq_est_test(bool dc_est_en,uint16 smp_num,sint32 *dc_est,sint32 *power)

{
  S16 SVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  _func_void_varargs *p_Var5;
  int iVar6;
  int iVar7;
  _func_S16_int_uint8 *p_Var8;
  int iVar9;
  
  iVar6 = smp_num + 1;
  (*g_phyFuns->iq_est_enable_)(dc_est_en,smp_num);
  iVar2 = esp_dport_access_reg_read(0x3ff460dc);
  *dc_est = (iVar2 >> 6) / iVar6;
  iVar2 = esp_dport_access_reg_read(0x3ff460e0);
  dc_est[1] = (iVar2 >> 6) / iVar6;
  iVar2 = esp_dport_access_reg_read(0x3ff460e4);
  iVar3 = esp_dport_access_reg_read(0x3ff460ec);
  iVar4 = esp_dport_access_reg_read(0x3ff460f0);
  iVar9 = *dc_est * *dc_est;
  iVar7 = (iVar3 / iVar6) * 4 - iVar9;
  iVar3 = dc_est[1] * dc_est[1];
  iVar2 = (iVar2 / iVar6) * 8 - (iVar9 + iVar3);
  iVar3 = (iVar4 / iVar6) * 4 - iVar3;
  SVar1 = (*g_phyFuns->linear_to_db_)((uint)(-1 < iVar2) * iVar2,'\0');
  p_Var8 = g_phyFuns->linear_to_db_;
  *power = (int)SVar1;
  dc_est[2] = SVar1 + 8 >> 4;
  SVar1 = (*p_Var8)((uint)(-1 < iVar7) * iVar7,'\0');
  p_Var8 = g_phyFuns->linear_to_db_;
  power[1] = (int)SVar1;
  SVar1 = (*p_Var8)((uint)(-1 < iVar3) * iVar3,'\0');
  p_Var5 = g_phyFuns->iq_est_disable_;
  power[2] = (int)SVar1;
  (*p_Var5)();
  return;
}



// WARNING: Unknown calling convention

void ram_get_corr_power(int *power,U8 shift_bits)

{
  int iVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  
  iVar1 = esp_dport_access_reg_read(0x3ff46080);
  iVar2 = esp_dport_access_reg_read(0x3ff4608c);
  iVar6 = (iVar1 >> 9) + (iVar2 >> 9);
  iVar1 = esp_dport_access_reg_read(0x3ff46084);
  iVar2 = esp_dport_access_reg_read(0x3ff46088);
  iVar5 = (iVar1 >> 9) - (iVar2 >> 9);
  iVar1 = esp_dport_access_reg_read(0x3ff460dc);
  iVar1 = iVar1 >> 8;
  iVar2 = esp_dport_access_reg_read(0x3ff460e0);
  iVar2 = iVar2 >> 8;
  iVar3 = esp_dport_access_reg_read(0x3ff460e4);
  *power = iVar3 >> (shift_bits - 3 & 0x1f);
  uVar7 = iVar6 * iVar6 + iVar5 * iVar5;
  uVar4 = (shift_bits - 2) * 2;
  iVar3 = (uint)(uVar7 < (uint)(iVar6 * iVar6)) +
          (int)((ulonglong)((longlong)iVar6 * (longlong)iVar6) >> 0x20) +
          (int)((ulonglong)((longlong)iVar5 * (longlong)iVar5) >> 0x20);
  uVar7 = iVar3 * 2 << 0x20 - (0x20 - ((uVar4 ^ 0xffffffff) & 0x1f)) | uVar7 >> (uVar4 & 0x1f);
  if ((uVar4 >> 5 & 1) != 0) {
    uVar7 = iVar3 >> (uVar4 & 0x1f);
  }
  power[1] = uVar7;
  uVar7 = iVar1 * iVar1 + iVar2 * iVar2;
  iVar1 = (uint)(uVar7 < (uint)(iVar1 * iVar1)) +
          (int)((ulonglong)((longlong)iVar1 * (longlong)iVar1) >> 0x20) +
          (int)((ulonglong)((longlong)iVar2 * (longlong)iVar2) >> 0x20);
  uVar7 = iVar1 * 2 << 0x20 - (0x20 - ((uVar4 ^ 0xffffffff) & 0x1f)) | uVar7 >> (uVar4 & 0x1f);
  if ((uVar4 >> 5 & 1) != 0) {
    uVar7 = iVar1 >> (uVar4 & 0x1f);
  }
  power[2] = uVar7;
  return;
}



// WARNING: Unknown calling convention

void get_rx_tone_pwr(float tone_freq_set)

{
  S16 SVar1;
  S16 SVar2;
  S16 sig_power;
  int iVar3;
  int get_power [3];
  
  if (NAN(tone_freq_set * 1.0)) {
    iVar3 = -0x80000000;
    if (0.0 <= tone_freq_set) {
      iVar3 = 0x7fffffff;
    }
  }
  else {
    iVar3 = (int)(tone_freq_set * 1.4013e-45);
  }
  (*g_phyFuns->start_tx_tone_)(1,iVar3,0,0,0,0);
  ets_delay_us(5);
  (*g_phyFuns->iq_est_enable_)(true,0x200);
  ram_get_corr_power(get_power,'\t');
  SVar1 = (*g_phyFuns->linear_to_db_)(get_power[0],'\0');
  SVar2 = (*g_phyFuns->linear_to_db_)(get_power[1],'\0');
  (*g_phyFuns->iq_est_disable_)();
  (*g_phyFuns->stop_tx_tone_)(1);
  phy_printf("%d,%d\n",(int)SVar1,(int)SVar2);
  return;
}



// WARNING: Unknown calling convention

void noise_init_check(int chan_en,int upd_en)

{
  sint16 sVar1;
  s16 *psVar2;
  sint16 *psVar3;
  int iVar4;
  s16 noise_t [3];
  s16 asStack_3a [5];
  int iStack_30;
  
  psVar3 = noise_array;
  iVar4 = 1;
  iStack_30 = chan_en;
  do {
    if (iStack_30 != 0) {
      chip_v7_set_chan((int8)iVar4,'\0');
    }
    psVar2 = noise_t;
    if (upd_en != 0) {
      *psVar3 = 0;
      memw();
      psVar2 = noise_t;
    }
    do {
      sVar1 = (*g_phyFuns->check_noise_floor_)();
      *psVar2 = sVar1;
      memw();
      psVar2 = psVar2 + 1;
      if ((upd_en != 0) && (sVar1 < *psVar3)) {
        *psVar3 = sVar1;
        memw();
      }
    } while (asStack_3a != psVar2);
    iVar4 = iVar4 + 5;
    psVar3 = psVar3 + 1;
    phy_printf("%d,%d,%d;;;",(int)noise_t[0],(int)noise_t[1],(int)noise_t[2]);
  } while (iVar4 != 0x10);
  phy_printf(&DAT_00055fbc);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void test_rf_cal_level(u8 rf_cal_level,uint32 flash_addr)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  uint32 t0;
  uint8 rf_cal_data [2048];
  
  phy_set_wifi_mode_only(false);
  uVar2 = ets_efuse_get_spiconfig();
  spi_flash_attach(uVar2,0);
  SPIRead(flash_addr,rf_cal_data,0x800);
  iVar1 = _DAT_60033c00;
  memw();
  re_entry = '\0';
  memw();
  uVar3 = register_chipv7_phy((u8 *)init_param_default,rf_cal_data,rf_cal_level);
  memw();
  phy_printf("%d, rf_cal_level=%d, check_fail=%d, wakeup=%d\n",_DAT_60033c00 - iVar1,rf_cal_level,
             uVar3 & 0xff,0);
  if ((uVar3 & 0xff) != 0) {
    SPIEraseSector(flash_addr >> 0xc);
    SPIWrite(flash_addr,rf_cal_data,0x800);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void improve_dig_rtc_vol(void)

{
  DIG_pwc_mea_ate(7,'\a');
  RTC_pwc_mea_ate(7,'\t');
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void burn_in_test(void)

{
  int iVar1;
  uint8 *puVar2;
  uint uVar3;
  uint32_t uVar4;
  STATUS SVar5;
  uint uVar6;
  uint8 rf_cal_data [2048];
  uint8 pll_cap_r [14];
  u8 most_back;
  u8 wtd_num;
  u8 untx_num;
  uint plcp0_addr;
  uint8 *local_2c;
  uint local_28;
  uint plcp1_addr;
  
  untx_num = '\0';
  memw();
  plcp1_addr = Plcp1AddrGet(10);
  HTsigAddrGet(10);
  plcp0_addr = Plcp0AddrGet(10);
  pll_cap_r[0] = '\0';
  pll_cap_r[1] = '\0';
  pll_cap_r[2] = '\0';
  pll_cap_r[3] = '\0';
  pll_cap_r[4] = '\0';
  pll_cap_r[5] = '\0';
  pll_cap_r[6] = '\0';
  pll_cap_r[7] = '\0';
  pll_cap_r[8] = '\0';
  pll_cap_r[9] = '\0';
  pll_cap_r[10] = '\0';
  pll_cap_r[0xb] = '\0';
  pll_cap_r[0xc] = '\0';
  pll_cap_r[0xd] = '\0';
  memw();
  wdt_nrst_inc();
  wdt_init(0,3,160000000);
  memw();
  _DAT_60033d1c = 0;
  improve_dig_rtc_vol();
  local_2c = pll_cap_r;
  do {
    phy_printf("\nnew loop begin:\n\n");
    uart_wait_idle('\0');
    wdt_feed();
    iVar1 = _DAT_60033c00;
    memw();
    chip7_sleep_params.param_flag = 0;
    re_entry = '\0';
    memw();
    register_chipv7_phy((u8 *)init_param_default,rf_cal_data,'\x02');
    improve_dig_rtc_vol();
    chip_v7_set_chan('\x0e','\0');
    uart_wait_idle('\0');
    memw();
    phy_printf("WifiInit_TIME=%dus\n\n",_DAT_60033c00 - iVar1);
    uart_wait_idle('\0');
    iVar1 = _DAT_60033c00;
    memw();
    fill_tx_frame(10,0,1000,0x1c,0,0,0x3cc,0,0,0,0,1,2,3,4,5,6);
    WifiTxStart(0xa0012,200,5000,0,0,1);
    memw();
    phy_printf("TX_TIME=%dus\n\n",_DAT_60033c00 - iVar1);
    uart_wait_idle('\0');
    local_2c[0xe] = '\0';
    memw();
    if (0 < chip7_sleep_params.target_power_chan_backoff[0]) {
      local_2c[0xe] = (uint8)chip7_sleep_params.target_power_chan_backoff[0];
      memw();
    }
    fill_txbeacon(&wtd_num,&untx_num,&most_back,&chip7_sleep_params.param_flag,local_2c);
    iVar1 = _DAT_60033c00;
    memw();
    chip_v7_set_chan('\x01','\0');
    memw();
    _DAT_60033cc0 = 0;
    uVar3 = esp_dport_access_reg_read(plcp1_addr);
    memw();
    *(uint *)plcp1_addr = uVar3 & 0xfffe0fff | 0x1000;
    uVar3 = esp_dport_access_reg_read();
    uVar6 = 0;
    memw();
    *(uint *)plcp1_addr = uVar3 & 0xf9ffffff;
    do {
      memw();
      _DAT_60033c10 = 0x40000002;
      _DAT_60033c40 = esp_dport_access_reg_read(&DAT_60033c40);
      _DAT_60033c40 = _DAT_60033c40 | 0x84;
      memw();
      _DAT_60033c4c = esp_dport_access_reg_read(&DAT_60033c4c);
      _DAT_60033c4c = _DAT_60033c4c | 0x81;
      memw();
      uVar3 = esp_dport_access_reg_read(plcp0_addr);
      memw();
      *(uint *)plcp0_addr = uVar3 | 0xc0000000;
      do {
        uVar3 = esp_dport_access_reg_read(&DAT_60033c48);
        if ((uVar3 & 0x80) != 0) {
          local_28 = (uint)(uVar6 != 0);
          goto code_r0x00037f3e;
        }
        memw();
      } while ((uint)(_DAT_60033c00 - iVar1) < 400000);
      uVar6 = 1;
      local_28 = 1;
      local_2c[0x10] = local_2c[0x10] + '\x01';
      memw();
code_r0x00037f3e:
      memw();
      if (_DAT_60033c68 >> 0x1c != 0) {
        memw();
        phy_printf("0x%x\n",_DAT_60033c68);
      }
      ets_delay_us(5000);
      memw();
    } while ((((uint)(_DAT_60033c00 - iVar1) < 200000) || (local_28 == 0)) &&
            (uVar6 = uVar6 + 1, uVar6 < 3));
    memw();
    if (((uint)(_DAT_60033c00 - iVar1) < 200000) &&
       (uVar3 = (uint)((iVar1 + 200000) - _DAT_60033c00) / 1000, uVar3 != 0)) {
      uVar6 = 0;
      do {
        uVar6 = uVar6 + 1;
        ets_delay_us(1000);
      } while (uVar6 != uVar3);
    }
    memw();
    phy_printf("BEA_TIME=%dus\n\n",_DAT_60033c00 - iVar1);
    uVar4 = wdt_nrst();
    if (uVar4 < 0xfb) {
      local_2c[0xf] = (uint8)uVar4;
      memw();
    }
    else {
      local_2c[0xf] = 0xfa;
      memw();
    }
    if (0xfa < local_2c[0x10]) {
      local_2c[0x10] = 0xfa;
      memw();
    }
    phy_printf("WatchDog_rst_num=%d\n\n",uVar4);
    puVar2 = local_2c;
    phy_printf("UNTX BEACON NUM=%d\n\n",local_2c[0x10]);
    phy_printf("%d, %d, %d\n\n",puVar2[0xf],puVar2[0x10],puVar2[0xe]);
    uart_wait_idle('\0');
    SVar5 = GetStopCmd();
    if (SVar5 == OK) {
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rx_per_init(void)

{
  uint uVar1;
  
  set_mac_filter(0x3040506,0x102);
  uVar1 = esp_dport_access_reg_read(&DAT_600330d8);
  _DAT_600330d8 = uVar1 & 0xfffffe00 | 0xd;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_600330dc);
  _DAT_600330dc = uVar1 & 0xfffffe00 | 0xf;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_600330e0);
  _DAT_600330e0 = uVar1 & 0xfffffe00 | 0xf;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_600330e4);
  memw();
  _DAT_600330e4 = uVar1 & 0xfffffe00 | 0xf;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void clk_pull_out(u32 clk_sel)

{
  undefined4 uVar1;
  uint uVar2;
  
  _DAT_3ff49044 = esp_dport_access_reg_read(&DAT_3ff49044);
  _DAT_3ff49044 = _DAT_3ff49044 | 0xffff1e71;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff49044);
  phy_printf("check GPIO0 setting = 0x%x\n",uVar1);
  ets_delay_us(5000);
  uVar2 = esp_dport_access_reg_read(&DAT_3ff49000);
  _DAT_3ff49000 = uVar2 & 0xfffffff0 | clk_sel & 0xf;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff49000);
  phy_printf("check PIN CTRL = 0x%x\n",uVar1);
  ets_delay_us(5000);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void clk50m_pull_out(u32 clk_sel)

{
  rtc_clk_apll_enable(1,0,0,6,2);
  _DAT_3ff69800 = esp_dport_access_reg_read(&DAT_3ff69800);
  _DAT_3ff69800 = _DAT_3ff69800 & 0xffffff0f;
  memw();
  _DAT_3ff69800 = esp_dport_access_reg_read(&DAT_3ff69800);
  _DAT_3ff69800 = _DAT_3ff69800 & 0xfffffff0;
  memw();
  if (clk_sel == 0) {
    _DAT_3ff49044 = esp_dport_access_reg_read(&DAT_3ff49044);
    _DAT_3ff49044 = _DAT_3ff49044 & 0xffff8fff;
    memw();
    _DAT_3ff49044 = esp_dport_access_reg_read(&DAT_3ff49044);
    _DAT_3ff49044 = _DAT_3ff49044 | 0x1000;
    memw();
    memw();
    _DAT_3ff49000 = 6;
    phy_printf("EMAC 50MHz inverted clock output GPIO0\n");
    return;
  }
  if (clk_sel == 0x10) {
    _DAT_3ff4904c = esp_dport_access_reg_read(&DAT_3ff4904c);
    _DAT_3ff4904c = _DAT_3ff4904c & 0xffff8fff;
    memw();
    _DAT_3ff4904c = esp_dport_access_reg_read(&DAT_3ff4904c);
    _DAT_3ff4904c = _DAT_3ff4904c | 0x5000;
    memw();
    phy_printf("EMAC 50MHz inverted clock output GPIO16\n");
    return;
  }
  if (clk_sel == 0x11) {
    _DAT_3ff49050 = esp_dport_access_reg_read(&DAT_3ff49050);
    _DAT_3ff49050 = _DAT_3ff49050 & 0xffff8fff;
    memw();
    _DAT_3ff49050 = esp_dport_access_reg_read(&DAT_3ff49050);
    _DAT_3ff49050 = _DAT_3ff49050 | 0x5000;
    memw();
    phy_printf("EMAC 50MHz inverted clock output GPIO17\n");
    return;
  }
  phy_printf("selection is invalid\n");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void print_efuse_mac(void)

{
  uint32_t val;
  undefined4 uVar1;
  undefined4 uVar2;
  
  uVar1 = esp_dport_access_reg_read(0x3ff5a008);
  uVar2 = esp_dport_access_reg_read(0x3ff5a004);
  phy_printf("efuse_MAC: 0x%x-%x\n",uVar1,uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_brown_out_set(void)

{
  uint uVar1;
  
  _DAT_3ff480d4 = esp_dport_access_reg_read(&DAT_3ff480d4);
  _DAT_3ff480d4 = _DAT_3ff480d4 | 0x40000000;
  memw();
  _DAT_3ff480d4 = esp_dport_access_reg_read(&DAT_3ff480d4);
  _DAT_3ff480d4 = _DAT_3ff480d4 | 0x4000000;
  memw();
  _DAT_3ff480d4 = esp_dport_access_reg_read(&DAT_3ff480d4);
  _DAT_3ff480d4 = _DAT_3ff480d4 & 0xc7ffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff480d4);
  memw();
  _DAT_3ff480d4 = uVar1 & 0xfc00ffff | 0x20000;
  return;
}



// WARNING: Unknown calling convention

void pad_gpio_set(u32 pad_addr,bool high_en)

{
  uint uVar1;
  
  if (high_en) {
    uVar1 = esp_dport_access_reg_read(pad_addr);
    memw();
    *(uint *)pad_addr = uVar1 & 0xfffff7ff;
    uVar1 = esp_dport_access_reg_read(pad_addr);
    memw();
    *(uint *)pad_addr = uVar1 | 0x20000;
    uVar1 = esp_dport_access_reg_read(pad_addr);
    memw();
    *(uint *)pad_addr = uVar1 | 0x8000000;
    uVar1 = esp_dport_access_reg_read(pad_addr);
    memw();
    *(uint *)pad_addr = uVar1 & 0xefffffff;
    return;
  }
  uVar1 = esp_dport_access_reg_read();
  memw();
  *(uint *)pad_addr = uVar1 & 0xf7ffffff;
  uVar1 = esp_dport_access_reg_read(pad_addr);
  memw();
  *(uint *)pad_addr = uVar1 | 0x10000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_brown_out_test(u8 thres,u8 rst)

{
  uint uVar1;
  
  _DAT_3ff480d4 = esp_dport_access_reg_read(&DAT_3ff480d4);
  _DAT_3ff480d4 = _DAT_3ff480d4 | 0x40000000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff480d4);
  _DAT_3ff480d4 = (thres & 7) << 0x1b | uVar1 & 0xc7ffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff480d4);
  _DAT_3ff480d4 = uVar1 & 0xfc00ffff | 0x20000;
  memw();
  phy_printf("brown threshold set to %d\n",(uint)thres);
  ets_delay_us(5000);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff480d4);
  memw();
  _DAT_3ff480d4 = (rst & 1) << 0x1a | uVar1 & 0xfbffffff;
  return;
}



// WARNING: Unknown calling convention

void test_tx_vdd33(uint32 delay_us)

{
  byte bVar1;
  U16 UVar2;
  S16 SVar3;
  S16 SVar4;
  int iVar5;
  S8 bb_atten;
  uint uStack_30;
  
  txcal_debuge_mode(false);
  uStack_30 = delay_us & 0xffff;
  set_channel_rfpll_freq('\x01',chip7_phy_init_ctrl.crystal_select,0);
  (*g_phyFuns->set_txcap_reg_)(chip7_sleep_params.para_txcap,'\x01');
  (*g_phyFuns->pbus_force_test_)('\x05','\x01',tx_rf_ana_gain[0]);
  (*g_phyFuns->pbus_force_test_)('\x01','\x02',tx_rf_ana_gain[1]);
  bVar1 = (*g_phyFuns->txbbgain_to_index_)(tx_rf_ana_gain[1]);
  (*g_phyFuns->pbus_set_dco_)(chip7_sleep_params.txdc_table + (uint)bVar1 * 4);
  ram_rfcal_pwrctrl(0x80,chip7_sleep_params.phy_pwctrl_target_power + 5,'\x01','+',&bb_atten,
                    pwrdet_offset,rfcal_bb_atten_init,true);
  rfcal_bb_atten_init = bb_atten + '1';
  memw();
  bb_atten = rfcal_bb_atten_init;
  UVar2 = (*g_phyFuns->phy_get_vdd33_)();
  phy_printf("vdd33_init=%d\n",UVar2);
  iVar5 = 0;
  do {
    (*g_phyFuns->start_tx_tone_step_)(true,0x80,bb_atten,false,0,'\0');
    SVar3 = (*g_phyFuns->get_power_db_)(pwrdet_offset);
    SVar4 = (*g_phyFuns->get_power_db_)(pwrdet_offset);
    UVar2 = (*g_phyFuns->phy_get_vdd33_)();
    phy_printf("i=%02d  bb_atten=%d  power_sum=%d  vdd33=%d\n",iVar5,(int)bb_atten,
               (short)(SVar3 + SVar4) + 4 >> 3,UVar2);
    uart_wait_idle('\0');
    iVar5 = iVar5 + 1;
    (*g_phyFuns->stop_tx_tone_)(1);
    ets_delay_us(uStack_30);
    bb_atten = bb_atten + -2;
    memw();
  } while (iVar5 != 0x14);
  (*g_phyFuns->txcal_work_mode_)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void coex_bt_wifi_test(void)

{
  t_force_wifi = 50000;
  intr_matrix_set(0,0xe,0xc);
  _xtos_set_interrupt_handler_arg(0xc,t0_toggle_force_wifi,0);
  _xtos_ints_on(0x1000);
  t0_start_toggle(t_force_wifi);
  rw_tx_test_init(4,0,0,1,0xf,1000,0x1010);
  intr_matrix_set(0,0xf,0xd);
  _xtos_set_interrupt_handler_arg(0xd,t1_toggle_refresh_rw,0);
  _xtos_ints_on(0x2000);
  t1_start_toggle(100);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rftest_optimize(void)

{
  memw();
  _DAT_3ff5cd04 = 0x55555556;
  memw();
  _DAT_3ff5cd08 = 0x55555556;
  return;
}



// WARNING: Unknown calling convention

bool init_param_read(void)

{
  bool bVar1;
  undefined4 uVar2;
  uint8 init_param [128];
  
  uVar2 = ets_efuse_get_spiconfig();
  spi_flash_attach(uVar2,0);
  SPIRead(0x60000,init_param,0x80);
  bVar1 = (init_param[0] == 'Z') == true;
  if (bVar1) {
    phy_printf("use flash init parameters\n");
    init_param_default[0x2c] = init_param[0x10];
    memw();
    init_param_default[0x3d] = init_param[0x16];
    memw();
    freqoff_vaild = (bool)init_param[0x2a];
    memw();
    freqoff_val = (s16)init_param[0x2b];
    memw();
    fixedfreq_vaild = init_param[0x30];
    memw();
    fixedfreq_chan = init_param[0x31];
    memw();
    fixedfreq_rate = init_param[0x32];
    memw();
  }
  return bVar1;
}



// WARNING: Unknown calling convention

void flash_init_param_print(bool flash_valid)

{
  bool unaff_a10;
  
  if (flash_valid) {
    flash_init_param_print(unaff_a10);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void tx_lo_for_5g(void)

{
  uint uVar1;
  
  test_set_rf_freq_offset(chip7_phy_init_ctrl.crystal_select,0xb02,0);
  tx_rf_ana_gain[0] = 0x3f;
  tx_rf_ana_gain[1] = 0x120;
  memw();
  set_tx_gain_table(0x3f,0x120);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = uVar1 & 0xfffff0ff | 0xe00;
  memw();
  (*g_phyFuns->start_tx_tone_step_)(true,0,'(',false,0,'\0');
  return;
}



// WARNING: Unknown calling convention

void phy_temp_track(uint8 rate)

{
  byte bVar1;
  uint8 uVar2;
  ushort extraout_a2;
  
  bVar1 = tsens_code_read();
  extraout_a2 = (ushort)bVar1;
  memw();
  phy_temp_meas = extraout_a2;
  if (((phy_tx_pwr_track_en != false) && (7 < rate)) &&
     (bVar1 = get_rate_target_power(rate), 0x40 < bVar1)) {
    if ((int)phy_temp_meas - (int)phy_temp_init < 0x33) {
      (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x03','\a','\x04','\n');
      (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x04','\x03','\0','\a');
      (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x06','\x06','\x06','\0');
      (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\a','\x03','\0','\r');
    }
    else {
      (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x03','\a','\x04','\b');
      (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x04','\x03','\0','\x06');
      (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x06','\x06','\x06','\x01');
      (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\a','\x03','\0','\r');
      if (phy_tx_pwr_print_en == false) {
        return;
      }
      uVar2 = get_rate_target_power(rate);
      phy_printf("rate=%d,rate_pwr=%d\n",rate,uVar2);
    }
  }
  if (phy_tx_pwr_print_en != false) {
    phy_printf("temp=%d,%d\n",(int)phy_temp_meas,(int)phy_temp_init);
  }
  return;
}



// WARNING: Unknown calling convention

void phy_ofdm_bandage_opt(uint8 rate,sint8 backoff,bool tx_cbw40m_en)

{
  if (fcc_mode_sel == '\x01') {
    if (((byte)(rate - 0xf) < 3) || (rate == '\v')) {
      dig_gain_rse(rate,'2','\f','\0',tx_cbw40m_en);
      return;
    }
    if (((rate & 0xfb) == 10) || (rate == '\x12')) {
      dig_gain_rse(rate,'2','\v','\0',tx_cbw40m_en);
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void write_rtc_mem_test(void)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  int *piVar4;
  
  piVar4 = (int *)&DAT_3ff61000;
  iVar1 = 0;
  do {
    memw();
    *piVar4 = iVar1;
    uVar2 = esp_dport_access_reg_read(piVar4);
    iVar3 = iVar1 + 1;
    phy_printf("rtc_mem %d: %d\n",iVar1,uVar2);
    piVar4 = piVar4 + 1;
    iVar1 = iVar3;
  } while (iVar3 != 0x100);
  return;
}



// WARNING: Unknown calling convention

u32 change_data_rate(u32 rate)

{
  u32 uVar1;
  
  switch(rate) {
  case 0:
  case 4:
    return 1;
  case 1:
  case 5:
    return 2;
  case 2:
  case 6:
    return 5;
  case 3:
  case 7:
    return 0xb;
  case 8:
    return 0x30;
  case 9:
    return 0x18;
  case 10:
    return 0xc;
  case 0xb:
    return 6;
  case 0xc:
    return 0x36;
  case 0xd:
    return 0x24;
  case 0xe:
    return 0x12;
  case 0xf:
    return 9;
  case 0x10:
    uVar1 = 6;
    if (tx_cbw40m_en) {
      uVar1 = 0xd;
    }
    break;
  case 0x11:
    uVar1 = 0x1b;
    if (!tx_cbw40m_en) {
      uVar1 = 0xd;
    }
    return uVar1;
  case 0x12:
    uVar1 = 0x13;
    if (tx_cbw40m_en) {
      uVar1 = 0x28;
    }
    return uVar1;
  case 0x13:
    uVar1 = 0x1a;
    if (tx_cbw40m_en) {
      uVar1 = 0x36;
    }
    return uVar1;
  case 0x14:
    uVar1 = 0x27;
    if (tx_cbw40m_en) {
      uVar1 = 0x51;
    }
    return uVar1;
  case 0x15:
    uVar1 = 0x34;
    if (tx_cbw40m_en) {
      uVar1 = 0x6c;
    }
    return uVar1;
  case 0x16:
    uVar1 = 0x3a;
    if (tx_cbw40m_en) {
      uVar1 = 0x79;
    }
    return uVar1;
  case 0x17:
    uVar1 = 0x41;
    if (tx_cbw40m_en) {
      uVar1 = 0x87;
    }
    return uVar1;
  default:
    phy_printf("input data rate error!!! it must be in [0x0 : 0x17]\n");
    return 1;
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void get_length_delay(u32 *len_delay,u8 rate)

{
  ushort uVar1;
  byte bVar2;
  u32 uVar3;
  uint rate_00;
  int iVar4;
  int iVar5;
  u16 current [6];
  
  rate_00 = (uint)rate;
  memcpy(current,&DAT_000527f8,0xc);
  bVar2 = get_target_power_offset(rate,chip7_phy_init_ctrl.ratepwr_offset);
  uVar3 = change_data_rate(rate_00);
  if (rate_00 < 4) {
    iVar5 = 600;
    iVar4 = 400;
  }
  else if (rate_00 < 8) {
    iVar5 = 600;
    iVar4 = 500;
  }
  else {
    iVar5 = 0xa6;
    iVar4 = 0x7e;
  }
  uVar1 = current[bVar2];
  *len_delay = (int)((uVar3 & 0xff) * iVar4) >> 3;
  len_delay[1] = (uint)(((int)((uVar1 - 0x50) * 1000) / 0x14 + -1000) * iVar5) / 1000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void remove_11b_4p8G_spur(u8 remove_en,u8 num,u8 thres)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c458);
  uVar3 = (thres & 0x7f) << 8;
  _DAT_3ff5c458 = uVar1 & 0xffff80ff | uVar3;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c458);
  uVar2 = (num & 0xf) << 0xf;
  _DAT_3ff5c458 = uVar1 & 0xfff87fff | uVar2;
  memw();
  _DAT_3ff5c458 = esp_dport_access_reg_read(&DAT_3ff5c458);
  _DAT_3ff5c458 = _DAT_3ff5c458 | 0x80000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c454);
  _DAT_3ff5c454 = uVar1 & 0xffff80ff | uVar3;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c454);
  _DAT_3ff5c454 = uVar1 & 0xfff87fff | uVar2;
  memw();
  _DAT_3ff5c454 = esp_dport_access_reg_read(&DAT_3ff5c454);
  _DAT_3ff5c454 = _DAT_3ff5c454 | 0x80000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c454);
  memw();
  _DAT_3ff5c454 = uVar1 & 0xfffffffe | remove_en & 1;
  return;
}



// WARNING: Unknown calling convention

void txpwr_track_correct(s8 pwcorrect_v,bool print_en)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rx_pbus_set(uint16 rxon_rfrx,uint16 rxon_bb1,uint16 rxoff_rfrx,uint16 rxoff_bb1)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  uint *puVar7;
  uint pbus_table [256];
  uint table_rxon [4];
  uint table_rxoff [3];
  
  table_rxon[1] = (uint)rxon_bb1 << 9 | 0x1401ff;
  uVar5 = (uint)rxon_rfrx << 9 | 0x401ff;
  table_rxon[2] = 0xf50000;
  table_rxoff[0] = 0;
  table_rxon[3] = 0xf60000;
  table_rxoff[1] = 0;
  table_rxoff[2] = 0;
  table_rxon[0] = uVar5;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46030);
  uVar1 = uVar1 & 0xff;
  uVar6 = uVar1 + 3;
  uVar2 = esp_dport_access_reg_read(&DAT_3ff46030);
  puVar7 = pbus_table + uVar1;
  _DAT_3ff46030 = uVar6 * 0x100 & 0xffff | uVar2 & 0xffff00ff;
  memw();
  puVar3 = table_rxon;
  puVar4 = puVar7;
  while( true ) {
    puVar3 = puVar3 + 1;
    *puVar4 = uVar5;
    puVar4 = puVar4 + 1;
    if (puVar3 == table_rxoff) break;
    uVar5 = *puVar3;
  }
  while (uVar1 <= uVar6) {
    _DAT_3ff45038 = *puVar7;
    puVar7 = puVar7 + 1;
    memw();
    uVar2 = esp_dport_access_reg_read(&DAT_3ff45034);
    _DAT_3ff45034 = (uVar1 + 0x200) * 0x100 | uVar2 & 0xfffc00ff;
    memw();
    _DAT_3ff45034 = esp_dport_access_reg_read(&DAT_3ff45034);
    uVar1 = uVar1 + 1;
    _DAT_3ff45034 = _DAT_3ff45034 & 0xfffcffff;
    memw();
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46030);
  uVar2 = uVar1 >> 0x10 & 0xff;
  uVar6 = uVar2 + 2;
  uVar5 = uVar2 + 1;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46030);
  _DAT_3ff46030 = uVar1 & 0xffffff | uVar6 * 0x1000000;
  memw();
  puVar7 = pbus_table + uVar2;
  *puVar7 = (uint)rxoff_rfrx << 9 | 0x401ff;
  uVar1 = table_rxoff[2];
  pbus_table[uVar5] = (uint)rxoff_bb1 << 9 | 0x1401ff;
  pbus_table[uVar6] = uVar1;
  if (uVar2 <= uVar6) {
    while( true ) {
      _DAT_3ff45038 = *puVar7;
      puVar7 = puVar7 + 1;
      memw();
      uVar1 = esp_dport_access_reg_read(&DAT_3ff45034);
      _DAT_3ff45034 = (uVar2 + 0x200) * 0x100 | uVar1 & 0xfffc00ff;
      memw();
      _DAT_3ff45034 = esp_dport_access_reg_read(&DAT_3ff45034);
      _DAT_3ff45034 = _DAT_3ff45034 & 0xfffcffff;
      memw();
      if (uVar6 < uVar5) break;
      uVar2 = uVar5;
      uVar5 = uVar5 + 1;
    }
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void tx_pbus_set(uint16 txon_rfrx,uint16 txon_bb1,uint16 txoff_rfrx,uint16 txoff_bb1)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  uint *puVar7;
  uint pbus_table [256];
  uint table_txon [5];
  uint table_txoff [3];
  
  table_txon[1] = (uint)txon_bb1 << 9 | 0x1401ff;
  uVar5 = (uint)txon_rfrx << 9 | 0x401ff;
  table_txon[2] = 0xf00000;
  table_txon[3] = 0xf10000;
  table_txon[4] = 0xf20000;
  table_txoff[0] = 0;
  table_txoff[1] = 0;
  table_txoff[2] = 0;
  table_txon[0] = uVar5;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46034);
  uVar1 = uVar1 & 0xff;
  uVar6 = uVar1 + 4;
  uVar2 = esp_dport_access_reg_read(&DAT_3ff46034);
  puVar7 = pbus_table + uVar1;
  _DAT_3ff46034 = uVar6 * 0x100 & 0xffff | uVar2 & 0xffff00ff;
  memw();
  puVar3 = table_txon;
  puVar4 = puVar7;
  while( true ) {
    puVar3 = puVar3 + 1;
    *puVar4 = uVar5;
    puVar4 = puVar4 + 1;
    if (puVar3 == table_txoff) break;
    uVar5 = *puVar3;
  }
  while (uVar1 <= uVar6) {
    _DAT_3ff45038 = *puVar7;
    puVar7 = puVar7 + 1;
    memw();
    uVar2 = esp_dport_access_reg_read(&DAT_3ff45034);
    _DAT_3ff45034 = (uVar1 + 0x200) * 0x100 | uVar2 & 0xfffc00ff;
    memw();
    _DAT_3ff45034 = esp_dport_access_reg_read(&DAT_3ff45034);
    uVar1 = uVar1 + 1;
    _DAT_3ff45034 = _DAT_3ff45034 & 0xfffcffff;
    memw();
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46034);
  uVar2 = uVar1 >> 0x10 & 0xff;
  uVar6 = uVar2 + 2;
  uVar5 = uVar2 + 1;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46034);
  _DAT_3ff46034 = uVar1 & 0xffffff | uVar6 * 0x1000000;
  memw();
  puVar7 = pbus_table + uVar2;
  *puVar7 = (uint)txoff_rfrx << 9 | 0x401ff;
  uVar1 = table_txoff[2];
  pbus_table[uVar5] = (uint)txoff_bb1 << 9 | 0x1401ff;
  pbus_table[uVar6] = uVar1;
  if (uVar2 <= uVar6) {
    while( true ) {
      _DAT_3ff45038 = *puVar7;
      puVar7 = puVar7 + 1;
      memw();
      uVar1 = esp_dport_access_reg_read(&DAT_3ff45034);
      _DAT_3ff45034 = (uVar2 + 0x200) * 0x100 | uVar1 & 0xfffc00ff;
      memw();
      _DAT_3ff45034 = esp_dport_access_reg_read(&DAT_3ff45034);
      _DAT_3ff45034 = _DAT_3ff45034 & 0xfffcffff;
      memw();
      if (uVar6 < uVar5) break;
      uVar2 = uVar5;
      uVar5 = uVar5 + 1;
    }
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void pa_pbus_set(uint16 paon_txrf1,uint16 paoff_txrf1)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  uint uVar5;
  uint pbus_table [256];
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46038);
  uVar1 = uVar1 & 0xff;
  uVar5 = uVar1 + 1;
  uVar2 = esp_dport_access_reg_read(&DAT_3ff46038);
  puVar3 = pbus_table + uVar1;
  _DAT_3ff46038 = uVar5 * 0x100 & 0xffff | uVar2 & 0xffff00ff;
  memw();
  *puVar3 = (uint)paon_txrf1 << 9 | 0x4401ff;
  pbus_table[uVar5] = 0xf30000;
  uVar2 = uVar5;
  if (uVar1 <= uVar5) {
    while( true ) {
      uVar4 = uVar2;
      _DAT_3ff45038 = *puVar3;
      puVar3 = puVar3 + 1;
      memw();
      uVar2 = esp_dport_access_reg_read(&DAT_3ff45034);
      _DAT_3ff45034 = (uVar1 + 0x200) * 0x100 | uVar2 & 0xfffc00ff;
      memw();
      _DAT_3ff45034 = esp_dport_access_reg_read(&DAT_3ff45034);
      _DAT_3ff45034 = _DAT_3ff45034 & 0xfffcffff;
      memw();
      if (uVar5 < uVar4) break;
      uVar2 = uVar4 + 1;
      uVar1 = uVar4;
    }
  }
  uVar2 = esp_dport_access_reg_read(&DAT_3ff46038);
  uVar1 = uVar2 >> 0x10 & 0xff;
  uVar5 = uVar1 + 1;
  uVar2 = esp_dport_access_reg_read(&DAT_3ff46038);
  _DAT_3ff46038 = uVar2 & 0xffffff | uVar5 * 0x1000000;
  puVar3 = pbus_table + uVar1;
  memw();
  *puVar3 = (uint)paoff_txrf1 << 9 | 0x4401ff;
  pbus_table[uVar5] = 0x5401ff;
  uVar2 = uVar5;
  if (uVar1 <= uVar5) {
    while( true ) {
      uVar4 = uVar2;
      _DAT_3ff45038 = *puVar3;
      puVar3 = puVar3 + 1;
      memw();
      uVar2 = esp_dport_access_reg_read(&DAT_3ff45034);
      _DAT_3ff45034 = (uVar1 + 0x200) * 0x100 | uVar2 & 0xfffc00ff;
      memw();
      _DAT_3ff45034 = esp_dport_access_reg_read(&DAT_3ff45034);
      _DAT_3ff45034 = _DAT_3ff45034 & 0xfffcffff;
      memw();
      if (uVar5 < uVar4) break;
      uVar2 = uVar4 + 1;
      uVar1 = uVar4;
    }
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void force_txon_en(bool en)

{
  uint uVar1;
  
  if (en) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = uVar1 & 0xfffffcff | 0x200;
    memw();
    rx_pbus_set((ushort)en,0x7c,(ushort)en,0x7c);
    tx_pbus_set((ushort)en,0x7c,(ushort)en,0x7c);
    pa_pbus_set(0x7f,0x7f);
    return;
  }
  ram_set_pbus_mem();
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 | 0xc00;
  memw();
  ets_delay_us(1);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = uVar1 & 0xfffff3ff | 0x800;
  memw();
  ets_delay_us(1);
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 & 0xfffff3ff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
  memw();
  _DAT_3ff460a0 = uVar1 & 0xfffffcff;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpio_conf_for_certific(void)

{
  uint uVar1;
  byte bVar2;
  
  uart_wait_idle(uart_no);
  uVar1 = 0;
  bVar2 = 0xfa;
  do {
    if (((uVar1 & 0xfd) != 1) && (5 < bVar2)) {
      rtc_set_dig_gpio_out(uVar1,3);
    }
    bVar2 = bVar2 + 1;
    uVar1 = uVar1 + 1;
  } while (uVar1 != 0x28);
  return;
}



// WARNING: Unknown calling convention

void read_flash_init_para(u32 addr,u8 *data)

{
  undefined4 uVar1;
  
  uVar1 = ets_efuse_get_spiconfig();
  spi_flash_attach(uVar1,0);
  SPIRead(addr,data,0x90);
  return;
}



// WARNING: Unknown calling convention

void write_flash_init_para(u32 addr,u8 *data)

{
  SPIEraseSector(addr >> 0xc);
  SPIWrite(addr,data,0x90);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void fcc_bt_force_tx_tone(u32 start,u32 bt_chan,u32 power)

{
  uint uVar1;
  
  if (start != 0) {
    set_chan_freq_sw_start((char)bt_chan + '\x02',0,chip7_phy_init_ctrl.crystal_select);
    uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = uVar1 & 0xfffff0ff | 0xe00;
    memw();
    _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = _DAT_3ff460a0 | 0x30000;
    memw();
    (*g_phyFuns->start_tx_tone_step_)(true,0,(char)power + 'P',false,0,'\0');
    phy_printf("BT TX TONE START!\n");
    return;
  }
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 & 0xfffff0ff;
  memw();
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 & 0xfffcffff;
  memw();
  (*g_phyFuns->start_tx_tone_step_)(false,0,(char)power + 'P',false,0,'\0');
  phy_printf("BT TX TONE STOP!\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

U16 get_sar2_vol(uint8 atten)

{
  uint uVar1;
  U16 e [8];
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = uVar1 & 0xffffff1f | 0x80;
  memw();
  _DAT_3ff460c0 = esp_dport_access_reg_read(&DAT_3ff460c0);
  _DAT_3ff460c0 = _DAT_3ff460c0 | 0x80;
  memw();
  set_xpd_sar(true);
  _DAT_3ff48890 = esp_dport_access_reg_read(&DAT_3ff48890);
  _DAT_3ff48890 = _DAT_3ff48890 | 0x8000000;
  memw();
  _DAT_3ff4882c = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = _DAT_3ff4882c | 0x10;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48838);
  _DAT_3ff48838 = uVar1 & 0x3fffffff | (uint)atten << 0x1e;
  memw();
  _DAT_3ff4e05c = esp_dport_access_reg_read(&DAT_3ff4e05c);
  _DAT_3ff4e05c = _DAT_3ff4e05c | 0x800000;
  memw();
  _DAT_3ff4e05c = esp_dport_access_reg_read(&DAT_3ff4e05c);
  _DAT_3ff4e05c = _DAT_3ff4e05c & 0xffdfffff;
  memw();
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4e050);
  } while ((uVar1 >> 0x18 & 7) != 0);
  _DAT_3ff4e050 = esp_dport_access_reg_read(&DAT_3ff4e050);
  _DAT_3ff4e050 = _DAT_3ff4e050 & 0xfffffffd;
  memw();
  _DAT_3ff4e050 = esp_dport_access_reg_read(&DAT_3ff4e050);
  _DAT_3ff4e050 = _DAT_3ff4e050 | 2;
  memw();
  ets_delay_us(10);
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4e050);
  } while ((uVar1 >> 0x18 & 7) != 0);
  (*g_phyFuns->read_sar_dout_)(e);
  _DAT_3ff4882c = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = _DAT_3ff4882c & 0xffffffef;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e05c);
  memw();
  _DAT_3ff4e05c = uVar1 & 0xff7fffff;
  return (U16)(e[0] + 4 >> 3);
}



// WARNING: Unknown calling convention

void coex_test(u8 mode)

{
  coex_test_enable = true;
  memw();
  t_force_wifi = 50000;
  intr_matrix_set(0,0xe,0xc);
  _xtos_set_interrupt_handler_arg(0xc,t0_toggle_force_wifi,0);
  _xtos_ints_on(0x1000);
  t0_start_toggle(t_force_wifi);
  if (mode == '\0') {
    phy_printf("rw_le_advscan_test_init");
    rw_le_advscan_test_init();
    _xtos_set_interrupt_handler_arg(0xd,t1_toggle_refresh_rw_le_advscan,0);
  }
  else if (mode == '\x01') {
    phy_printf("rw_le_rx_per_init");
    rw_le_rx_per_init(0x26);
    _xtos_set_interrupt_handler_arg(0xd,t1_toggle_refresh_rw_le_check_rx,0);
  }
  else if (mode == '\x02') {
    phy_printf("rw_rx_per_init");
    rw_rx_per_init(1,0x27);
    _xtos_set_interrupt_handler_arg(0xd,t1_toggle_check_rx,0);
  }
  else if (mode == '\x03') {
    phy_printf("rw_inq_test_init");
    rw_inq_test_init(4,1,0,0,0xf,1000,1);
    _xtos_set_interrupt_handler_arg(0xd,t1_toggle_refresh_rw,0);
  }
  else if (mode == '\x04') {
    phy_printf("rw_tx_test_init");
    rw_tx_test_init(4,0,0,1,0xf,1000,0x1010);
    _xtos_set_interrupt_handler_arg(0xd,t1_toggle_refresh_rw,0);
  }
  else if (mode == '\x05') {
    phy_printf("rw_le_adv_test_init");
    rw_le_adv_test_init();
    _xtos_set_interrupt_handler_arg(0xd,t1_toggle_refresh_rw_le,0);
  }
  else {
    phy_printf("rw_le_tx_nohoppe_init");
    rw_le_tx_nohoppe_init(0x27,4,0xaaaa,0x1e);
    _xtos_set_interrupt_handler_arg(0xd,t1_toggle_refresh_rw_le,0);
  }
  intr_matrix_set(0,0xf,0xd);
  _xtos_ints_on(0x2000);
  t1_start_toggle(100);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_rtc_dig_dbias(uint8 dig_dbias)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  _DAT_3ff4807c = uVar1 & 0xfffff8ff | (dig_dbias & 7) << 8;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4807c);
  memw();
  _DAT_3ff4807c = uVar1 & 0xffffc7ff | (dig_dbias & 7) << 0xb;
  return;
}



// WARNING: Unknown calling convention

void rtc_clk_bbpll_set_new(uint8 ref)

{
  uint8 uVar1;
  uint8 uVar2;
  uint8 uVar3;
  
  if (ref == '\x04') {
    uVar1 = '@';
    uVar2 = '`';
    uVar3 = 0xa9;
  }
  else if (ref == '(') {
    uVar1 = 0xc6;
    uVar2 = ' ';
    uVar3 = '\0';
  }
  else {
    uVar2 = '\0';
    uVar3 = ref == '\x14';
    if ((bool)uVar3) {
      uVar2 = '`';
    }
    uVar1 = '\0';
    if (ref == '\x14') {
      uVar1 = 0xc6;
    }
  }
  (*g_phyFuns->i2c_writeReg_)('f','\x04','\x02',uVar3);
  (*g_phyFuns->i2c_writeReg_)('f','\x04','\x03',uVar2);
  (*g_phyFuns->i2c_writeReg_)('f','\x04','\x05',uVar1);
  ets_delay_us(0xa0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_clk_cpu_freq_set_new(uint8 ref)

{
  int iVar1;
  rtc_xtal_freq_t xtal_freq;
  
  iVar1 = rtc_clk_xtal_freq_get();
  memw();
  _DAT_3ff48070 = _DAT_3ff48070 & 0xe7ffffff;
  memw();
  ets_update_cpu_frequency();
  rtc_clk_wait_for_slow_cycle();
  _DAT_3ff48000 = esp_dport_access_reg_read(&DAT_3ff48000);
  _DAT_3ff48000 = _DAT_3ff48000 | 0x400;
  memw();
  rtc_clk_apb_freq_update(iVar1 * 1000000);
  _DAT_3ff48000 = esp_dport_access_reg_read(&DAT_3ff48000);
  _DAT_3ff48000 = _DAT_3ff48000 & 0xfffffbff;
  memw();
  rtc_clk_bbpll_set_new(ref);
  memw();
  _DAT_3ff48070 = _DAT_3ff48070 & 0xe7ffffff | 0x8000000;
  memw();
  rtc_clk_wait_for_slow_cycle();
  rtc_clk_apb_freq_update(80000000);
  ets_update_cpu_frequency(0x50);
  return;
}



// WARNING: Unknown calling convention

void bbpll_80m_cal(uint8 ref)

{
  rtc_clk_cpu_freq_set_new(ref);
  rtc_uart_div_modify(0);
  return;
}



// WARNING: Unknown calling convention

void bt_rx_spur_cal(uint32 chan,bool print_en)

{
  uint8 uVar1;
  uint32 rx_pwr [2];
  
  if (chan == 0x13) {
    set_chan_freq_sw_start(',',0,chip7_phy_init_ctrl.crystal_select);
    bt_rx_2440_dac = rx_spur_cal(false,print_en,rx_pwr);
    memw();
    bt_rx_2440_dcur = rx_spur_cal(true,print_en,rx_pwr);
    memw();
    return;
  }
  set_chan_freq_sw_start('T',0,chip7_phy_init_ctrl.crystal_select);
  uVar1 = rx_spur_cal(false,print_en,rx_pwr);
  if (chan == 0x27) {
    memw();
    bt_rx_2480_dac = uVar1;
    bt_rx_2480_dcur = rx_spur_cal(true,print_en,rx_pwr);
    memw();
    return;
  }
  rx_spur_cal(true,print_en,rx_pwr);
  return;
}



// WARNING: Unknown calling convention

void bt_2480_opt_enter(uint32 chan)

{
  uint32 uVar1;
  
  if (!bt_2480_opt_en) {
    return;
  }
  if (chan == 0x27) {
    (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\a','\x06','\0');
    if (bt_rx_chan_old == 0x27) goto LAB_00039d6c;
LAB_00039d02:
    bt_rx_spur_cal(chan,bt_2480_print);
    uVar1 = chan;
  }
  else {
    uVar1 = bt_rx_chan_old;
    if ((chan != bt_rx_chan_old) && (uVar1 = chan, chan == 0x13)) goto LAB_00039d02;
  }
  bt_rx_chan_old = uVar1;
  if (chan == 0x13) {
    (*g_phyFuns->i2c_writeReg_Mask_)('h','\x03','\0','\x05','\x02',bt_rx_2440_dac);
    (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\x02','\0',bt_rx_2440_dcur);
    return;
  }
  if (chan != 0x27) {
    return;
  }
LAB_00039d6c:
  (*g_phyFuns->i2c_writeReg_Mask_)('h','\x03','\0','\x05','\x02',bt_rx_2480_dac);
  (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\x02','\0',bt_rx_2480_dcur);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_2480_opt_exit(void)

{
  if (bt_2480_opt_en) {
    (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\a','\x06','\x03');
    (*g_phyFuns->i2c_writeReg_Mask_)('h','\x03','\0','\x05','\x02','\b');
    (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\x02','\0','\x06');
  }
  return;
}



// WARNING: Unknown calling convention

void bt_3200_opt(bool en)

{
  if (en) {
    (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\a','\a','\0');
    (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x02','\x03','\0','\0');
    en = true;
  }
  else {
    (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01',en,'\a','\a','\x01');
    (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x02','\x03',en,'\b');
  }
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\b','\a','\x06',en);
  return;
}



// WARNING: Unknown calling convention

void test_2480_power(uint32 shift)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint64 pwr_sum [7];
  S16 rxiq_remain;
  
  iVar2 = -0x68;
  do {
    freq_offset_get_pwr('\x06',(S16)iVar2,'\n',pwr_sum,&rxiq_remain,false,false);
    iVar3 = iVar2 + 1;
    uVar6 = pwr_sum[1]._4_4_ >> (shift & 0x1f);
    uVar7 = uVar6;
    uVar1 = (pwr_sum[1]._4_4_ << 1) << 0x20 - (0x20 - ((shift ^ 0xffffffff) & 0x1f)) |
            (uint)pwr_sum[1] >> (shift & 0x1f);
    if ((shift & 0x20) != 0) {
      uVar7 = 0;
      uVar1 = uVar6;
    }
    uVar4 = pwr_sum[0]._4_4_ >> (shift & 0x1f);
    uVar5 = uVar4;
    uVar6 = (pwr_sum[0]._4_4_ << 1) << 0x20 - (0x20 - ((shift ^ 0xffffffff) & 0x1f)) |
            (uint)pwr_sum[0] >> (shift & 0x1f);
    if ((shift & 0x20) != 0) {
      uVar5 = 0;
      uVar6 = uVar4;
    }
    phy_printf("step=%d,sig_pwr=%lld,tot_pwr=%lld\n",iVar2,uVar6,uVar5,uVar1,uVar7);
    iVar2 = iVar3;
  } while (iVar3 != -100);
  return;
}



// WARNING: Unknown calling convention

u32 ble_chan_trans(u32 chan)

{
  u32 uVar1;
  
  if (chan == 0x25) {
    uVar1 = 0;
  }
  else {
    uVar1 = 0xc;
    if ((chan != 0x26) && (uVar1 = chan, chan != 0x27)) {
      if (chan < 0xb) {
        uVar1 = chan + 1;
      }
      else {
        uVar1 = 0;
        if (chan < 0x25) {
          uVar1 = chan + 2;
        }
      }
    }
  }
  return uVar1;
}



// WARNING: Unknown calling convention

uint16 bt_chan_change(bool bt_en,uint8 chan_num,bool tx_en)

{
  uint16 uVar1;
  
  if (bt_en) {
    if (chan_num < 0x28) {
      uVar1 = (chan_num + 0x4b1) * 2;
    }
    else {
      uVar1 = (chan_num - 0x28) * 2 + 0x963;
    }
  }
  else {
    uVar1 = 0x962;
    if (((chan_num != '%') && (uVar1 = 0x97a, chan_num != '&')) && (uVar1 = 0x9b0, chan_num != '\'')
       ) {
      if (chan_num < 0xb) {
        uVar1 = (chan_num + 0x4b2) * 2;
      }
      else {
        uVar1 = 0x962;
        if (chan_num < 0x25) {
          uVar1 = (chan_num + 0x4b3) * 2;
        }
      }
    }
  }
  if (!tx_en) {
    uVar1 = uVar1 + 2;
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void bt_set_freq_cal(bool bt_en,uint8 chan_num,bool tx_en)

{
  uint16 uVar1;
  
  uVar1 = bt_chan_change(bt_en,chan_num,tx_en);
  set_chan_freq_sw_start((char)uVar1 + 0xa0,0,chip7_phy_init_ctrl.crystal_select);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_freq_test(uint32 *para_array,uint32 para_num)

{
  uint uVar1;
  STATUS SVar2;
  
  phy_printf("set_freq_test,%d, %d %d %d %d\n",*para_array,para_array[1],para_array[2],para_array[3]
             ,para_array[4]);
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 | 0x3000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = uVar1 & 0xfffff0ff | 0xe00;
  memw();
  (*g_phyFuns->start_tx_tone_step_)(true,0x20,'P',false,0,'\0');
  do {
    if (para_array[1] != 0) {
      uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
      _DAT_3ff460a0 = uVar1 & 0xfffff0ff | 0x200;
      memw();
      ets_delay_us(10);
      uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
      _DAT_3ff460a0 = uVar1 & 0xfffff0ff | 0xe00;
      memw();
      ets_delay_us(2);
    }
    uVar1 = 2;
    if (2 < para_num) {
      do {
        set_chan_freq_sw_start(*(U8 *)(para_array + uVar1),0,chip7_phy_init_ctrl.crystal_select);
        ets_delay_us(*(undefined2 *)para_array);
        uVar1 = uVar1 + 1 & 0xff;
      } while (uVar1 < para_num);
    }
    SVar2 = GetStopCmd();
  } while (SVar2 != OK);
  phy_printf("set_freq_test done\n");
  return;
}



// WARNING: Unknown calling convention

void pbus_test_init(bool bt_sel)

{
  uint16 txdc [4];
  
  (*g_phyFuns->pbus_force_test_)('\0','\x01',1);
  (*g_phyFuns->pbus_force_test_)('\x01','\x02',0x20);
  if (bt_sel) {
    (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x7e);
    (*g_phyFuns->pbus_set_dco_)(chip7_sleep_params.bt_txdc_table + 4);
  }
  else {
    (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x7c);
    (*g_phyFuns->pbus_set_dco_)(chip7_sleep_params.txdc_table + 4);
  }
  (*g_phyFuns->pbus_force_test_)('\x05','\x01',0x1f);
  (*g_phyFuns->pbus_force_test_)('\x04','\x01',0x7f);
  ets_delay_us(10);
  (*g_phyFuns->txdc_cal_v70_)((sint16 *)txdc);
  (*g_phyFuns->pbus_force_test_)('\x04','\x01',0);
  (*g_phyFuns->pbus_force_test_)('\x01','\x01',0);
  (*g_phyFuns->pbus_force_test_)('\0','\x01',0);
  return;
}



// WARNING: Unknown calling convention

void pbus_wr_que(bool bt_sel,bool rfrx_en,bool filt_en,bool pa_en,uint16 delay_us,uint16 *txdc)

{
  sleep_param_t *psVar1;
  int iVar2;
  uint16 *puVar3;
  uint16 uVar4;
  
  if ((((*txdc == 0) || (txdc[1] == 0)) || (txdc[2] == 0)) || (txdc[3] == 0)) {
    iVar2 = 4;
    psVar1 = &chip7_sleep_params;
    puVar3 = txdc;
    do {
      if (bt_sel) {
        uVar4 = psVar1->bt_txdc_table[4];
      }
      else {
        uVar4 = psVar1->txdc_table[4];
      }
      psVar1 = (sleep_param_t *)((int)&psVar1->param_flag + 2);
      *puVar3 = uVar4;
      memw();
      puVar3 = puVar3 + 1;
      iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
  }
  if (rfrx_en) {
    (*g_phyFuns->pbus_force_test_)('\0','\x01',1);
  }
  if (filt_en) {
    (*g_phyFuns->pbus_force_test_)('\x01','\x02',0x20);
    if (bt_sel) {
      (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x7e);
    }
    else {
      (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x7c);
    }
    (*g_phyFuns->pbus_set_dco_)(txdc);
  }
  if (pa_en) {
    (*g_phyFuns->pbus_force_test_)('\x05','\x01',0x1f);
    (*g_phyFuns->pbus_force_test_)('\x04','\x01',0x7f);
  }
  ets_delay_us(delay_us);
  return;
}



// WARNING: Unknown calling convention

void pbus_debug_test(bool bt_sel,uint8 rfrx_num,uint8 txbb_num,uint8 pa_num,uint16 delay1,
                    uint16 delay2,uint16 delay3,uint16 rx_bb,uint16 rx_pa,uint16 rfrx,
                    uint32 *txdc_in)

{
  STATUS SVar1;
  uint16 txdc [4];
  
  txdc[0] = (uint16)*txdc_in;
  memw();
  phy_printf("bt_sel=%d,num=%d %d %d,delay=%d %d %d,rx=%x %x %x\n",bt_sel,rfrx_num,txbb_num,pa_num,
             delay1,delay2,delay3,rx_bb,rx_pa,rfrx);
  (*g_phyFuns->set_txclk_en_)(true);
  (*g_phyFuns->pbus_debugmode_)();
  do {
    pbus_wr_que(bt_sel,rfrx_num == '\x01',txbb_num == '\x01',pa_num == '\x01',delay1,txdc);
    pbus_wr_que(bt_sel,rfrx_num == '\x02',txbb_num == '\x02',pa_num == '\x02',delay2,txdc);
    pbus_wr_que(bt_sel,rfrx_num == '\x03',txbb_num == '\x03',pa_num == '\x03',delay3,txdc);
    (*g_phyFuns->pbus_force_test_)('\x01','\x01',rx_bb);
    (*g_phyFuns->pbus_force_test_)('\x04','\x01',rx_pa);
    (*g_phyFuns->pbus_force_test_)('\0','\x01',rfrx);
    ets_delay_us(1000);
    SVar1 = GetStopCmd();
  } while (SVar1 != OK);
  phy_printf("done\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void force_power_level(bool force_en,uint8 level)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  
  uVar3 = (uint)level;
  if (force_en) {
    uVar2 = esp_dport_access_reg_read(&DAT_3ff46000);
    iVar4 = (uVar3 < 7) * uVar3 + (uint)(uVar3 >= 7) * 7;
    bVar1 = phy_chan_gain_table[iVar4];
    uVar3 = esp_dport_access_reg_read(&DAT_3ff46000);
    _DAT_3ff46000 = (((uVar2 & 0x3fc0000) >> 0x12) + iVar4 & 0xff) << 10 | uVar3 & 0xfffc03ff;
    memw();
    uVar3 = esp_dport_access_reg_read(&DAT_3ff46000);
    _DAT_3ff46000 = (uint)bVar1 << 2 | uVar3 & 0xfffffc03;
    memw();
    _DAT_3ff46000 = esp_dport_access_reg_read(&DAT_3ff46000);
    _DAT_3ff46000 = _DAT_3ff46000 | 2;
    memw();
    uVar3 = esp_dport_access_reg_read(&DAT_3ff46000);
    memw();
    _DAT_3ff46000 = uVar3 | 1;
    return;
  }
  _DAT_3ff46000 = esp_dport_access_reg_read(&DAT_3ff46000);
  _DAT_3ff46000 = _DAT_3ff46000 & 0xfffffffd;
  memw();
  uVar3 = esp_dport_access_reg_read(&DAT_3ff46000);
  memw();
  _DAT_3ff46000 = uVar3 & 0xfffffffe;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void pvt_ate(void)

{
  uint16 uVar1;
  uint16 uVar2;
  uint16 uVar3;
  uint16 uVar4;
  
  pvt_pwr_ctrl('\x01');
  ets_delay_us(100);
  uVar1 = pvt_test(2,false,400);
  ets_delay_us(600);
  uVar2 = pvt_test(3,false,400);
  ets_delay_us(600);
  uVar3 = pvt_test(4,false,400);
  ets_delay_us(600);
  uVar4 = pvt_test(7,false,400);
  ets_delay_us(600);
  pvt_pwr_ctrl('\0');
  phy_printf("pvt_ate,%d,%d,%d,%d\n",uVar1,uVar2,uVar3,uVar4);
  return;
}



// WARNING: Unknown calling convention

void get_path_loss_offset(s32 *pwr_list)

{
  sint32 pwr_ac [3];
  sint32 dc_est [3];
  sint16 dc_comp [4];
  
  dc_comp[3] = 0x100;
  dc_comp[0] = 0x100;
  dc_comp[1] = 0x100;
  dc_comp[2] = 0x100;
  memw();
  (*g_phyFuns->pbus_debugmode_)();
  (*g_phyFuns->loopback_mode_en_)(true);
  (*g_phyFuns->set_loopback_gain_)(0,0x104,0x20);
  (*g_phyFuns->pbus_rx_dco_cal_)(4000,dc_comp,10,false,false);
  (*g_phyFuns->start_tx_tone_step_)(true,0x40,'\x14',false,0,'\0');
  dc_iq_est_test(true,0x800,dc_est,pwr_ac);
  *pwr_list = dc_est[2];
  if (dc_est[2] - 0x21U < 7) {
    pwr_list[1] = 0;
  }
  else {
    pwr_list[1] = dc_est[2] + -0x24 >> 1;
  }
  (*g_phyFuns->start_tx_tone_step_)(false,0x40,'(',false,0,'\0');
  (*g_phyFuns->loopback_mode_en_)(false);
  (*g_phyFuns->pbus_xpd_rx_on_)(0);
  (*g_phyFuns->pbus_workmode_)();
  return;
}



// WARNING: Unknown calling convention

void mac_filter_enable(bool enable)

{
  mac_filter_en = enable;
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void force_rx_gain(bool force_en,uint8 gain,bool bt_mode)

{
  uint uVar1;
  
  if (bt_mode) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = (gain + 0x80) * 0x1000000 | uVar1 & 0xffffff;
    memw();
  }
  else {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = uVar1 & 0xffffff | (uint)gain << 0x18;
    memw();
  }
  _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = _DAT_3ff5c02c & 0xff7fffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
  memw();
  _DAT_3ff5c02c = (force_en & 1) << 0x17 | uVar1 & 0xff7fffff;
  return;
}



// WARNING: Unknown calling convention

void rx_gain_comp_cal(bool print_en,bool bt_mode)

{
  uint8 uVar1;
  u16 uVar2;
  s32 sVar3;
  uint8 in_a5;
  uint8 btcmplx;
  _func_void_uint8_uint8_uint8_uint8 *p_Var4;
  _func_void_u8_u8_u16 *p_Var5;
  _func_void_bool_sint16_uint8_bool_sint16_uint8 *p_Var6;
  sint16 sVar7;
  sint16 rx_dc_comp [4];
  uint32 dc_est [2];
  undefined4 uStack_20;
  
  rx_dc_comp[0] = 0x100;
  rx_dc_comp[3] = 0x100;
  rx_dc_comp[1] = 0x100;
  rx_dc_comp[2] = 0x100;
  memw();
  if (bt_mode) {
    p_Var4 = g_phyFuns->i2c_writeReg_;
    uVar1 = get_rfrx_dcap_bt('\x04');
    (*p_Var4)('d','\0','\x04',uVar1);
    p_Var4 = g_phyFuns->i2c_writeReg_;
    uVar1 = get_rfrx_dcap_bt('\a');
    (*p_Var4)('d','\0','\a',uVar1);
    in_a5 = (*g_phyFuns->i2c_readReg_Mask_)('g','\x01','\x0f','\x02','\0');
    (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x0f','\x02','\0','\0');
  }
  (*g_phyFuns->pbus_debugmode_)();
  (*g_phyFuns->pbus_xpd_rx_on_)(0);
  (*g_phyFuns->loopback_mode_en_)(true);
  (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x1f1);
  (*g_phyFuns->set_loopback_gain_)(0,0x1b4,0x20);
  if (bt_mode) {
    p_Var5 = g_phyFuns->pbus_force_test_;
    uVar2 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
    (*p_Var5)('\x01','\x01',uVar2 | 2);
    (*g_phyFuns->pbus_rx_dco_cal_)(4000,rx_dc_comp,10,false,false);
    sVar7 = 0x20;
    if (!bt_mode) {
      sVar7 = 0x80;
    }
    p_Var6 = g_phyFuns->start_tx_tone_step_;
  }
  else {
    (*g_phyFuns->pbus_rx_dco_cal_)(4000,rx_dc_comp,10,bt_mode,bt_mode);
    sVar7 = 0x80;
    p_Var6 = g_phyFuns->start_tx_tone_step_;
  }
  (*p_Var6)(true,sVar7,'(',false,0,'\0');
  ets_delay_us(5);
  ram_dc_iq_est(true,0x1000,(sint32 *)dc_est);
  if (print_en) {
    phy_printf("%d,%d,%d\n",dc_est[0],dc_est[1],uStack_20);
  }
  (*g_phyFuns->stop_tx_tone_)(1);
  (*g_phyFuns->loopback_mode_en_)(false);
  (*g_phyFuns->pbus_xpd_rx_on_)(0);
  (*g_phyFuns->pbus_workmode_)();
  force_rx_gain(true,'F',false);
  force_rx_gain(false,'F',false);
  sVar3 = (*g_phyFuns->get_data_sat_)((int)(short)(((short)uStack_20 + -0x2f) * 2),0,-0xc);
  set_chan_rxcomp((sint8)sVar3);
  if (bt_mode) {
    (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x0f','\x02','\0',in_a5);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void WifiRxStart(WIFI_RATE rx_rate)

{
  rx_gain_comp_cal(false,false);
  bb_wdt_rst_enable(true);
  do_rx_poll(rx_rate);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void wifi_init(void)

{
  bool bVar1;
  bool flash_valid;
  byte bVar2;
  int iVar3;
  uint uVar4;
  uint8 rf_cal_data [2048];
  rwip_rf_api api;
  uint8 mac_addr [6];
  
  phy_get_romfunc_addr();
  i2c_xtal_init();
  phy_printf("xtal clk=%d, CRYSTAL_SELECT=%d\n",0x28,0);
  rtc_init_lite(0x28);
  memw();
  _DAT_3ff000c0 = 0xffffffff;
  memw();
  _DAT_3ff000cc = 0xffffffff;
  _DAT_3ff4808c = esp_dport_access_reg_read(&DAT_3ff4808c);
  _DAT_3ff4808c = _DAT_3ff4808c & 0xfffffbff;
  memw();
  _DAT_3ff5f048 = esp_dport_access_reg_read(&DAT_3ff5f048);
  _DAT_3ff5f048 = _DAT_3ff5f048 & 0xffffbfff;
  memw();
  iVar3 = GetUartDevice();
  uart_no = *(uint8 *)(iVar3 + 0x18);
  memw();
  uart_tx_switch(uart_no);
  uart_wait_idle(uart_no);
  ets_delay_us(0xffff);
  uart_div_modify(uart_no,0x15b3);
  uart_wait_idle(uart_no);
  rtc_set_cpu_freq(1);
  ets_update_cpu_frequency(0x50);
  uart_div_modify(uart_no,0x2b67);
  print_efuse_mac();
  phy_set_wifi_mode_only(false);
  read_macaddr_from_otp(mac_addr);
  rf_cal_data[4] = mac_addr[0];
  memw();
  uVar4 = esp_dport_access_reg_read(0x3ff44038);
  if ((uVar4 >> 4 & 1) == 0) {
    register_chipv7_phy((u8 *)init_param_default,rf_cal_data,'\x02');
    rx_gain_level(false);
    noise_init();
    coex_bt_high_prio();
    rf_rw_init(&api);
    phy_bt_power_track(true);
    mac_init();
    write_efuse_dig_reserve();
    phy_pwdet_always_en(true);
    rx_gain_comp_cal(false,false);
    esp_dport_access_reg_read(0x3ff44038);
  }
  else {
    bVar1 = init_param_read();
    register_chipv7_phy((u8 *)init_param_default,rf_cal_data,'\x02');
    rx_gain_level(false);
    noise_init();
    coex_bt_high_prio();
    rf_rw_init(&api);
    phy_bt_power_track(true);
    mac_init();
    write_efuse_dig_reserve();
    phy_pwdet_always_en(true);
    rx_gain_comp_cal(false,false);
    flash_valid = (bool)esp_dport_access_reg_read(0x3ff44038);
    if (((flash_valid & 0x10U) != 0) && (bVar1)) {
      flash_init_param_print(flash_valid);
    }
  }
  phy_version_print();
  phy_printf("*RFTestBIN %d\n",0xc1);
  tx_rf_ana_gain_init[0] = tx_rf_ana_gain[0];
  memw();
  tx_rf_ana_gain_init[1] = tx_rf_ana_gain[1];
  memw();
  memw();
  _DAT_3ff5cd04 = 0x55555556;
  memw();
  _DAT_3ff5cd08 = 0x55555556;
  bVar2 = tsens_code_read();
  phy_temp_init = (ushort)bVar2;
  memw();
  return;
}



// WARNING: Unknown calling convention

void idf_enable(uint8 conf)

{
  short_log_en = (bool)conf;
  memw();
  return;
}


/*
Unable to decompile 'run_rftest_case'
Cause: Exception while decompiling 0003b8d0: process: timeout

*/


// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_tx_8m_enable(uint hoppe_n500k)

{
  memw();
  memw();
  _DAT_3ff51000 = _DAT_3ff51000 & 0xffffffc3;
  memw();
  _DAT_3ff51014 = 0x18021;
  memw();
  memw();
  _DAT_3ff51044 = _DAT_3ff51044 & 0xffffff00 | 0xa0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51040 = (hoppe_n500k & 0x3f) << 0x15 | _DAT_3ff51040 & 0xf81fffff | 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_tx_if_init(uint guard,uint tx_on_ahead,uint tx_on_behind,uint init_tx_DC)

{
  uint16 uVar1;
  uint uVar2;
  
  memw();
  _DAT_3ff5103c = (guard & 0x3ff) << 0x15 | _DAT_3ff5103c & 0x801fffff;
  memw();
  uVar1 = phy_get_fetx_delay();
  memw();
  memw();
  memw();
  uVar2 = (tx_on_behind & 0x3ff) << 1 | (1000 - uVar1 & 0x3ff) << 0xb | _DAT_3ff5103c & 0xffe00001;
  memw();
  memw();
  _DAT_3ff5103c = uVar2 | 0x80000000;
  memw();
  if (init_tx_DC != 0) {
    memw();
    _DAT_3ff5103c = uVar2 | 0x80000001;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void BT_init_rx_filters(uint16 freq_offset_500k)

{
  memw();
  _DAT_3ff51028 = 0x17;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff5105c = _DAT_3ff5105c & 0xfc1f07ff | 0x3409800;
  memw();
  memw();
  _DAT_3ff51058 = _DAT_3ff51058 & 0xffff03ff | 0x5000;
  memw();
  memw();
  _DAT_3ff51020 = -(uint)freq_offset_500k & 0x3f | _DAT_3ff51020 & 0xffffffc0;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff5c090 = _DAT_3ff5c090 & 0xc00fffff | 0x32700000;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff5c0d0 = _DAT_3ff5c0d0 & 0xfffffe00 | 0x1d4;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff5104c = _DAT_3ff5104c & 0xffff83ff | 0x7800;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff5c07c = _DAT_3ff5c07c & 0xc000ffff | 0x3a10000;
  memw();
  memw();
  _DAT_3ff5c080 = _DAT_3ff5c080 & 0x1f8000c1 | 0x6019d408;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff5c084 = _DAT_3ff5c084 & 0xe02001ff | 0x989e00;
  memw();
  memw();
  _DAT_3ff5106c = _DAT_3ff5106c & 0xfff0ffff | 0x60000;
  memw();
  memw();
  _DAT_60032124 = _DAT_60032124 | 0x200;
  memw();
  memw();
  _DAT_3ff51084 = _DAT_3ff51084 & 0xff00ffff | 0xfb0000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_dgmixer_fstep_250k(void)

{
  memw();
  memw();
  _DAT_3ff51040 = _DAT_3ff51040 & 0xffe00001 | 0x199a;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_rfoffset_en(void)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51040 = _DAT_3ff51040 & 0xefffffff;
  memw();
  memw();
  _DAT_3ff51020 = _DAT_3ff51020 | 0x180;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_bb_init_cmplx(void)

{
  phy_dis_hw_set_freq();
  ets_delay_us(2);
  memw();
  _DAT_3ff51000 = _DAT_3ff51000 & 0xffffffc3;
  memw();
  memw();
  _DAT_3ff51014 = 0x18021;
  memw();
  _DAT_3ff51044 = _DAT_3ff51044 & 0xffffff00 | 0xa0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51040 = _DAT_3ff51040 & 0xf81fffff | 1;
  memw();
  BT_tx_if_init(0x122,1000,200,1);
  BT_init_rx_filters(0x38);
  memw();
  _DAT_3ff51040 = _DAT_3ff51040 & 0xffe00001 | 0x199a;
  memw();
  memw();
  memw();
  memw();
  _DAT_60032130 = _DAT_60032130 & 0xffff0000 | 0x88e6;
  memw();
  memw();
  memw();
  memw();
  _DAT_600320f4 = _DAT_600320f4 & 0xffffc0ff | 0xa3f;
  memw();
  memw();
  memw();
  memw();
  _DAT_600320f0 = _DAT_600320f0 & 0xfe00fe00 | 0xdc00dc;
  memw();
  memw();
  _DAT_600320dc = _DAT_600320dc & 0xffff7fff;
  memw();
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x0f','\x02','\0','\x01');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x0f','\x03','\x03','\x01');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x06','\x06','\0','n');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x05','\x06','\0','l');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x0f','\x04','\x04','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\v','\x04','\x03','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\b','\x06','\0','\f');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\a','\x06','\0','\n');
  memw();
  _DAT_6000604c = _DAT_6000604c & 0xffff00ff | 0xc800;
  memw();
  phy_en_hw_set_freq();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_bb_init_cmplx_reg(void)

{
  memw();
  _DAT_3ff51000 = _DAT_3ff51000 & 0xffffffc3;
  memw();
  memw();
  _DAT_3ff51014 = 0x18021;
  memw();
  _DAT_3ff51044 = _DAT_3ff51044 & 0xffffff00 | 0xa0;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff51040 = _DAT_3ff51040 & 0xf81fffff | 1;
  memw();
  BT_tx_if_init(0x122,1000,200,1);
  BT_init_rx_filters(0x38);
  memw();
  memw();
  _DAT_3ff51040 = _DAT_3ff51040 & 0xffe00001 | 0x199a;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rw_coex_on(void)

{
  memw();
  memw();
  _DAT_600310d0 = _DAT_600310d0 | 1;
  memw();
  memw();
  _DAT_60031300 = _DAT_60031300 | 1;
  memw();
  memw();
  _DAT_60033d38 = _DAT_60033d38 & 0xffff | 0x10000;
  memw();
  memw();
  memw();
  memw();
  _DAT_60033d30 = _DAT_60033d30 & 0xf00fffff | 0x4400000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void force_bt_mode(void)

{
  memw();
  memw();
  _DAT_600310d0 = _DAT_600310d0 & 0xfffffffe;
  memw();
  memw();
  _DAT_60031300 = _DAT_60031300 & 0xfffffffe;
  memw();
  memw();
  _DAT_3ff5c080 = _DAT_3ff5c080 | 0xc0;
  memw();
  memw();
  memw();
  memw();
  _DAT_60033d30 = _DAT_60033d30 & 0xf00fffff | 0x1100000;
  memw();
  memw();
  _DAT_60033d38 = _DAT_60033d38 & 0xffff0000 | 10;
  memw();
  memw();
  _DAT_60033d40 = _DAT_60033d40 & 0xffffffc7 | 0x10;
  memw();
  memw();
  _DAT_600041c4 = _DAT_600041c4 | 0x40;
  memw();
  memw();
  _DAT_3ff5d040 = _DAT_3ff5d040 & 0x7fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void force_wifi_mode(u32 bt_mux_off)

{
  if (force_wifi_mode_on == 0) {
    if (bt_mux_off != 0) {
      memw();
      _DAT_3ff51098 = _DAT_3ff51098 & 0xfffffffe;
      memw();
    }
    memw();
    _DAT_600310d0 = _DAT_600310d0 & 0xffffff0f;
    memw();
    memw();
    _DAT_60031300 = _DAT_60031300 & 0xffffff0f;
    memw();
    memw();
    _DAT_3ff5c080 = _DAT_3ff5c080 & 0xffffff3f | 0x80;
    memw();
    memw();
    _DAT_600041c4 = _DAT_600041c4 & 0xffffffbf;
    memw();
    phy_force_wifi_chan();
    memw();
    _DAT_3ff5d040 = _DAT_3ff5d040 | 0x80000000;
    memw();
    force_wifi_mode_on = 1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void unforce_wifi_mode(void)

{
  if ((force_wifi_mode_on == 1) &&
     ((memw(), (_DAT_3ff5110c & 0x40000000) == 0 || (memw(), (_DAT_3ff5110c & 0x100000) == 0)))) {
    phy_unforce_wifi_chan();
    memw();
    _DAT_3ff5c080 = _DAT_3ff5c080 & 0xffffff3f;
    memw();
    memw();
    _DAT_600041c4 = _DAT_600041c4 | 0x40;
    memw();
    memw();
    _DAT_3ff5d040 = _DAT_3ff5d040 & 0x7fffffff;
    memw();
    memw();
    _DAT_3ff51098 = _DAT_3ff51098 | 1;
    memw();
    force_wifi_mode_on = 0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void coex_bt_high_prio(void)

{
  memw();
  memw();
  _DAT_3ff5c080 = _DAT_3ff5c080 & 0xffffff3f;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_60033d30 = _DAT_60033d30 & 0xf00fffff | 0x1400001;
  memw();
  memw();
  memw();
  memw();
  _DAT_60033d38 = 0xc80000a;
  memw();
  memw();
  _DAT_60033d40 = _DAT_60033d40 & 0xffffffc7 | 0x10;
  memw();
  memw();
  _DAT_600041c4 = _DAT_600041c4 | 0x40;
  memw();
  memw();
  _DAT_600310d0 = _DAT_600310d0 & 0xffffff0f | 1;
  memw();
  memw();
  _DAT_60031300 = _DAT_60031300 & 0xffffff0f | 1;
  memw();
  memw();
  _DAT_3ff5d040 = _DAT_3ff5d040 & 0x7fffffff;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_rxfilt(void)

{
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x0f','\x02','\0','\x04');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_txfilt(void)

{
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x0f','\x02','\0','\0');
  return;
}



// WARNING: Unknown calling convention

void bt_cmplx_hq_wr(u32 value)

{
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x06','\x06','\0',(uint8)value);
  return;
}



// WARNING: Unknown calling convention

void bt_cmplx_lq_wr(u32 value)

{
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x05','\x06','\0',(uint8)value);
  return;
}



// WARNING: Unknown calling convention

u32 bt_cmplx_hq_re(void)

{
  byte bVar1;
  
  bVar1 = (*g_phyFuns->i2c_readReg_Mask_)('g','\x01','\x06','\x06','\0');
  return (uint)bVar1;
}



// WARNING: Unknown calling convention

u32 bt_cmplx_lq_re(void)

{
  byte bVar1;
  
  bVar1 = (*g_phyFuns->i2c_readReg_Mask_)('g','\x01','\x05','\x06','\0');
  return (uint)bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void pm_wakeup_opt(u32 wakeup_opt,u32 reject_opt)

{
  memw();
  memw();
  _DAT_3ff48038 = (wakeup_opt & 0x7ff) << 0xb | _DAT_3ff48038 & 0xffc007ff;
  memw();
  _DAT_3ff48064 = reject_opt;
  return;
}



// WARNING: Unknown calling convention

u32 get_chip_version(void)

{
  return chip_version;
}



// WARNING: Unknown calling convention

void pm_set_sleep_cycles(u32 sleep_cycles)

{
  longlong lVar1;
  
  lVar1 = rtc_time_get();
  rtc_sleep_set_wakeup_time
            ((int)(lVar1 + (ulonglong)sleep_cycles),(int)(lVar1 + (ulonglong)sleep_cycles >> 0x20));
  periodic_cal_sat = 5000 < sleep_cycles;
  return;
}



// WARNING: Unknown calling convention

void pm_rtc_clock_cali(RTC_clock *RTC)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = rtc_slowck_cali(0,0x80);
  if (uVar1 != 0) {
    uVar2 = RTC->period;
    if (uVar2 != 0) {
      uVar3 = uVar2 - uVar1;
      if (uVar2 < uVar1) {
        uVar3 = uVar1 - uVar2;
      }
      if (0x1ff < uVar3) {
        return;
      }
      uVar1 = uVar2 * 3 + uVar1 * 5 >> 3;
    }
    RTC->period = uVar1;
  }
  return;
}



void pm_prepare_to_sleep(void)

{
  return;
}



undefined4 pm_sdio_nidle(void)

{
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u8 pm_goto_sleep(u32 sleep_mode)

{
  software_slp_reject = '\0';
  SDIO_slp_reject = '\0';
  memw();
  memw();
  _DAT_3ff48048 = _DAT_3ff48048 | 3;
  memw();
  memw();
  _DAT_3ff48018 = _DAT_3ff48018 | 0x80000000;
  do {
    memw();
  } while ((_DAT_3ff48040 & 3) == 0);
  return '\0';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void pm_sleep_set_mac(void)

{
  uint uVar1;
  uint uVar2;
  
  memw();
  memw();
  memw();
  uVar1 = _DAT_60033cb8 & 0x6000;
  uVar2 = _DAT_60033cb8 | 0x8000;
  while (uVar1 != 0) {
    _DAT_60033cb8 = uVar2;
    ets_delay_us(2);
    memw();
    uVar2 = _DAT_60033cb8;
    uVar1 = _DAT_60033cb8 & 0x6000;
  }
  memw();
  _DAT_60033cb8 = uVar2 | 0x5fe0000;
  memw();
  memw();
  if ((uVar2 & 0x6000) == 0) {
    return;
  }
  do {
    ets_delay_us(2);
    memw();
  } while ((_DAT_60033cb8 & 0x6000) != 0);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void pm_mac_deinit(void)

{
  pm_sleep_set_mac();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void pm_set_wakeup_mac(void)

{
  memw();
  memw();
  _DAT_60033cb8 = _DAT_60033cb8 & 0xfa017fff;
  return;
}



// WARNING: Unknown calling convention

bool pm_check_mac_idle(void)

{
  return false;
}



void pm_set_sleep_btco(void)

{
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void pm_set_wakeup_btco(void)

{
  return;
}



// WARNING: Unknown calling convention

void pm_unmask_bt(u8 tw)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void pm_mac_init(void)

{
  memw();
  memw();
  _DAT_60033cb8 = _DAT_60033cb8 & 0xfa017fff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

SW_REJECT_TYPE pm_set_sleep_mode_full(u32 sleep_mode,_func_void_varargs *pmac_save_params)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  
  phy_close_rf();
  pm_sleep_set_mac();
  if (sleep_mode == 0x40) {
    rtc_slp_prep(0,1,1,0,0,0,0,0,0,0,0,0,4,0,0,0);
    return SW_NOREJECT;
  }
  if (sleep_mode < 0x41) {
    if (sleep_mode == 8) {
      uVar2 = 0;
    }
    else {
      if (8 < sleep_mode) {
        if (sleep_mode == 0x10) {
          rtc_slp_prep(0,1,0,0,0,0,0,0,0,0,0,0,4,0,0,0);
          return SW_NOREJECT;
        }
        if (sleep_mode != 0x20) {
          return SW_NOREJECT;
        }
        memw();
        _DAT_3ff48078 = _DAT_3ff48078 & 0xfcffffff;
        memw();
        rtc_slp_prep(0,1,1,0,0,0,0,0,0,0,0,0,4,4,4,4);
        memw();
        _DAT_3ff48000 = _DAT_3ff48000 & 0xfffeffff;
        memw();
        memw();
        uart_div_modify(0,(uint)(_DAT_3ff480b4 << 0x10) / 0x1c200);
        memw();
        memw();
        memw();
        memw();
        goto LAB_0003ff67;
      }
      if (sleep_mode != 4) {
        return SW_NOREJECT;
      }
      uVar2 = 1;
    }
    rtc_slp_prep(0,0,0,0,0,0,0,uVar2,0,0,0,0,4,0,0,0);
  }
  else {
    if (sleep_mode == 0x100) {
      memw();
      memw();
      uVar1 = 1;
      uVar2 = 7;
      uVar3 = 0;
    }
    else {
      if (sleep_mode < 0x101) {
        if (sleep_mode != 0x80) {
          return SW_NOREJECT;
        }
        memw();
        _DAT_3ff48088 = _DAT_3ff48088 | 0x10000000;
        memw();
        ets_delay_us(5);
        memw();
        memw();
        _DAT_3ff48084 = _DAT_3ff48084 | 0x20000;
        return SW_NOREJECT;
      }
      if (sleep_mode == 0x200) {
        memw();
        memw();
        uVar2 = 4;
      }
      else {
        if (sleep_mode != 0x400) {
          return SW_NOREJECT;
        }
        memw();
        memw();
        uVar2 = 7;
      }
      uVar1 = 0;
      uVar3 = 1;
    }
    _DAT_3ff48078 = _DAT_3ff48078 & 0xfcffffff;
    rtc_slp_prep(0,uVar1,uVar1,0,0,0,0,0,uVar3,0,0,0,uVar2,uVar2,uVar2,uVar2);
    memw();
    uart_div_modify(0,(uint)(_DAT_3ff480b4 << 0x10) / 0x1c200);
    memw();
    _DAT_3ff48000 = _DAT_3ff48000 & 0xfffeffff;
    memw();
    memw();
    memw();
    memw();
    memw();
LAB_0003ff67:
    rtc_printf("rom_ram_pd_en:%d\nlslp_mem_force_pu:%d\nslowmem_force_pu:%d\nfastmem_force_pu:%d\n",
               _DAT_3ff48084 >> 0x18 & 0x3f,_DAT_3ff48084 >> 4 & 1,_DAT_3ff48080 >> 0x10 & 1,
               _DAT_3ff48080 >> 0xd & 1);
    ets_delay_us(50000);
  }
  return SW_NOREJECT;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint8 temprature_sens_read(void)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff4884c = _DAT_3ff4884c & 0xfe00ffff | 0x3020000;
  memw();
  ets_delay_us(100);
  memw();
  _DAT_3ff4884c = _DAT_3ff4884c | 0x4000000;
  memw();
  ets_delay_us(2);
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff4884c = _DAT_3ff4884c & 0xf8ffffff;
  return (uint8)((_DAT_3ff48844 & 0x3fc00000) >> 0x16);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void dac_out(uint8 dac_en,u8 tone_en,uint16 dc_value,uint16 tone_scale,uint16 tone_step)

{
  if (tone_en == '\0') {
    memw();
    _DAT_3ff48898 = _DAT_3ff48898 & 0xfffeffff;
    memw();
  }
  else {
    memw();
    memw();
    memw();
    _DAT_3ff48898 = _DAT_3ff48898 & 0xffff0000 | (uint)tone_step | 0x10000;
    memw();
    if ((tone_en & 1) != 0) {
      memw();
      memw();
      memw();
      memw();
      memw();
      memw();
      memw();
      _DAT_3ff4889c =
           (tone_scale & 3) << 0x10 | _DAT_3ff4889c & 0xffccff00 | 0x1000000 | dc_value & 0xff |
           0x200000;
      memw();
      goto LAB_0004029b;
    }
  }
  memw();
  _DAT_3ff4889c = _DAT_3ff4889c & 0xfeffffff;
  memw();
  memw();
  _DAT_3ff48484 = _DAT_3ff48484 & 0xf807ffff | (dc_value & 0xff) << 0x13;
  memw();
LAB_0004029b:
  if ((tone_en & 2) == 0) {
    memw();
    _DAT_3ff4889c = _DAT_3ff4889c & 0xfdffffff;
    memw();
    memw();
    _DAT_3ff48488 = _DAT_3ff48488 & 0xf807ffff | (uint)(dc_value >> 8) << 0x13;
    memw();
  }
  else {
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_3ff4889c =
         (tone_scale >> 8 & 3) << 0x12 | _DAT_3ff4889c & 0xff3300ff | 0x2000000 |
         (uint)(dc_value >> 8) << 8 | 0x800000;
    memw();
  }
  memw();
  if ((dac_en & 1) == 0) {
    _DAT_3ff48484 = _DAT_3ff48484 & 0xfffbfbff;
    memw();
  }
  else {
    memw();
    memw();
    memw();
    memw();
    _DAT_3ff48484 = _DAT_3ff48484 & 0xe7ffffff | 0x60400;
    memw();
  }
  memw();
  if ((dac_en & 2) == 0) {
    memw();
    _DAT_3ff48488 = _DAT_3ff48488 & 0xfffbfbff;
    return;
  }
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48488 = _DAT_3ff48488 & 0xe7ffffff | 0x60400;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void touch_init(uint16 pad_en)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48490 = _DAT_3ff48490 & 0xe7ffffff | 0x66000000;
  memw();
  memw();
  _DAT_3ff48884 = _DAT_3ff48884 & 0xffbfffff;
  memw();
  memw();
  _DAT_3ff4888c = _DAT_3ff4888c & 0xfffffc00 | pad_en & 0x3ff;
  if ((pad_en & 1) != 0) {
    memw();
    _DAT_3ff48494 = _DAT_3ff48494 & 0xe007ffff | 0x3f80000;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void touch_read(uint16 *pad_out,uint16 sample_num)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  
  memw();
  memw();
  memw();
  _DAT_3ff48858 = _DAT_3ff48858 & 0xff000000 | (uint)sample_num | 0xa0000;
  memw();
  memw();
  memw();
  do {
    memw();
  } while ((_DAT_3ff48884 & 0x400) == 0);
  uVar1 = 0;
  iVar3 = 0x10;
  while( true ) {
    memw();
    uVar2 = uVar1 + 1;
    *pad_out = (uint16)(*(uint *)(((uVar1 >> 1) + 0xffd221c) * 4) >> iVar3);
    uVar1 = uVar2 & 0xff;
    if (uVar1 == 10) break;
    iVar3 = 0;
    if ((uVar2 & 1) == 0) {
      iVar3 = 0x10;
    }
    pad_out = pad_out + 1;
  }
  memw();
  memw();
  _DAT_3ff48884 = _DAT_3ff48884 & 0xffffcfff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void vdd33_init(void)

{
  memw();
  memw();
  memw();
  _DAT_3ff460c0 = _DAT_3ff460c0 | 0x80;
  memw();
  memw();
  _DAT_3ff4882c = _DAT_3ff4882c & 0xffffff1f | 0xc;
  memw();
  memw();
  _DAT_3ff4e050 = _DAT_3ff4e050 | 0xc0;
  memw();
  (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\t','\x02','\0','\0');
  memw();
  memw();
  _DAT_3ff48890 = _DAT_3ff48890 | 0x8000000;
  memw();
  memw();
  _DAT_3ff48030 = _DAT_3ff48030 | 0x8000000;
  memw();
  memw();
  _DAT_3ff4880c = _DAT_3ff4880c | 0xc0000;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff4e05c = _DAT_3ff4e05c & 0xffdfffff | 0x800000;
  memw();
  memw();
  _DAT_3ff48894 = _DAT_3ff48894 & 0x8007ffff;
  memw();
  memw();
  _DAT_3ff48838 = _DAT_3ff48838 & 0x3fffffff;
  memw();
  memw();
  _DAT_3ff66010 = _DAT_3ff66010 & 0xfffffffb;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint16 get_vdd33(void)

{
  uint uVar1;
  
  (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\t','\a','\a','\x01');
  memw();
  _DAT_3ff4882c = _DAT_3ff4882c | 0x10;
  memw();
  memw();
  _DAT_3ff4e05c = _DAT_3ff4e05c | 0x800000;
  memw();
  do {
    memw();
  } while ((_DAT_3ff4e050 >> 0x18 & 7) != 0);
  memw();
  memw();
  memw();
  _DAT_3ff4e050 = _DAT_3ff4e050 & 0xfffffffd | 2;
  memw();
  ets_delay_us(10);
  do {
    memw();
  } while ((_DAT_3ff4e050 >> 0x18 & 7) != 0);
  memw();
  uVar1 = _DAT_3ff4e080 & 0xfff;
  (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\t','\a','\a','\0');
  memw();
  memw();
  _DAT_3ff4882c = _DAT_3ff4882c & 0xffffffef;
  memw();
  memw();
  _DAT_3ff4e05c = _DAT_3ff4e05c & 0xff7fffff;
  return 0xfff - (short)(uVar1 + 4 >> 3);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint16 adc1_read_test(uint8 pad,uint8 atten,uint16 pad_en_wait)

{
  uint uVar1;
  
  memw();
  memw();
  _DAT_3ff4882c = _DAT_3ff4882c | 0xf;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48800 = _DAT_3ff48800 | 0x10030000;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48834 =
       (3 << 0x20 - (0x20 - ((uint)pad << 1 & 0x1f)) ^ 0xffffffffU) & _DAT_3ff48834 |
       (atten & 3) << 0x20 - (0x20 - ((uint)pad << 1 & 0x1f));
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff488a0 = _DAT_3ff488a0 & 0xfffffff0;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48810 = _DAT_3ff48810 & 0xffff0000;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48808 = pad_en_wait | 0x10000;
  memw();
  memw();
  _DAT_3ff4880c = _DAT_3ff4880c & 0xfffc0000 | 0x20001;
  memw();
  memw();
  do {
    memw();
  } while ((_DAT_3ff4883c >> 0x16 & 7) != 0);
  memw();
  uVar1 = _DAT_3ff48854 & 0x8005ffff;
  memw();
  memw();
  memw();
  do {
    memw();
  } while ((_DAT_3ff48854 & 0x10000) == 0);
  memw();
  memw();
  memw();
  _DAT_3ff48854 = uVar1 | 0x80060000;
  return (uint16)uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint16 adc1_amp_read_full(uint8 pad,uint8 atten,uint16 stg1,uint16 stg2,uint16 stg3)

{
  uint16 uVar1;
  uint uVar2;
  
  memw();
  _DAT_3ff4882c = _DAT_3ff4882c | 0xf;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48800 = _DAT_3ff48800 | 0x10030000;
  memw();
  uVar2 = (uint)pad << 1;
  memw();
  _DAT_3ff48834 =
       (3 << 0x20 - (0x20 - (uVar2 & 0x1f)) ^ 0xffffffffU) & _DAT_3ff48834 |
       (atten & 3) << 0x20 - (0x20 - (uVar2 & 0x1f));
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48810 = _DAT_3ff48810 & 0xff0f000f | 0x3f038f;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48808 = CONCAT22(stg2,stg1);
  memw();
  memw();
  _DAT_3ff4880c = _DAT_3ff4880c & 0xffff0000 | (uint)stg3;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  uVar2 = _DAT_3ff48854 & 0x10000;
  _DAT_3ff48854 =
       (1 << 0x20 - (0x20 - (pad & 0x1f)) & 0xfffU) << 0x13 | _DAT_3ff48854 & 0x8005ffff | 0x40000 |
       0x80020000;
  while (uVar2 == 0) {
    ets_delay_us(1);
    memw();
    uVar2 = _DAT_3ff48854 & 0x10000;
  }
  memw();
  memw();
  uVar1 = (uint16)_DAT_3ff48854;
  memw();
  _DAT_3ff48854 = _DAT_3ff48854 & 0xfffbffff;
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint16 hall_sens_read_full(void)

{
  uint16 uVar1;
  uint16 uVar2;
  uint16 uVar3;
  uint16 uVar4;
  u16 Sens_Vp0;
  u16 Sens_Vn0;
  
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48858 = _DAT_3ff48858 | 0xc000000;
  memw();
  memw();
  _DAT_3ff48478 = _DAT_3ff48478 & 0xbfffffff | 0x80000000;
  memw();
  ets_delay_us(100);
  uVar1 = adc1_read_test('\0','\0',2);
  uVar2 = adc1_read_test('\x03','\0',2);
  memw();
  _DAT_3ff48478 = _DAT_3ff48478 | 0x40000000;
  memw();
  uVar3 = adc1_read_test('\0','\0',2);
  uVar4 = adc1_read_test('\x03','\0',2);
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48858 = _DAT_3ff48858 & 0xf3ffffff;
  return ((uVar1 + uVar4) - uVar3) - uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint16 hall_sens_amp_read_full(uint16 stg1,uint16 stg2,uint16 stg3)

{
  uint16 uVar1;
  uint16 uVar2;
  u16 Sens_Vp0;
  
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48858 = _DAT_3ff48858 | 0xc000000;
  memw();
  memw();
  _DAT_3ff48478 = _DAT_3ff48478 & 0xbfffffff | 0x80000000;
  memw();
  ets_delay_us(100);
  uVar1 = adc1_amp_read_full('\0','\0',stg1,stg2,stg3);
  memw();
  _DAT_3ff48478 = _DAT_3ff48478 | 0x40000000;
  memw();
  uVar2 = adc1_amp_read_full('\0','\0',stg1,stg2,stg3);
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48858 = _DAT_3ff48858 & 0xf3ffffff;
  return uVar1 - uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint16 adc2_read_test(uint8 pad,uint8 atten)

{
  uint uVar1;
  
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff4882c = _DAT_3ff4882c & 0xffffff1f | 0xf;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48838 =
       (3 << 0x20 - (0x20 - ((uint)pad << 1 & 0x1f)) ^ 0xffffffffU) & _DAT_3ff48838 |
       (atten & 3) << 0x20 - (0x20 - ((uint)pad << 1 & 0x1f));
  memw();
  memw();
  do {
    memw();
  } while ((_DAT_3ff4e050 >> 0x18 & 7) != 0);
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  do {
    memw();
  } while ((_DAT_3ff4883c & 0xe000000) != 0);
  memw();
  uVar1 = _DAT_3ff48894 & 0x8005ffff;
  memw();
  memw();
  memw();
  do {
    memw();
  } while ((_DAT_3ff48894 & 0x10000) == 0);
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48894 = uVar1 | 0x80040000;
  memw();
  memw();
  _DAT_3ff4e050 = _DAT_3ff4e050 & 0xfffffffe | 1;
  memw();
  memw();
  _DAT_3ff48890 = _DAT_3ff48890 & 0xf7ffffff | 0x28030000;
  return (uint16)uVar1;
}



// WARNING: Unknown calling convention

void adc1_pad_init(u8 pad_en)

{
  u32 rtc_pad_musk;
  u32 mask;
  
  mask = 0;
  if (pad_en < 8) {
    mask = *(u32 *)(CSWTCH_18 + (uint)pad_en * 4);
  }
  rtc_pads_muxsel(mask,1);
  rtc_pads_pu(mask,0);
  rtc_pads_pd(mask,0);
  rtc_pads_funie(mask,0);
  rtc_pads_slpie(mask,0);
  rtc_pads_slpoe(mask,0);
  return;
}



// WARNING: Unknown calling convention

uint16 adc1_read(uint8 pad,uint8 atten)

{
  uint16 uVar1;
  
  adc1_pad_init(pad);
  uVar1 = adc1_read_test(pad,atten,2);
  return uVar1;
}



// WARNING: Unknown calling convention

uint16 adc1_amp_read(void)

{
  uint16 uVar1;
  
  adc1_pad_init('\0');
  uVar1 = adc1_amp_read_full('\0','\0',0x400,1,4);
  return uVar1;
}



// WARNING: Unknown calling convention

uint16 hall_sens_read(void)

{
  uint16 uVar1;
  
  adc1_pad_init('\0');
  adc1_pad_init('\x03');
  uVar1 = hall_sens_read_full();
  return uVar1;
}



// WARNING: Unknown calling convention

uint16 hall_sens_amp_read(void)

{
  uint16 uVar1;
  
  adc1_pad_init('\0');
  uVar1 = hall_sens_amp_read_full(1000,1,100);
  return uVar1;
}



// WARNING: Unknown calling convention

void adc2_pad_init(u8 pad_en)

{
  u32 rtc_pad_musk;
  u32 mask;
  
  mask = 0;
  if (pad_en < 10) {
    mask = *(u32 *)(CSWTCH_24 + (uint)pad_en * 4);
  }
  rtc_pads_muxsel(mask,1);
  rtc_pads_pu(mask,0);
  rtc_pads_pd(mask,0);
  rtc_pads_funie(mask,0);
  rtc_pads_slpie(mask,0);
  rtc_pads_slpoe(mask,0);
  return;
}



// WARNING: Unknown calling convention

uint16 adc2_read(uint8 pad,uint8 atten)

{
  uint16 uVar1;
  
  adc2_pad_init(pad);
  uVar1 = adc2_read_test(pad,atten);
  return uVar1;
}



// WARNING: Unknown calling convention

void adc_pad_int(u8 adc_num,u32 adc1_channel,u32 adc2_channel)

{
  u32 mask;
  
  mask = 0;
  if ((adc_num & 1) != 0) {
    mask = adc1_channel & 1;
    if ((adc1_channel & 2) != 0) {
      mask = 2;
    }
    if ((adc1_channel & 4) != 0) {
      mask = 4;
    }
    if ((adc1_channel & 8) != 0) {
      mask = 8;
    }
    if ((adc1_channel & 0x10) != 0) {
      mask = 0x200;
    }
    if ((adc1_channel & 0x20) != 0) {
      mask = 0x100;
    }
    if ((adc1_channel >> 6 & 1) != 0) {
      mask = 0x10;
    }
    if ((adc1_channel >> 7 & 1) != 0) {
      mask = 0x20;
    }
  }
  if ((adc_num & 2) != 0) {
    if ((adc2_channel & 1) != 0) {
      mask = 0x400;
    }
    if ((adc2_channel >> 1 & 1) != 0) {
      mask = 0x800;
    }
    if ((adc2_channel >> 2 & 1) != 0) {
      mask = 0x1000;
    }
    if ((adc2_channel >> 3 & 1) != 0) {
      mask = 0x2000;
    }
    if ((adc2_channel >> 4 & 1) != 0) {
      mask = 0x4000;
    }
    if ((adc2_channel >> 5 & 1) != 0) {
      mask = 0x8000;
    }
    if ((adc2_channel & 0x40) != 0) {
      mask = 0x10000;
    }
    if ((adc2_channel & 0x80) != 0) {
      mask = 0x20000;
    }
    if ((adc2_channel >> 8 & 1) != 0) {
      mask = 0x40;
    }
    if ((adc2_channel >> 9 & 1) != 0) {
      mask = 0x80;
    }
  }
  rtc_pads_pu(mask,0);
  rtc_pads_pd(mask,0);
  rtc_pads_funie(mask,0);
  rtc_pads_slpie(mask,0);
  rtc_pads_slpoe(mask,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void adc_pad_init(u32 pad)

{
  if ((pad & 1) != 0) {
    memw();
    memw();
    memw();
    _DAT_3ff4847c = _DAT_3ff4847c & 0xfff7ffff | 0x8000000;
    memw();
  }
  if ((pad & 2) != 0) {
    memw();
    memw();
    memw();
    _DAT_3ff4847c = _DAT_3ff4847c & 0xffffbfff | 0x4000000;
    memw();
  }
  if ((pad & 4) != 0) {
    memw();
    memw();
    memw();
    _DAT_3ff4847c = _DAT_3ff4847c & 0xfffffdff | 0x2000000;
    memw();
  }
  if ((pad & 8) != 0) {
    memw();
    memw();
    memw();
    _DAT_3ff4847c = _DAT_3ff4847c & 0xffffffef | 0x1000000;
    memw();
  }
  if ((pad & 0x10) != 0) {
    memw();
    memw();
    memw();
    _DAT_3ff4848c = _DAT_3ff4848c & 0xff3fffdf | 0x20000;
    memw();
  }
  if ((pad & 0x20) != 0) {
    memw();
    memw();
    memw();
    _DAT_3ff4848c = _DAT_3ff4848c & 0xe7fff7ff | 0x40000;
    memw();
  }
  if ((pad & 0x40) != 0) {
    memw();
    memw();
    memw();
    _DAT_3ff48480 = _DAT_3ff48480 & 0xff7fffff | 0x20000000;
    memw();
  }
  if ((pad & 0x80) != 0) {
    memw();
    memw();
    memw();
    _DAT_3ff48480 = _DAT_3ff48480 & 0xfffbffff | 0x10000000;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void dac_pad_init(u8 dac_pad,uint8 dac_val)

{
  memw();
  memw();
  _DAT_3ff4889c = _DAT_3ff4889c & 0xfcffffff;
  memw();
  memw();
  _DAT_3ff48898 = _DAT_3ff48898 | 0x10000;
  if ((dac_pad & 1) != 0) {
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_3ff48484 = _DAT_3ff48484 & 0xe007ffff | 0x20000 | (uint)dac_val << 0x13;
    memw();
  }
  if ((dac_pad & 2) != 0) {
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_3ff48488 = _DAT_3ff48488 & 0xe007ffff | 0x20000 | (uint)dac_val << 0x13;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_cmd_wakeup_conf(void)

{
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48830 = _DAT_3ff48830 & 0xffc00000 | 0x8118;
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff4882c = _DAT_3ff4882c & 0xfffffdff | 0x300;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pads_muxsel(u32 mask,u32 value)

{
  if ((mask & 1) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x1b | _DAT_3ff4847c & 0xf7ffffff;
    memw();
  }
  if ((mask & 2) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x1a | _DAT_3ff4847c & 0xfbffffff;
    memw();
  }
  if ((mask & 4) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x19 | _DAT_3ff4847c & 0xfdffffff;
    memw();
  }
  if ((mask & 8) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x18 | _DAT_3ff4847c & 0xfeffffff;
    memw();
  }
  if ((mask & 0x10) != 0) {
    memw();
    _DAT_3ff48480 = (value & 1) << 0x1d | _DAT_3ff48480 & 0xdfffffff;
    memw();
  }
  if ((mask & 0x20) != 0) {
    memw();
    _DAT_3ff48480 = (value & 1) << 0x1c | _DAT_3ff48480 & 0xefffffff;
    memw();
  }
  if ((mask & 0x40) != 0) {
    memw();
    _DAT_3ff48484 = (value & 1) << 0x11 | _DAT_3ff48484 & 0xfffdffff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    memw();
    _DAT_3ff48488 = (value & 1) << 0x11 | _DAT_3ff48488 & 0xfffdffff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0x12 | _DAT_3ff4848c & 0xfffbffff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0x11 | _DAT_3ff4848c & 0xfffdffff;
    memw();
  }
  if ((mask & 0x400) != 0) {
    memw();
    _DAT_3ff48494 = (value & 1) << 0x13 | _DAT_3ff48494 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x800) != 0) {
    memw();
    _DAT_3ff48498 = (value & 1) << 0x13 | _DAT_3ff48498 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    memw();
    _DAT_3ff4849c = (value & 1) << 0x13 | _DAT_3ff4849c & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    memw();
    _DAT_3ff484a0 = (value & 1) << 0x13 | _DAT_3ff484a0 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    memw();
    _DAT_3ff484a4 = (value & 1) << 0x13 | _DAT_3ff484a4 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    memw();
    _DAT_3ff484a8 = (value & 1) << 0x13 | _DAT_3ff484a8 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    memw();
    _DAT_3ff484ac = (value & 1) << 0x13 | _DAT_3ff484ac & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    memw();
    _DAT_3ff484b0 = (value & 1) << 0x13 | _DAT_3ff484b0 & 0xfff7ffff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pads_funsel(u32 mask,u32 value)

{
  if ((mask & 1) != 0) {
    memw();
    _DAT_3ff4847c = (value & 3) << 0x16 | _DAT_3ff4847c & 0xff3fffff;
    memw();
  }
  if ((mask & 2) != 0) {
    memw();
    _DAT_3ff4847c = (value & 3) << 0x11 | _DAT_3ff4847c & 0xfff9ffff;
    memw();
  }
  if ((mask & 4) != 0) {
    memw();
    _DAT_3ff4847c = (value & 3) << 0xc | _DAT_3ff4847c & 0xffffcfff;
    memw();
  }
  if ((mask & 8) != 0) {
    memw();
    _DAT_3ff4847c = (value & 3) << 7 | _DAT_3ff4847c & 0xfffffe7f;
    memw();
  }
  if ((mask & 0x10) != 0) {
    memw();
    _DAT_3ff48480 = (value & 3) << 0x1a | _DAT_3ff48480 & 0xf3ffffff;
    memw();
  }
  if ((mask & 0x20) != 0) {
    memw();
    _DAT_3ff48480 = (value & 3) << 0x15 | _DAT_3ff48480 & 0xff9fffff;
    memw();
  }
  if ((mask & 0x40) != 0) {
    memw();
    _DAT_3ff48484 = (value & 3) << 0xf | _DAT_3ff48484 & 0xfffe7fff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    memw();
    _DAT_3ff48488 = (value & 3) << 0xf | _DAT_3ff48488 & 0xfffe7fff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    memw();
    _DAT_3ff4848c = (value & 3) << 0xf | _DAT_3ff4848c & 0xfffe7fff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    memw();
    _DAT_3ff4848c = (value & 3) << 9 | _DAT_3ff4848c & 0xfffff9ff;
    memw();
  }
  if ((mask & 0x400) != 0) {
    memw();
    _DAT_3ff48494 = (value & 3) << 0x11 | _DAT_3ff48494 & 0xfff9ffff;
    memw();
  }
  if ((mask & 0x800) != 0) {
    memw();
    _DAT_3ff48498 = (value & 3) << 0x11 | _DAT_3ff48498 & 0xfff9ffff;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    memw();
    _DAT_3ff4849c = (value & 3) << 0x11 | _DAT_3ff4849c & 0xfff9ffff;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    memw();
    _DAT_3ff484a0 = (value & 3) << 0x11 | _DAT_3ff484a0 & 0xfff9ffff;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    memw();
    _DAT_3ff484a4 = (value & 3) << 0x11 | _DAT_3ff484a4 & 0xfff9ffff;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    memw();
    _DAT_3ff484a8 = (value & 3) << 0x11 | _DAT_3ff484a8 & 0xfff9ffff;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    memw();
    _DAT_3ff484ac = (value & 3) << 0x11 | _DAT_3ff484ac & 0xfff9ffff;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    memw();
    _DAT_3ff484b0 = (value & 3) << 0x11 | _DAT_3ff484b0 & 0xfff9ffff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pads_slpsel(u32 mask,u32 value)

{
  if ((mask & 1) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x15 | _DAT_3ff4847c & 0xffdfffff;
    memw();
  }
  if ((mask & 2) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x10 | _DAT_3ff4847c & 0xfffeffff;
    memw();
  }
  if ((mask & 4) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0xb | _DAT_3ff4847c & 0xfffff7ff;
    memw();
  }
  if ((mask & 8) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 6 | _DAT_3ff4847c & 0xffffffbf;
    memw();
  }
  if ((mask & 0x10) != 0) {
    memw();
    _DAT_3ff48480 = (value & 1) << 0x19 | _DAT_3ff48480 & 0xfdffffff;
    memw();
  }
  if ((mask & 0x20) != 0) {
    memw();
    _DAT_3ff48480 = (value & 1) << 0x14 | _DAT_3ff48480 & 0xffefffff;
    memw();
  }
  if ((mask & 0x40) != 0) {
    memw();
    _DAT_3ff48484 = (value & 1) << 0xe | _DAT_3ff48484 & 0xffffbfff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    memw();
    _DAT_3ff48488 = (value & 1) << 0xe | _DAT_3ff48488 & 0xffffbfff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0xe | _DAT_3ff4848c & 0xffffbfff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 8 | _DAT_3ff4848c & 0xfffffeff;
    memw();
  }
  if ((mask & 0x400) != 0) {
    memw();
    _DAT_3ff48494 = (value & 1) << 0x10 | _DAT_3ff48494 & 0xfffeffff;
    memw();
  }
  if ((mask & 0x800) != 0) {
    memw();
    _DAT_3ff48498 = (value & 1) << 0x10 | _DAT_3ff48498 & 0xfffeffff;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    memw();
    _DAT_3ff4849c = (value & 1) << 0x10 | _DAT_3ff4849c & 0xfffeffff;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    memw();
    _DAT_3ff484a0 = (value & 1) << 0x10 | _DAT_3ff484a0 & 0xfffeffff;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    memw();
    _DAT_3ff484a4 = (value & 1) << 0x10 | _DAT_3ff484a4 & 0xfffeffff;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    memw();
    _DAT_3ff484a8 = (value & 1) << 0x10 | _DAT_3ff484a8 & 0xfffeffff;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    memw();
    _DAT_3ff484ac = (value & 1) << 0x10 | _DAT_3ff484ac & 0xfffeffff;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    memw();
    _DAT_3ff484b0 = (value & 1) << 0x10 | _DAT_3ff484b0 & 0xfffeffff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pads_slpoe(u32 mask,u32 value)

{
  if ((mask & 0x40) != 0) {
    memw();
    _DAT_3ff48484 = (value & 1) << 0xc | _DAT_3ff48484 & 0xffffefff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    memw();
    _DAT_3ff48488 = (value & 1) << 0xc | _DAT_3ff48488 & 0xffffefff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0xc | _DAT_3ff4848c & 0xffffefff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 6 | _DAT_3ff4848c & 0xffffffbf;
    memw();
  }
  if ((mask & 0x400) != 0) {
    memw();
    _DAT_3ff48494 = (value & 1) << 0xe | _DAT_3ff48494 & 0xffffbfff;
    memw();
  }
  if ((mask & 0x800) != 0) {
    memw();
    _DAT_3ff48498 = (value & 1) << 0xe | _DAT_3ff48498 & 0xffffbfff;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    memw();
    _DAT_3ff4849c = (value & 1) << 0xe | _DAT_3ff4849c & 0xffffbfff;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    memw();
    _DAT_3ff484a0 = (value & 1) << 0xe | _DAT_3ff484a0 & 0xffffbfff;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    memw();
    _DAT_3ff484a4 = (value & 1) << 0xe | _DAT_3ff484a4 & 0xffffbfff;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    memw();
    _DAT_3ff484a8 = (value & 1) << 0xe | _DAT_3ff484a8 & 0xffffbfff;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    memw();
    _DAT_3ff484ac = (value & 1) << 0xe | _DAT_3ff484ac & 0xffffbfff;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    memw();
    _DAT_3ff484b0 = (value & 1) << 0xe | _DAT_3ff484b0 & 0xffffbfff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pads_slpie(u32 mask,u32 value)

{
  if ((mask & 1) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x14 | _DAT_3ff4847c & 0xffefffff;
    memw();
  }
  if ((mask & 2) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0xf | _DAT_3ff4847c & 0xffff7fff;
    memw();
  }
  if ((mask & 4) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 10 | _DAT_3ff4847c & 0xfffffbff;
    memw();
  }
  if ((mask & 8) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 5 | _DAT_3ff4847c & 0xffffffdf;
    memw();
  }
  if ((mask & 0x10) != 0) {
    memw();
    _DAT_3ff48480 = (value & 1) << 0x18 | _DAT_3ff48480 & 0xfeffffff;
    memw();
  }
  if ((mask & 0x20) != 0) {
    memw();
    _DAT_3ff48480 = (value & 1) << 0x13 | _DAT_3ff48480 & 0xfff7ffff;
    memw();
  }
  if ((mask & 0x40) != 0) {
    memw();
    _DAT_3ff48484 = (value & 1) << 0xd | _DAT_3ff48484 & 0xffffdfff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    memw();
    _DAT_3ff48488 = (value & 1) << 0xd | _DAT_3ff48488 & 0xffffdfff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0xd | _DAT_3ff4848c & 0xffffdfff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 7 | _DAT_3ff4848c & 0xffffff7f;
    memw();
  }
  if ((mask & 0x400) != 0) {
    memw();
    _DAT_3ff48494 = (value & 1) << 0xf | _DAT_3ff48494 & 0xffff7fff;
    memw();
  }
  if ((mask & 0x800) != 0) {
    memw();
    _DAT_3ff48498 = (value & 1) << 0xf | _DAT_3ff48498 & 0xffff7fff;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    memw();
    _DAT_3ff4849c = (value & 1) << 0xf | _DAT_3ff4849c & 0xffff7fff;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    memw();
    _DAT_3ff484a0 = (value & 1) << 0xf | _DAT_3ff484a0 & 0xffff7fff;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    memw();
    _DAT_3ff484a4 = (value & 1) << 0xf | _DAT_3ff484a4 & 0xffff7fff;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    memw();
    _DAT_3ff484a8 = (value & 1) << 0xf | _DAT_3ff484a8 & 0xffff7fff;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    memw();
    _DAT_3ff484ac = (value & 1) << 0xf | _DAT_3ff484ac & 0xffff7fff;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    memw();
    _DAT_3ff484b0 = (value & 1) << 0xf | _DAT_3ff484b0 & 0xffff7fff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pads_funie(u32 mask,u32 value)

{
  if ((mask & 1) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x13 | _DAT_3ff4847c & 0xfff7ffff;
    memw();
  }
  if ((mask & 2) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0xe | _DAT_3ff4847c & 0xffffbfff;
    memw();
  }
  if ((mask & 4) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 9 | _DAT_3ff4847c & 0xfffffdff;
    memw();
  }
  if ((mask & 8) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 4 | _DAT_3ff4847c & 0xffffffef;
    memw();
  }
  if ((mask & 0x10) != 0) {
    memw();
    _DAT_3ff48480 = (value & 1) << 0x17 | _DAT_3ff48480 & 0xff7fffff;
    memw();
  }
  if ((mask & 0x20) != 0) {
    memw();
    _DAT_3ff48480 = (value & 1) << 0x12 | _DAT_3ff48480 & 0xfffbffff;
    memw();
  }
  if ((mask & 0x40) != 0) {
    memw();
    _DAT_3ff48484 = (value & 1) << 0xb | _DAT_3ff48484 & 0xfffff7ff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    memw();
    _DAT_3ff48488 = (value & 1) << 0xb | _DAT_3ff48488 & 0xfffff7ff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0xb | _DAT_3ff4848c & 0xfffff7ff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 5 | _DAT_3ff4848c & 0xffffffdf;
    memw();
  }
  if ((mask & 0x400) != 0) {
    memw();
    _DAT_3ff48494 = (value & 1) << 0xd | _DAT_3ff48494 & 0xffffdfff;
    memw();
  }
  if ((mask & 0x800) != 0) {
    memw();
    _DAT_3ff48498 = (value & 1) << 0xd | _DAT_3ff48498 & 0xffffdfff;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    memw();
    _DAT_3ff4849c = (value & 1) << 0xd | _DAT_3ff4849c & 0xffffdfff;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    memw();
    _DAT_3ff484a0 = (value & 1) << 0xd | _DAT_3ff484a0 & 0xffffdfff;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    memw();
    _DAT_3ff484a4 = (value & 1) << 0xd | _DAT_3ff484a4 & 0xffffdfff;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    memw();
    _DAT_3ff484a8 = (value & 1) << 0xd | _DAT_3ff484a8 & 0xffffdfff;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    memw();
    _DAT_3ff484ac = (value & 1) << 0xd | _DAT_3ff484ac & 0xffffdfff;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    memw();
    _DAT_3ff484b0 = (value & 1) << 0xd | _DAT_3ff484b0 & 0xffffdfff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pads_pu(u32 mask,u32 value)

{
  if ((mask & 0x40) != 0) {
    memw();
    _DAT_3ff48484 = (value & 1) << 0x1b | _DAT_3ff48484 & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    memw();
    _DAT_3ff48488 = (value & 1) << 0x1b | _DAT_3ff48488 & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0x1b | _DAT_3ff4848c & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0x16 | _DAT_3ff4848c & 0xffbfffff;
    memw();
  }
  if ((mask & 0x400) != 0) {
    memw();
    _DAT_3ff48494 = (value & 1) << 0x1b | _DAT_3ff48494 & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x800) != 0) {
    memw();
    _DAT_3ff48498 = (value & 1) << 0x1b | _DAT_3ff48498 & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    memw();
    _DAT_3ff4849c = (value & 1) << 0x1b | _DAT_3ff4849c & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    memw();
    _DAT_3ff484a0 = (value & 1) << 0x1b | _DAT_3ff484a0 & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    memw();
    _DAT_3ff484a4 = (value & 1) << 0x1b | _DAT_3ff484a4 & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    memw();
    _DAT_3ff484a8 = (value & 1) << 0x1b | _DAT_3ff484a8 & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    memw();
    _DAT_3ff484ac = (value & 1) << 0x1b | _DAT_3ff484ac & 0xf7ffffff;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    memw();
    _DAT_3ff484b0 = (value & 1) << 0x1b | _DAT_3ff484b0 & 0xf7ffffff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pads_pd(u32 mask,u32 value)

{
  if ((mask & 0x40) != 0) {
    memw();
    _DAT_3ff48484 = (value & 1) << 0x1c | _DAT_3ff48484 & 0xefffffff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    memw();
    _DAT_3ff48488 = (value & 1) << 0x1c | _DAT_3ff48488 & 0xefffffff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0x1c | _DAT_3ff4848c & 0xefffffff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0x17 | _DAT_3ff4848c & 0xff7fffff;
    memw();
  }
  if ((mask & 0x400) != 0) {
    memw();
    _DAT_3ff48494 = (value & 1) << 0x1c | _DAT_3ff48494 & 0xefffffff;
    memw();
  }
  if ((mask & 0x800) != 0) {
    memw();
    _DAT_3ff48498 = (value & 1) << 0x1c | _DAT_3ff48498 & 0xefffffff;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    memw();
    _DAT_3ff4849c = (value & 1) << 0x1c | _DAT_3ff4849c & 0xefffffff;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    memw();
    _DAT_3ff484a0 = (value & 1) << 0x1c | _DAT_3ff484a0 & 0xefffffff;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    memw();
    _DAT_3ff484a4 = (value & 1) << 0x1c | _DAT_3ff484a4 & 0xefffffff;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    memw();
    _DAT_3ff484a8 = (value & 1) << 0x1c | _DAT_3ff484a8 & 0xefffffff;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    memw();
    _DAT_3ff484ac = (value & 1) << 0x1c | _DAT_3ff484ac & 0xefffffff;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    memw();
    _DAT_3ff484b0 = (value & 1) << 0x1c | _DAT_3ff484b0 & 0xefffffff;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pads_hold(u32 mask,u32 value)

{
  if ((mask & 1) != 0) {
    memw();
    _DAT_3ff4847c = _DAT_3ff4847c & 0x7fffffff | value << 0x1f;
    memw();
  }
  if ((mask & 2) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x1e | _DAT_3ff4847c & 0xbfffffff;
    memw();
  }
  if ((mask & 4) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x1d | _DAT_3ff4847c & 0xdfffffff;
    memw();
  }
  if ((mask & 8) != 0) {
    memw();
    _DAT_3ff4847c = (value & 1) << 0x1c | _DAT_3ff4847c & 0xefffffff;
    memw();
  }
  if ((mask & 0x10) != 0) {
    memw();
    _DAT_3ff48480 = _DAT_3ff48480 & 0x7fffffff | value << 0x1f;
    memw();
  }
  if ((mask & 0x20) != 0) {
    memw();
    _DAT_3ff48480 = (value & 1) << 0x1e | _DAT_3ff48480 & 0xbfffffff;
    memw();
  }
  if ((mask & 0x40) != 0) {
    memw();
    _DAT_3ff48484 = (value & 1) << 0x1d | _DAT_3ff48484 & 0xdfffffff;
    memw();
  }
  if ((mask & 0x80) != 0) {
    memw();
    _DAT_3ff48488 = (value & 1) << 0x1d | _DAT_3ff48488 & 0xdfffffff;
    memw();
  }
  if ((mask & 0x100) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0x1d | _DAT_3ff4848c & 0xdfffffff;
    memw();
  }
  if ((mask & 0x200) != 0) {
    memw();
    _DAT_3ff4848c = (value & 1) << 0x18 | _DAT_3ff4848c & 0xfeffffff;
    memw();
  }
  if ((mask & 0x400) != 0) {
    memw();
    _DAT_3ff48494 = _DAT_3ff48494 & 0x7fffffff | value << 0x1f;
    memw();
  }
  if ((mask & 0x800) != 0) {
    memw();
    _DAT_3ff48498 = _DAT_3ff48498 & 0x7fffffff | value << 0x1f;
    memw();
  }
  if ((mask & 0x1000) != 0) {
    memw();
    _DAT_3ff4849c = _DAT_3ff4849c & 0x7fffffff | value << 0x1f;
    memw();
  }
  if ((mask & 0x2000) != 0) {
    memw();
    _DAT_3ff484a0 = _DAT_3ff484a0 & 0x7fffffff | value << 0x1f;
    memw();
  }
  if ((mask & 0x4000) != 0) {
    memw();
    _DAT_3ff484a4 = _DAT_3ff484a4 & 0x7fffffff | value << 0x1f;
    memw();
  }
  if ((mask & 0x8000) != 0) {
    memw();
    _DAT_3ff484a8 = _DAT_3ff484a8 & 0x7fffffff | value << 0x1f;
    memw();
  }
  if ((mask & 0x10000) != 0) {
    memw();
    _DAT_3ff484ac = _DAT_3ff484ac & 0x7fffffff | value << 0x1f;
    memw();
  }
  if ((mask & 0x20000) != 0) {
    memw();
    _DAT_3ff484b0 = _DAT_3ff484b0 & 0x7fffffff | value << 0x1f;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_apbbridge_sel(u32 sel)

{
  memw();
  memw();
  _DAT_3ff48018 = (sel & 1) << 0x16 | _DAT_3ff48018 & 0xffbfffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_powerup_rf(void)

{
  memw();
  memw();
  _DAT_3ff48030 = _DAT_3ff48030 | 0xd8000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_powerdown_rf(void)

{
  memw();
  memw();
  _DAT_3ff48030 = _DAT_3ff48030 & 0x27ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 rtc_get_st(void)

{
  memw();
  return _DAT_3ff480c0 >> 0x1c;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 rtc_is_st_idle(void)

{
  memw();
  return (_DAT_3ff480c0 & 0x8000000) >> 0x1b;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_soc_clk_ck12m(void)

{
  memw();
  memw();
  _DAT_3ff48070 = _DAT_3ff48070 & 0xe7ffffff | 0x10000000;
  memw();
  memw();
  _DAT_3ff48000 = _DAT_3ff48000 & 0xffffc0ff | 0x1500;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_init_full(u32 fast_clk_sel,u32 ck12m_div,u32 ck12m_wait,u32 xtal_wait,u32 pll_wait,
                  u32 ana_clk_sel,u32 slw_ck_dcap,u32 ck12m_dfreq,u32 pwrctl_init,u32 ck12m_fpu,
                  u32 xtl_fpu,u32 bias_core_fpu,u32 bias_i2c_fpu,u32 bias_fnslp,u32 bbpll_fpu,
                  u32 bbplli2c_fpu,u32 rtcreg_fpu,u32 rtcdboost_fpu,u32 dec_hbw,u32 inc_hbp,
                  u32 rtc_dbias,u32 dig_dbias,u32 x32k_dac,u32 lslp_meminf_pd)

{
  memw();
  _DAT_3ff4808c = _DAT_3ff4808c & 0xfffffbff;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff4801c =
       (ck12m_wait & 0xff) << 6 |
       (xtal_wait & 0x3ff) << 0xe | _DAT_3ff4801c & 0x3f | pll_wait << 0x18;
  memw();
  if (pwrctl_init != 0) {
    memw();
    if (ck12m_fpu == 0) {
      _DAT_3ff48070 = _DAT_3ff48070 & 0xfbffffff;
      memw();
    }
    else {
      _DAT_3ff48070 = _DAT_3ff48070 | 0x4000000;
      memw();
    }
    memw();
    if (xtl_fpu == 0) {
      _DAT_3ff48000 = _DAT_3ff48000 & 0xffffdfff;
      memw();
    }
    else {
      _DAT_3ff48000 = _DAT_3ff48000 | 0x2000;
      memw();
    }
    memw();
    if (bias_core_fpu == 0) {
      _DAT_3ff48000 = _DAT_3ff48000 & 0xffbfffff;
      memw();
    }
    else {
      _DAT_3ff48000 = _DAT_3ff48000 | 0x400000;
      memw();
    }
    memw();
    if (bias_i2c_fpu == 0) {
      _DAT_3ff48000 = _DAT_3ff48000 & 0xfff7ffff;
      memw();
    }
    else {
      _DAT_3ff48000 = _DAT_3ff48000 | 0x80000;
      memw();
    }
    memw();
    if (bias_fnslp == 0) {
      _DAT_3ff48000 = _DAT_3ff48000 & 0xfffeffff;
      memw();
    }
    else {
      _DAT_3ff48000 = _DAT_3ff48000 | 0x10000;
      memw();
    }
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    if (bbpll_fpu == 0) {
      _DAT_3ff48000 = _DAT_3ff48000 & 0xffedb7ff;
      memw();
    }
    else {
      _DAT_3ff48000 = _DAT_3ff48000 & 0xffedbfff | 0x800;
      memw();
    }
    memw();
    if (bbplli2c_fpu == 0) {
      _DAT_3ff48000 = _DAT_3ff48000 & 0xfffffdff;
      memw();
    }
    else {
      _DAT_3ff48000 = _DAT_3ff48000 | 0x200;
      memw();
    }
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_3ff48084 = _DAT_3ff48084 & 0xffeaaaaf;
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_3ff48080 = _DAT_3ff48080 & 0xfffedffa;
    memw();
    memw();
    memw();
    memw();
    _DAT_3ff48088 = _DAT_3ff48088 & 0x5555afff;
    memw();
    if (dec_hbw == 0) {
      memw();
      _DAT_3ff48078 = _DAT_3ff48078 & 0xbfffffff;
      memw();
    }
    else {
      memw();
      _DAT_3ff48078 = _DAT_3ff48078 | 0x40000000;
      memw();
    }
    if (inc_hbp == 0) {
      memw();
      _DAT_3ff48078 = _DAT_3ff48078 & 0xdfffffff;
      memw();
    }
    else {
      memw();
      _DAT_3ff48078 = _DAT_3ff48078 | 0x20000000;
      memw();
    }
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    memw();
    _DAT_3ff4807c =
         _DAT_3ff4807c & 0xf03fc0ff | (rtc_dbias & 7) << 0x16 | (rtc_dbias & 7) << 0x19 |
         (dig_dbias & 7) << 0xb | (dig_dbias & 7) << 8;
    memw();
  }
  rtc_init_clk(0,fast_clk_sel,ck12m_div,ana_clk_sel,slw_ck_dcap,ck12m_dfreq);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pad_gpio_wakeup(u32 mask,u32 value)

{
  rtc_pads_muxsel(mask,1);
  rtc_pads_funsel(mask,0);
  memw();
  _DAT_3ff4840c = (mask ^ 0xffffffff) & _DAT_3ff4840c;
  memw();
  rtc_pads_slpsel(mask,1);
  rtc_pads_slpoe(mask,0);
  rtc_pads_slpie(mask,1);
  rtc_pads_funie(mask,1);
  rtc_pads_pu(mask,0);
  rtc_pads_pd(mask,0);
  if ((mask & 1) != 0) {
    memw();
    memw();
    memw();
    _DAT_3ff48428 = _DAT_3ff48428 & 0xfffffc7f | 0x400 | (value & 7) << 7;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_pad_ext_wakeup(u32 mask,u32 wakeup_sel,u32 wakeup_lv)

{
  rtc_pads_muxsel(mask,1);
  rtc_pads_funsel(mask,0);
  memw();
  _DAT_3ff4840c = (mask << 0xe ^ 0xffffffff) & _DAT_3ff4840c;
  memw();
  rtc_pads_slpsel(mask,1);
  rtc_pads_slpoe(mask,0);
  rtc_pads_slpie(mask,1);
  rtc_pads_funie(mask,1);
  rtc_pads_pu(mask,0);
  rtc_pads_pd(mask,0);
  memw();
  memw();
  _DAT_3ff484bc = _DAT_3ff484bc & 0x7ffffff | wakeup_sel << 0x1b;
  memw();
  memw();
  _DAT_3ff48060 = (wakeup_lv & 1) << 0x1e | _DAT_3ff48060 & 0xbfffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_cmd_ext_wakeup(u32 mask,u32 wakeup_sel)

{
  rtc_pads_muxsel(mask,1);
  rtc_pads_funsel(mask,0);
  memw();
  _DAT_3ff4840c = (mask << 0xe ^ 0xffffffff) & _DAT_3ff4840c;
  memw();
  rtc_pads_slpsel(mask,1);
  rtc_pads_slpoe(mask,0);
  rtc_pads_slpie(mask,1);
  rtc_pads_funie(mask,1);
  rtc_pads_pu(mask,0);
  rtc_pads_pd(mask,0);
  memw();
  memw();
  _DAT_3ff484bc = _DAT_3ff484bc & 0x7ffffff | wakeup_sel << 0x1b;
  memw();
  memw();
  _DAT_3ff48060 = _DAT_3ff48060 | 0x40000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_wifi_force_pd(void)

{
  memw();
  memw();
  _DAT_3ff000cc = _DAT_3ff000cc & 0xffffffbf;
  memw();
  memw();
  _DAT_3ff000d0 = _DAT_3ff000d0 | 4;
  memw();
  memw();
  _DAT_3ff48088 = _DAT_3ff48088 | 0x10000000;
  memw();
  memw();
  _DAT_3ff48084 = _DAT_3ff48084 | 0x20000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_sdreg_off(void)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48074 = _DAT_3ff48074 & 0x7fffffff | 0xc00000;
  return;
}



// WARNING: Unknown calling convention

void rtc_slp_prep_lite_12M(u32 deep_slp,u32 cpu_lp_mode)

{
  rtc_slp_prep(2,0,0,0,0,0,0,0,0,deep_slp,0,cpu_lp_mode,4,0,0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void cfg_sdio_volt(uint8 drefh,uint8 drefm,uint8 drefl)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48074 =
       (drefl & 3) << 0x19 |
       (drefm & 3) << 0x1b | (drefh & 3) << 0x1d | _DAT_3ff48074 & 0x817fffff | 0x80000000 |
       0x1400000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_wifi_force_pd_off(void)

{
  memw();
  memw();
  _DAT_3ff48084 = _DAT_3ff48084 & 0xfffdffff;
  memw();
  memw();
  _DAT_3ff48088 = _DAT_3ff48088 & 0xefffffff;
  memw();
  memw();
  _DAT_3ff000d0 = _DAT_3ff000d0 & 0xfffffffe;
  memw();
  memw();
  _DAT_3ff000cc = _DAT_3ff000cc | 0x40f;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_digital_lp_mode_off_stg1(void)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48000 = _DAT_3ff48000 & 0xffdbefff;
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff000c0 = 0xffffffff;
  memw();
  memw();
  _DAT_3ff48084 = _DAT_3ff48084 & 0xfffd555f;
  memw();
  memw();
  _DAT_3ff48088 = _DAT_3ff48088 & 0xeaaaffff;
  memw();
  memw();
  _DAT_3ff000d0 = _DAT_3ff000d0 & 0xfffffffe;
  memw();
  memw();
  _DAT_3ff000cc = 0xffffffff;
  memw();
  rtc_dbias_cfg(4,0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rtc_digital_lp_mode_off_stg2(void)

{
  memw();
  memw();
  _DAT_3ff48000 = _DAT_3ff48000 & 0xfffffaff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_sar_sleep_timer_start(u32 cycles)

{
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_3ff48818 = cycles;
  memw();
  memw();
  _DAT_3ff4882c = _DAT_3ff4882c & 0xfffffcff | 0x200;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rtc_mac_tx_init(RTC_TX_INFO *rtc_tx_infor)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = _DAT_60033d24;
  memw();
  memw();
  _DAT_60033d24 = _DAT_60033d24 | 2;
  do {
    memw();
  } while ((uVar1 & 1) == 0);
  memw();
  memw();
  memw();
  memw();
  memw();
  memw();
  _DAT_60033c78 = _DAT_60033c78 | 2;
  memw();
  memw();
  _DAT_600330d8 = _DAT_600330d8 | 7;
  memw();
  memw();
  _DAT_600330dc = _DAT_600330dc | 7;
  memw();
  memw();
  _DAT_600330e0 = _DAT_600330e0 | 7;
  memw();
  memw();
  _DAT_600330e4 = _DAT_600330e4 | 7;
  memw();
  tx_link.buf_addr = rtc_tx_infor->txframe_ptr;
  memw();
  _DAT_60033c6c = _DAT_60033c6c & 0xffffffed | 0x10000000;
  memw();
  memw();
  memw();
  _DAT_60033040 = *(uint *)(tx_link.buf_addr + 8) >> 0x10 | *(int *)(tx_link.buf_addr + 0xc) << 0x10
  ;
  memw();
  memw();
  _DAT_60033044 = *(uint *)(tx_link.buf_addr + 0xc) >> 0x10;
  memw();
  memw();
  _DAT_60033c40 = _DAT_60033c40 | 0x80;
  memw();
  uVar3 = *(uint *)rtc_tx_infor >> 8 & 0xfff;
  memw();
  _DAT_60033c4c = _DAT_60033c4c | 0x80;
  uVar1 = *(uint *)rtc_tx_infor;
  tx_link.link_dscr = uVar3 * 0x1001 + 0xc0000000;
  tx_link.next_addr = 0;
  memw();
  if ((uVar1 & 0x200000) == 0) {
    _DAT_3ff5c860 = _DAT_3ff5c860 & 0xfffff3ff;
    memw();
    memw();
    _DAT_3ff5c87c = _DAT_3ff5c87c & 0xfffff7ff;
    memw();
  }
  else {
    _DAT_3ff5c860 = _DAT_3ff5c860 | 0xc00;
    memw();
    memw();
    _DAT_3ff5c87c = _DAT_3ff5c87c | 0x800;
    memw();
  }
  uVar2 = uVar1 & 0x3f;
  if (uVar2 < 0x20) {
    if (uVar2 < 0x18) {
      if (uVar2 < 0x10) {
        uVar2 = (uVar1 & 0x1f) << 0xc;
        _DAT_600340f8 = 0;
      }
      else {
        memw();
        _DAT_600340f0 = _DAT_600340f0 & 0xf9ffffff | 0x2000000;
        memw();
        _DAT_600340f8 =
             (uVar1 >> 0x16 & 1) << 0x1e | uVar3 << 8 | (uVar1 >> 0x14 & 1) << 7 | uVar2 - 0x10;
        uVar2 = 0xb000;
      }
    }
    else {
      memw();
      _DAT_600340f0 = _DAT_600340f0 & 0xf9ffffff | 0x2000000;
      memw();
      _DAT_600340f8 =
           (uVar1 >> 0x16 & 1) << 0x1e | uVar3 << 8 | 0x80000000 | (uVar1 >> 0x14 & 1) << 7 |
           uVar2 - 0x18;
      uVar2 = 0xb000;
    }
  }
  else {
    uVar2 = (uVar2 - 0x10 & 0x1f) << 0xc;
    _DAT_600340f8 = 0;
  }
  memw();
  memw();
  memw();
  memw();
  _DAT_600340f0 = _DAT_600340f0 & 0xfffe0000 | uVar2 | uVar3;
  memw();
  if ((uVar1 & 0x100000) != 0) {
    memw();
    _DAT_600340fc = _DAT_600340fc & 0xffff0000 | uVar3;
    memw();
  }
  memw();
  memw();
  memw();
  memw();
  _DAT_60033cec =
       (*(uint *)&rtc_tx_infor->field_0x4 & 0x3ff) << 0xc |
       (*(uint *)&rtc_tx_infor->field_0x4 >> 0xc & 0xf) << 0x18 | _DAT_60033cec & 0xf0c00fff;
  if ((uVar1 & 0x800000) != 0) {
    memw();
    _DAT_60033cf0 = _DAT_60033cf0 | 0x8000000;
    memw();
  }
  if ((uVar1 & 0x1000000) != 0) {
    memw();
    _DAT_60033cf0 = _DAT_60033cf0 | 0x10000000;
    memw();
  }
  memw();
  memw();
  memw();
  memw();
  _DAT_60033cf0 = (uVar1 >> 0x19 & 1) << 0x18 | _DAT_60033cf0 & 0xf8f00000 | 0x60bd8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

u32 rtc_mac_tx(void)

{
  u32 uVar1;
  
  memw();
  memw();
  _DAT_60033c4c = _DAT_60033c4c | 0x80;
  memw();
  memw();
  _DAT_60033cf0 = _DAT_60033cf0 | 0xc0000000;
  do {
    memw();
  } while ((_DAT_60033c48 & 0x80) == 0);
  memw();
  uVar1 = 0xffffffff;
  if ((_DAT_60033cc8 & 0x40) != 0) {
    memw();
    _DAT_60033cc4 = _DAT_60033cc4 | 0x40;
    memw();
    memw();
    uVar1 = _DAT_60034108;
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_disable_agc(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c030);
  memw();
  _DAT_3ff5c030 = uVar1 | 0x100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_enable_agc(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c030);
  memw();
  _DAT_3ff5c030 = uVar1 & 0xfffffeff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_write_gain_mem(u32 data_h,u32 data_l,u8 addr)

{
  uint uVar1;
  
  memw();
  _DAT_3ff45038 = data_l;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45034);
  _DAT_3ff45034 = uVar1 & 0xfffc0000 | (uint)addr * 0x100 + 0x100f0;
  memw();
  memw();
  _DAT_3ff45038 = data_h;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45034);
  _DAT_3ff45034 = uVar1 & 0xfffc0000 | (uint)addr * 0x100 + 0x1000f;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45034);
  memw();
  _DAT_3ff45034 = uVar1 & 0xfffcffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_set_txclk_en(bool txclk_en)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
  uVar2 = 0x30000;
  if (!txclk_en) {
    uVar2 = 0;
  }
  memw();
  _DAT_3ff460a0 = uVar2 | uVar1 & 0xfffcffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_set_rxclk_en(bool rxclk_en)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
  uVar2 = 0xc000;
  if (!rxclk_en) {
    uVar2 = 0;
  }
  memw();
  _DAT_3ff460a0 = uVar2 | uVar1 & 0xffff3fff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void disable_wifi_agc(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c01c);
  _DAT_3ff5c01c = uVar1 & 0xff00ffff | 0x7f0000;
  memw();
  _DAT_3ff5c038 = esp_dport_access_reg_read(&DAT_3ff5c038);
  _DAT_3ff5c038 = _DAT_3ff5c038 | 0x4000000;
  memw();
  _DAT_3ff5c030 = esp_dport_access_reg_read(&DAT_3ff5c030);
  _DAT_3ff5c030 = _DAT_3ff5c030 & 0xffffffcf;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c080);
  memw();
  _DAT_3ff5c080 = uVar1 | 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void enable_wifi_agc(void)

{
  uint uVar1;
  
  _DAT_3ff5c080 = esp_dport_access_reg_read(&DAT_3ff5c080);
  _DAT_3ff5c080 = _DAT_3ff5c080 & 0xfffffffe;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c030);
  _DAT_3ff5c030 = uVar1 & 0xffffffcf | 0x10;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c01c);
  _DAT_3ff5c01c = uVar1 & 0xff00ffff | 0xc0000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c038);
  memw();
  _DAT_3ff5c038 = uVar1 | 0x4000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void wr_bt_tx_atten(sint8 *bt_dig_atten)

{
  sint8 tx_gain [8];
  
  tx_gain[0] = -*bt_dig_atten;
  memw();
  if (!bt_dig_gain_force) {
    memw();
    DAT_3ff4600c = tx_gain[0];
    DAT_3ff4600c_1._0_1_ = tx_gain[1];
    DAT_3ff4600c_1._1_1_ = tx_gain[2];
    DAT_3ff4600c_1._2_1_ = tx_gain[3];
    memw();
    _DAT_3ff46010 = tx_gain._4_4_;
  }
  return;
}



// WARNING: Unknown calling convention

void wr_bt_tx_gain_mem(uint8 pa_in,uint8 bb_in)

{
  ushort uVar1;
  ushort uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  sleep_param_t *psVar8;
  uint uVar9;
  u16 txdc [4];
  
  uVar5 = (uint)bb_in;
  uVar3 = esp_dport_access_reg_read(&DAT_3ff46000);
  if (uVar5 == 0xff) {
    uVar5 = (uint)chip7_sleep_params.bt_bb_gain;
    uVar9 = chip7_sleep_params.bt_bb_gain >> 6 & 0xff;
  }
  else {
    uVar9 = (uint)(bb_in >> 6);
  }
  uVar6 = (uint)chip7_sleep_params.bt_bb_gain;
  uVar4 = uVar6;
  uVar7 = uVar6;
  if (uVar6 != 0) {
    uVar7 = 4;
    if (uVar6 == 0x30) {
      uVar7 = 8;
    }
    uVar4 = 1;
    if (uVar6 == 0x30) {
      uVar4 = 2;
    }
  }
  uVar1 = chip7_sleep_params.bt_txiq[uVar4];
  uVar2 = chip7_sleep_params.bt_txdc_table[uVar7];
  memw();
  uVar3 = ((uVar3 & 0x3fc0000) >> 0x12) + 8;
  psVar8 = &chip7_sleep_params;
  do {
    uVar4 = (uint)pa_in;
    if (pa_in == 0xff) {
      uVar4 = (uint)psVar8->bt_pa_gain[0];
    }
    psVar8 = (sleep_param_t *)((int)&psVar8->param_flag + 1);
    (*g_phyFuns->write_gain_mem_)
              ((uint)uVar2 << 0xc | (uint)txdc[1] << 3 | (uint)(txdc[2] >> 6) | (uint)uVar1 << 0x15,
               uVar4 << 10 |
               (uint)txdc[3] << 0x11 | (uint)txdc[2] << 0x1a | uVar9 | (uVar5 & 0x3f) << 3,(u8)uVar3
              );
    uVar3 = (uVar3 & 0xff) + 1;
  } while (psVar8 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_tx_gain_table(U16 pa_gain,U16 bbgain)

{
  ushort uVar1;
  ushort uVar2;
  byte bVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  u32 gain_data_h;
  u16 txdc [4];
  
  uVar4 = esp_dport_access_reg_read(&DAT_3ff46000);
  _DAT_3ff46000 = uVar4 & 0xfc03ffff | 0x1b80000;
  memw();
  bVar3 = (*g_phyFuns->txbbgain_to_index_)(bbgain);
  uVar1 = chip7_sleep_params.txdc_table[(uint)bVar3 * 4];
  memw();
  uVar2 = chip7_sleep_params.wifi_txiq[3 < bVar3];
  iVar5 = 0x6e;
  do {
    iVar6 = iVar5 + 1;
    (*g_phyFuns->write_gain_mem_)
              ((uint)uVar1 << 0xc | (uint)txdc[1] << 3 | (uint)(txdc[2] >> 6) | (uint)uVar2 << 0x15,
               (uint)txdc[3] << 0x11 | (uint)txdc[2] << 0x1a | (uint)pa_gain << 10 |
               bbgain >> 6 & 0xff | (bbgain & 0x3f) << 3,(u8)iVar5);
    iVar5 = iVar6;
  } while (iVar6 != 0x76);
  return;
}



// WARNING: Unknown calling convention

u8 set_most_pwr_reg(void)

{
  u8 uVar1;
  int iVar2;
  uint uVar3;
  ushort uVar4;
  U8 target_power [6];
  
  get_phy_target_power(target_power,(short)phy_in_vdd33_offset);
  iVar2 = (int)phy_in_most_power;
  if (iVar2 < (int)(uint)target_power[5]) {
    uVar3 = (uint)target_power[5] - (uint)(byte)phy_in_most_power & 0xff;
    phy_set_most_tpw_disbg = true;
    memw();
    if (uVar3 < 9) {
      set_most_tpw = target_power[5] + 0xf8;
      uVar4 = 0xe;
      memw();
    }
    else if (uVar3 < 0x13) {
      set_most_tpw = target_power[5] + 0xee;
      uVar4 = 10;
      memw();
    }
    else if (uVar3 < 0x19) {
      set_most_tpw = target_power[5] + 0xe8;
      uVar4 = 7;
      memw();
    }
    else if (uVar3 < 0x21) {
      set_most_tpw = target_power[5] + 0xe0;
      uVar4 = 6;
      memw();
    }
    else if (uVar3 < 0x2d) {
      set_most_tpw = target_power[5] + 0xd4;
      uVar4 = 5;
      memw();
    }
    else if (uVar3 < 0x39) {
      set_most_tpw = target_power[5] + 200;
      uVar4 = 2;
      memw();
    }
    else if (uVar3 < 0x45) {
      set_most_tpw = target_power[5] + 0xbc;
      uVar4 = 1;
      memw();
    }
    else {
      set_most_tpw = target_power[5] + 0xa4;
      uVar4 = 0;
      memw();
    }
    uVar1 = '\x05';
    tx_rf_ana_gain[0] = uVar4 | chip7_sleep_params.loop_tx_rf_ana_gain[0] & 0xf0;
    memw();
  }
  else {
    phy_set_most_tpw_disbg = false;
    memw();
    if (iVar2 < (int)(uint)target_power[4]) {
      uVar1 = '\x05';
      set_most_tpw = target_power[5];
      memw();
    }
    else if (iVar2 < (int)(uint)target_power[3]) {
      uVar1 = '\x04';
      set_most_tpw = target_power[4];
      memw();
    }
    else if (iVar2 < (int)(uint)target_power[2]) {
      uVar1 = '\x03';
      set_most_tpw = target_power[3];
      memw();
    }
    else if (iVar2 < (int)(uint)target_power[1]) {
      uVar1 = '\x02';
      set_most_tpw = target_power[2];
      memw();
    }
    else if (iVar2 < (int)(uint)target_power[0]) {
      uVar1 = '\x01';
      set_most_tpw = target_power[1];
      memw();
    }
    else {
      uVar1 = '\0';
      set_most_tpw = target_power[0];
      memw();
    }
    tx_rf_ana_gain[0] = chip7_sleep_params.loop_tx_rf_ana_gain[0] & 0xff | 0xf;
    memw();
  }
  set_tx_gain_table(tx_rf_ana_gain[0],tx_rf_ana_gain[1]);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_xpd_sar(bool on)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4880c);
  uVar2 = 0xc0000;
  if (!on) {
    uVar2 = 0;
  }
  memw();
  _DAT_3ff4880c = uVar2 | uVar1 & 0xfff3ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bb_wdt_rst_enable(bool enable)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5d040);
  memw();
  _DAT_3ff5d040 = uVar1 & 0x7fffffff | (uint)enable << 0x1f;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bb_wdt_int_enable(bool enable)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5d040);
  memw();
  _DAT_3ff5d040 = (enable & 1) << 0x1e | uVar1 & 0xbfffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bb_wdt_timeout_clear(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5d040);
  memw();
  _DAT_3ff5d040 = uVar1 | 0x20000000;
  return;
}



// WARNING: Unknown calling convention

uint32 bb_wdt_get_status(void)

{
  uint32 uVar1;
  uint32_t val;
  
  uVar1 = esp_dport_access_reg_read(0x3ff5d008);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_tx_gain_cal(void)

{
  short sVar1;
  sleep_param_t *psVar2;
  ushort uVar3;
  char cVar4;
  short sVar5;
  char cVar6;
  uint16 pa_ana_gain [2];
  sint16 correct_qdb;
  
  cVar4 = -0x60;
  psVar2 = &chip7_sleep_params;
  sVar1 = (short)btpwr_atten_offset;
  uVar3 = (ushort)chip7_sleep_params.bt_txpwr_atten;
  sVar5 = -0x4c - (uVar3 + sVar1);
  do {
    pa_ana_gain[1] = chip7_sleep_params.bt_bb_gain;
    pa_ana_gain[0] = bt_tx_pa_gain;
    memw();
    correct_qdb = sVar5;
    correct_rf_ana_gain_new(&correct_qdb,pa_ana_gain,pa_ana_gain + 1,true);
    cVar6 = ((char)(uVar3 + sVar1) + (char)correct_qdb) - cVar4;
    psVar2->bt_pa_gain[0] = (uint8)pa_ana_gain[0];
    memw();
    if (cVar6 < '\0') {
      psVar2->bt_dig_atten[0] = '\0';
      memw();
    }
    else {
      if ('@' < cVar6) {
        cVar6 = '@';
      }
      psVar2->bt_dig_atten[0] = cVar6;
      memw();
    }
    cVar4 = cVar4 + '\f';
    sVar5 = sVar5 + 0xc;
    psVar2 = (sleep_param_t *)((int)&psVar2->param_flag + 1);
  } while (cVar4 != '\0');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_tx_gain_cal_set(void)

{
  bt_tx_gain_cal();
  force_txrx_off(true);
  wr_bt_tx_gain_mem(0xff,0xff);
  wr_bt_tx_atten(chip7_sleep_params.bt_dig_atten);
  force_txrx_off(false);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_tx_gain_cal_set(void)

{
  if (!bt_dig_gain_force) {
    bt_tx_gain_cal_set();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_wifi_enable_set(uint8 enable)

{
  uint uVar1;
  
  if (enable != '\0') {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c080);
    memw();
    _DAT_3ff5c080 = uVar1 & 0xffffff3f;
    return;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c080);
  memw();
  _DAT_3ff5c080 = uVar1 | 0xc0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_set_noise_floor(sint16 noise)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  
  iVar1 = (int)noise;
  uVar3 = 0x5400;
  if (iVar1 < -0x15f) {
    uVar3 = ((uint)(iVar1 < -0x188) * -0x188 + (uint)(iVar1 >= -0x188) * iVar1 & 0x3ff) << 5;
  }
  uVar2 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = uVar2 & 0xffff801f | uVar3;
  memw();
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = _DAT_3ff5c018 | 0x10;
  memw();
  if (corr_cca_thr != '\0') {
    set_rx_sense(corr_cca_thr);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_close_rf(void)

{
  undefined4 uVar1;
  CriticalType crit_level;
  
  uVar1 = phy_enter_critical();
  noise_check_loop('\x01',true);
  disable_wifi_agc();
  _DAT_3ff00024 = esp_dport_access_reg_read(&DAT_3ff00024);
  _DAT_3ff00024 = _DAT_3ff00024 & 0xfffffffd;
  memw();
  (*g_phyFuns->pbus_debugmode_)();
  (*g_phyFuns->pbus_force_test_)('\x01','\x01',0);
  (*g_phyFuns->pbus_workmode_)();
  _DAT_3ff48030 = esp_dport_access_reg_read(&DAT_3ff48030);
  _DAT_3ff48030 = _DAT_3ff48030 & 0x27ffffff;
  memw();
  set_xpd_sar(false);
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Unknown calling convention

U8 get_target_power_offset(U8 rate,U8 *ratepw_offset)

{
  U8 UVar1;
  uint uVar2;
  
  uVar2 = (uint)rate;
  if (uVar2 < 8) {
    UVar1 = '\0';
    if (chip7_phy_init_ctrl.pwr_ind_11b_en != '\0') {
      return chip7_phy_init_ctrl.pwr_ind_11b[0];
    }
  }
  else {
    if (uVar2 < 0x10) {
      return ratepw_offset[*(byte *)((int)&CSWTCH_256 + (uVar2 - 8 & 0xff))];
    }
    UVar1 = '\0';
    if (uVar2 < 0x18) {
      UVar1 = ratepw_offset[uVar2 - 0x10];
    }
  }
  return UVar1;
}



// WARNING: Unknown calling convention

uint8 ram_txbbgain_to_index(uint16 txbb_gain)

{
  if (txbb_gain == 0x30) {
    return '\x04';
  }
  if (txbb_gain < 0x31) {
    if (txbb_gain == 0x20) {
      return '\x01';
    }
  }
  else {
    if (txbb_gain == 0xa0) {
      return '\x02';
    }
    if (txbb_gain == 0x120) {
      return '\x03';
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

sint8 ram_set_chan_cal_interp(sint8 *chan_data,uint8 chan)

{
  char cVar1;
  char cVar2;
  uint uVar3;
  
  uVar3 = chan - 1 & 0xff;
  if (uVar3 < 6) {
    cVar1 = *chan_data;
    cVar2 = chan_data[1];
  }
  else {
    if (10 < uVar3) {
      if (uVar3 < 0xd) {
        return (char)((int)(((int)chan_data[3] - (int)chan_data[2]) * (uVar3 - 10) * 5) / 0x16) +
               chan_data[2];
      }
      return chan_data[3];
    }
    cVar1 = chan_data[1];
    uVar3 = uVar3 - 5;
    cVar2 = chan_data[2];
  }
  return (char)((int)(((int)cVar2 - (int)cVar1) * uVar3) / 5) + cVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void write_txrate_power_offset(bool chg_offset)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  char cVar4;
  uint uVar5;
  uint *puVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  
  if (!chg_offset) {
    memw();
    _DAT_3ff4506c = 0xfedcba98;
    memw();
    _DAT_3ff45070 = 0xffffffff;
    memw();
    _DAT_3ff45074 = 0xffffffff;
    memw();
    _DAT_3ff45078 = 0xffffffff;
    memw();
    _DAT_3ff4503c = 0x77777777;
    memw();
    _DAT_3ff45040 = 0x77777777;
    memw();
    _DAT_3ff45044 = 0x77777777;
    memw();
    _DAT_3ff45048 = 0x77777777;
    return;
  }
  puVar6 = (uint *)&DAT_3ff4504c;
  cVar4 = '\b';
  do {
    uVar2 = 0;
    uVar8 = uVar2;
    do {
      bVar1 = get_target_power_offset(cVar4 + ((byte)(uVar2 >> 2) & 0x3f),phy_chan_pwr_index);
      uVar5 = uVar2 & 7;
      uVar2 = uVar2 + 1;
      uVar8 = uVar8 + ((uint)bVar1 << 0x20 - (uVar5 * -4 + 0x20));
    } while (uVar2 != 8);
    memw();
    *puVar6 = uVar8;
    cVar4 = cVar4 + '\x02';
    puVar6 = puVar6 + 1;
  } while (puVar6 != (uint *)0x3ff4505c);
  if (lr_enable != false) {
    uVar8 = esp_dport_access_reg_read(&DAT_3ff4504c);
    _DAT_3ff4504c = uVar8 & 0xffff | 0x77770000;
    memw();
    uVar8 = esp_dport_access_reg_read(&DAT_3ff45050);
    _DAT_3ff45050 = uVar8 & 0xffff0000 | 0x7777;
    memw();
  }
  iVar9 = 0;
  puVar6 = (uint *)0x3ff4505c;
  do {
    uVar5 = 0;
    iVar7 = 8;
    uVar8 = uVar5;
    uVar2 = uVar5;
    do {
      if ((uVar2 & 3) == 3) {
        iVar3 = (uint)phy_chan_pwr_index[(uVar2 >> 2) + 8 + iVar9] << 0x20 - (0x20 - (uVar5 & 0x1f))
        ;
      }
      else {
        iVar3 = (uint)phy_chan_pwr_index[(uVar2 >> 2) + iVar9] << 0x20 - (0x20 - (uVar5 & 0x1f));
      }
      uVar8 = uVar8 + iVar3;
      uVar2 = uVar2 + 1 & 0xff;
      uVar5 = uVar5 + 4;
      iVar7 = iVar7 + -1;
    } while (iVar7 != 0);
    memw();
    *puVar6 = uVar8;
    iVar9 = iVar9 + 2;
    puVar6 = puVar6 + 1;
  } while (iVar9 != 8);
  return;
}



// WARNING: Unknown calling convention

void get_phy_target_power(U8 *target_power,S16 vdd33_offset)

{
  sint8 sVar1;
  sint8 backoff_m [4];
  
  backoff_m[0] = (sint8)chip7_sleep_params.target_power_chan_backoff[0];
  backoff_m[1] = (sint8)chip7_sleep_params.target_power_chan_backoff[1];
  backoff_m[2] = (sint8)chip7_sleep_params.target_power_chan_backoff[2];
  backoff_m[3] = (sint8)chip7_sleep_params.target_power_chan_backoff[3];
  memw();
  sVar1 = (*g_phyFuns->set_chan_cal_interp_)(backoff_m,chip7_sleep_params.phy_channel_num);
  (*g_phyFuns->target_power_add_backoff_)(target_power,(U8 *)0x5bc12,(short)sVar1);
  *target_power = ((char)vdd33_offset - (char)target_power_backoff_qdb) + *target_power;
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void force_txrx_off(bool off)

{
  uint uVar1;
  
  if (off) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = uVar1 & 0xfffff0ff | 0x800;
    memw();
    ets_delay_us(1);
    uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = uVar1 & 0xfffff0ff | 0xa00;
    memw();
    ets_delay_us(1);
    return;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = uVar1 & 0xfffff0ff | 0x200;
  memw();
  ets_delay_us(1);
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 & 0xfffff0ff;
  memw();
  ets_delay_us(1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_pwdet_onetime_en(void)

{
  uint uVar1;
  
  pwdet_sar2_init();
  _DAT_3ff4e060 = esp_dport_access_reg_read(&DAT_3ff4e060);
  _DAT_3ff4e060 = _DAT_3ff4e060 & 0xfffffffe;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e060);
  memw();
  _DAT_3ff4e060 = uVar1 | 1;
  phy_pwdet_onetime_flag = true;
  memw();
  return;
}



// WARNING: Unknown calling convention

void ram_read_sar_dout(U16 *sar_data)

{
  ushort uVar1;
  int iVar2;
  
  iVar2 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4e080 + iVar2 * 4);
    *sar_data = (uVar1 ^ 0xffff) & 0xfff;
    memw();
    iVar2 = iVar2 + 1;
    sar_data = sar_data + 1;
  } while (iVar2 != 8);
  return;
}



// WARNING: Unknown calling convention

void get_rate_fcc_index(uint8 chan,uint8 *fcc_index_all)

{
  byte bVar1;
  uint uVar2;
  byte bVar3;
  byte bVar4;
  
  uVar2 = (uint)chan;
  if (chip7_phy_init_ctrl.fcc_enable == '\x02') {
    bVar4 = chip7_phy_init_ctrl.chan_pwr_limit_cbw20[uVar2 - 1] >> 4;
    bVar3 = chip7_phy_init_ctrl.chan_pwr_limit_cbw20[uVar2 - 1] & 0xf;
    switch(uVar2 - 3 & 0xff) {
    case 0:
      bVar1 = chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[0] & 0xf;
      break;
    case 1:
      bVar1 = chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[0] >> 4;
      break;
    case 2:
      bVar1 = chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[1] & 0xf;
      break;
    case 3:
      bVar1 = chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[1] >> 4;
      break;
    case 4:
      bVar1 = chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[2] & 0xf;
      break;
    case 5:
      bVar1 = chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[2] >> 4;
      break;
    case 6:
      bVar1 = chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[3] & 0xf;
      break;
    case 7:
      bVar1 = chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[3] >> 4;
      break;
    case 8:
      bVar1 = chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[4] & 0xf;
      break;
    default:
      bVar1 = 0;
    }
  }
  else if (chip7_phy_init_ctrl.fcc_enable == '\x03') {
    bVar4 = chip7_phy_init_ctrl.chan_pwr_limit_cbw20[uVar2 - 1];
    bVar3 = chip7_phy_init_ctrl.chan_pwr_limit_cbw20_gn[uVar2 - 1];
    switch(uVar2 - 3 & 0xff) {
    case 0:
      bVar1 = (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[0] < 0x19) *
              chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[0] +
              (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[0] >= 0x19) * '\x19';
      break;
    case 1:
      bVar1 = (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[1] < 0x19) *
              chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[1] +
              (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[1] >= 0x19) * '\x19';
      break;
    case 2:
      bVar1 = (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[2] < 0x19) *
              chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[2] +
              (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[2] >= 0x19) * '\x19';
      break;
    case 3:
      bVar1 = (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[3] < 0x19) *
              chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[3] +
              (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[3] >= 0x19) * '\x19';
      break;
    case 4:
      bVar1 = (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[4] < 0x19) *
              chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[4] +
              (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[4] >= 0x19) * '\x19';
      break;
    case 5:
      bVar1 = (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[0] < 0x19) *
              chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[0] +
              (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[0] >= 0x19) * '\x19';
      break;
    case 6:
      bVar1 = (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[1] < 0x19) *
              chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[1] +
              (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[1] >= 0x19) * '\x19';
      break;
    case 7:
      bVar1 = (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[2] < 0x19) *
              chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[2] +
              (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[2] >= 0x19) * '\x19';
      break;
    case 8:
      bVar1 = (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[3] < 0x19) *
              chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[3] +
              (chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[3] >= 0x19) * '\x19';
      break;
    default:
      bVar1 = 0;
    }
    bVar4 = (bVar4 < 0x19) * bVar4 + (bVar4 >= 0x19) * '\x19';
    bVar3 = (bVar3 < 0x19) * bVar3 + (bVar3 >= 0x19) * '\x19';
  }
  else {
    bVar1 = 0;
    bVar3 = 0;
    bVar4 = 0;
  }
  *fcc_index_all = bVar3;
  fcc_index_all[1] = bVar4;
  fcc_index_all[2] = bVar1;
  memw();
  return;
}



// WARNING: Unknown calling convention

uint8 get_rate_target_power(uint8 rate)

{
  byte bVar1;
  uint uVar2;
  
  bVar1 = rate >> 2;
  uVar2 = 0x10;
  if (7 < bVar1) {
    if (bVar1 < 0x10) {
      uVar2 = (uint)*(byte *)((int)&CSWTCH_256 + (uint)(byte)(bVar1 - 8));
    }
    else {
      uVar2 = 0;
      if ((bVar1 < 0x18) && (uVar2 = (uint)(byte)(bVar1 - 0x10), (rate & 3) == 3)) {
        uVar2 = (uint)(byte)(bVar1 - 8);
      }
    }
  }
  return phy_chan_target_power[uVar2];
}



// WARNING: Removing unreachable block (ram,0x00044670)
// WARNING: Removing unreachable block (ram,0x00044673)
// WARNING: Removing unreachable block (ram,0x00044681)
// WARNING: Removing unreachable block (ram,0x00044695)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void get_chan_pwr_index(void)

{
  phy_chan_pwr_index[0] = chip7_phy_init_ctrl.ratepwr_offset[0];
  memw();
  if (chip7_phy_init_ctrl.ratepwr_offset[0] < phy_set_most_tpw_index) {
    phy_chan_pwr_index[0] = phy_set_most_tpw_index;
    memw();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void write_wifi_dig_gain(S8 *gain_table)

{
  memw();
  _DAT_3ff46004 = *(undefined4 *)gain_table;
  memw();
  _DAT_3ff46008 = *(undefined4 *)(gain_table + 4);
  return;
}



// WARNING: Removing unreachable block (ram,0x0004479a)
// WARNING: Removing unreachable block (ram,0x000447b9)
// WARNING: Removing unreachable block (ram,0x000447c3)
// WARNING: Unknown calling convention

void correct_rf_ana_gain_new(sint16 *correct_qdb,U16 *pa_gain,U16 *bb_gain,bool bt_mode)

{
  short in_a6;
  sint16 sVar1;
  sint16 gain_dt_tab [17];
  uint8 pa_gain_tab [17];
  
  memcpy(pa_gain_tab,&DAT_000528fc,0x11);
  memcpy(gain_dt_tab,&DAT_00052910,0x22);
  if ((ushort)pa_gain_tab[0] == *pa_gain) {
    in_a6 = gain_dt_tab[0];
  }
  sVar1 = gain_dt_tab[0] - in_a6;
  memw();
  if (sVar1 < *correct_qdb) {
    *correct_qdb = sVar1;
    *pa_gain = (ushort)pa_gain_tab[0];
    memw();
    if (bt_mode) {
      return;
    }
    if (8 < (int)*correct_qdb - (int)sVar1) {
      *bb_gain = 0x30;
      *correct_qdb = sVar1 + 8;
      memw();
      return;
    }
  }
  else {
    *correct_qdb = gain_dt_tab[0xf];
    *pa_gain = (ushort)pa_gain_tab[0xf];
    memw();
    sVar1 = gain_dt_tab[0xf];
    if (bt_mode) {
      return;
    }
  }
  *bb_gain = 0x120;
  *correct_qdb = sVar1;
  memw();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void tx_gain_table_set(void)

{
  char cVar1;
  short sVar2;
  s32 sVar3;
  sint8 *psVar4;
  sint8 *psVar5;
  sint8 gain_table [8];
  uint16 pa_ana_gain [2];
  sint16 correct_qdb;
  
  psVar5 = gain_table;
  sVar2 = chip7_sleep_params.loop_pwctrl_correct_power_qdb -
          chip7_sleep_params.loop_pwctrl_correct_atten;
  correct_qdb = sVar2 + phy_chan_gain_table[5] + 0x14;
  pa_ana_gain[0] = tx_rf_ana_gain[0];
  pa_ana_gain[1] = tx_rf_ana_gain[1];
  memw();
  correct_rf_ana_gain_new(&correct_qdb,pa_ana_gain,pa_ana_gain + 1,false);
  psVar4 = phy_chan_gain_table;
  sVar2 = sVar2 - correct_qdb;
  do {
    cVar1 = *psVar4;
    psVar4 = (sint8 *)((int)psVar4 + 1);
    sVar3 = (*g_phyFuns->get_data_sat_)((int)(short)(sVar2 + cVar1),0x1e,-0x7f);
    *psVar5 = (char)sVar3;
    memw();
    psVar5 = psVar5 + 1;
  } while ((u32 *)psVar4 != RX_aplenbk);
  if (force_tx_gain_en == false) {
    force_txrx_off(true);
    set_tx_gain_table(pa_ana_gain[0],pa_ana_gain[1]);
    write_wifi_dig_gain(gain_table);
    force_txrx_off(false);
  }
  return;
}



// WARNING: Unknown calling convention

uint8 set_chan_dig_gain(uint8 chan)

{
  sint8 sVar1;
  sint8 *psVar2;
  char *pcVar3;
  uint8 *puVar4;
  int iVar5;
  int iVar6;
  byte bVar7;
  sint8 *psVar8;
  byte bVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  uint8 uVar13;
  sint8 org_gain_table [6];
  U8 target_power [6];
  sint8 chan_data [4];
  uint8 fcc_index_all_20m [3];
  uint8 fcc_index_all [3];
  
  get_phy_target_power(target_power,(short)phy_in_vdd33_offset);
  iVar6 = 0;
  do {
    psVar8 = chan_data;
    psVar2 = chip7_sleep_params.tx_pwctrl_atten + iVar6;
    iVar5 = 4;
    do {
      sVar1 = *psVar2;
      psVar2 = psVar2 + 6;
      *psVar8 = sVar1;
      memw();
      psVar8 = psVar8 + 1;
      iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    sVar1 = (*g_phyFuns->set_chan_cal_interp_)(chan_data,chan);
    pcVar3 = phy_chan_gain_table + iVar6;
    org_gain_table[iVar6] = -sVar1;
    iVar6 = iVar6 + 1;
    *pcVar3 = -sVar1;
    memw();
  } while (iVar6 != 6);
  get_chan_pwr_index();
  phy_chan_gain_table[6] = phy_chan_gain_table[5];
  memw();
  phy_chan_gain_table[7] = phy_chan_gain_table[phy_chan_pwr_index[0x10]] + '\x06';
  memw();
  phy_chan_target_power[0] = target_power[phy_chan_pwr_index[0]];
  memw();
  if (1 < (byte)(chip7_phy_init_ctrl.fcc_enable - 2)) goto LAB_00044b5b;
  get_rate_fcc_index(chan,fcc_index_all);
  if (((byte)(chan - 3) < 2) && (chip7_sleep_params.phy_sub_chan_cfg == '\x02')) {
    uVar13 = chan + 0xfe;
LAB_000449c1:
    get_rate_fcc_index(uVar13,fcc_index_all_20m);
    fcc_index_all[0] = fcc_index_all_20m[0];
    memw();
    fcc_index_all[1] = fcc_index_all_20m[1];
    memw();
  }
  else if (((byte)(chan - 10) < 2) &&
          (uVar13 = chan + '\x02', chip7_sleep_params.phy_sub_chan_cfg == '\x03'))
  goto LAB_000449c1;
  puVar4 = phy_chan_pwr_index;
  iVar6 = 0;
  bVar7 = 0;
  iVar5 = 0x11;
  uVar10 = (uint)fcc_index_all[1];
  do {
    bVar9 = fcc_index_all[0];
    if ((7 < bVar7) && (bVar9 = fcc_index_all[2], bVar7 == 0x10)) {
      if (*puVar4 < uVar10) {
        bVar9 = fcc_index_all[1];
        if (uVar10 < 6) {
          uVar13 = target_power[uVar10];
          phy_chan_pwr_index[iVar6] = fcc_index_all[1];
          phy_chan_target_power[iVar6] = uVar13;
          memw();
          uVar11 = uVar10;
LAB_00044a69:
          phy_chan_gain_table[7] = org_gain_table[uVar11] + '\x06';
          memw();
        }
        else {
LAB_00044b19:
          phy_chan_gain_table[7] = org_gain_table[5] + '\x06' + (bVar9 - 5) * -4;
          phy_chan_target_power[iVar6] = target_power[5] + (bVar9 - 5) * -4;
          memw();
        }
      }
      break;
    }
    uVar11 = (uint)bVar9;
    if (*puVar4 < uVar11) {
      if (uVar11 < 6) {
        phy_chan_target_power[iVar6] = target_power[uVar11];
        phy_chan_pwr_index[iVar6] = bVar9;
        memw();
        if (bVar7 == 0x10) goto LAB_00044a69;
      }
      else {
        if (bVar7 < 8) {
          phy_chan_pwr_index[iVar6] = '\x05';
          memw();
          iVar12 = 5;
          phy_chan_target_power[iVar6] = target_power[5] + (bVar9 - 5) * -4;
          memw();
        }
        else {
          if (bVar7 == 0x10) goto LAB_00044b19;
          phy_chan_pwr_index[iVar6] = '\x06';
          memw();
          iVar12 = 6;
          phy_chan_target_power[iVar6] = target_power[5] + (bVar9 - 5) * -4;
        }
        phy_chan_gain_table[iVar12] = org_gain_table[5] + (bVar9 - 5) * -4;
        memw();
      }
    }
    if (((byte)(bVar7 - 8) < 8) && (phy_chan_pwr_index[iVar6] == '\x05')) {
      phy_chan_pwr_index[iVar6] = '\x06';
      memw();
    }
    bVar7 = bVar7 + 1;
    iVar6 = iVar6 + 1;
    puVar4 = puVar4 + 1;
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
LAB_00044b5b:
  write_txrate_power_offset(true);
  tx_gain_table_set();
  return '\0';
}



// WARNING: Restarted to delay deadcode elimination for space: ram
// WARNING: Unknown calling convention

void tx_pwctrl_cal(U8 *target_power,U8 *ratepw_offset,S16 *pwdet_error_accum,bool correct_en,
                  bool print_en)

{
  uint8 uVar1;
  bool bVar2;
  uint16 uVar3;
  uint16 uVar4;
  byte bVar5;
  uint8 tsen_meas;
  S16 SVar6;
  sint16 sVar7;
  char extraout_var;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  short sVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  uint uStack_40;
  
  uVar8 = esp_dport_access_reg_read(&DAT_3ff4e060);
  uStack_40 = uVar8 >> 0x18 & 0x7f;
  SVar6 = (*g_phyFuns->get_sar_dout_)(pwrdet_offset);
  uVar9 = uStack_40 >> 2;
  uVar8 = uVar8 >> 0x18 & 3;
  if (uVar9 < 8) {
    phy_tx_power_out = SVar6 + -8;
    uVar10 = 0x10;
    memw();
  }
  else {
    if ((0x17 < uVar9) || (sVar11 = -2, uVar8 != 3)) {
      sVar11 = 0;
    }
    phy_tx_power_out = SVar6 - sVar11;
    memw();
    if ((lr_enable == false) || (1 < (uVar9 - 9 & 0xff))) {
      if (uVar9 < 0x10) {
        uVar10 = (uint)*(byte *)((int)&CSWTCH_256 + (uVar9 - 8 & 0xff));
      }
      else {
        uVar10 = 0;
        if ((uVar9 < 0x18) && (uVar10 = uVar9 - 0x10 & 0xff, uVar8 == 3)) {
          uVar10 = uVar9 - 8 & 0xff;
        }
      }
    }
    else {
      uVar10 = 0x10;
      uStack_40 = 0;
    }
  }
  uVar1 = phy_chan_target_power[uVar10];
  phy_tx_pwr_error = phy_tx_power_out + (char)uVar1 * -4;
  iVar12 = (int)phy_tx_pwr_error;
  memw();
  if ((char)uVar1 < 0x20) {
    uVar8 = 0;
    if (tx_pwctrl_track_num < 4) {
      bVar2 = true;
      goto LAB_00044cd2;
    }
LAB_00044c88:
    bVar5 = (*g_phyFuns->get_pwctrl_correct_)((S16)uVar8,pwdet_error_accum,'\x04','\x01');
    uVar8 = (uint)bVar5;
    if ((char)bVar5 < '\x01') {
      bVar2 = bVar5 == 0;
      goto LAB_00044cd2;
    }
LAB_00044ca9:
    if (chip7_sleep_params.loop_pwctrl_correct_power_qdb < '\x14') goto LAB_00044d43;
    if (0x130 < phy_tx_power_out) goto LAB_00044cf2;
  }
  else {
    iVar12 = (uint)(iVar12 < -0x20) * -0x20 + (uint)(iVar12 >= -0x20) * iVar12;
    uVar8 = (uint)(iVar12 < 0x20) * iVar12 + (uint)(iVar12 >= 0x20) * 0x20;
    if (3 < tx_pwctrl_track_num) goto LAB_00044c88;
    if ((int)uVar8 < 1) {
      if (-0x11 < (int)uVar8) {
        bVar2 = true;
        uVar8 = 0;
        goto LAB_00044cd2;
      }
      bVar5 = -(char)((int)(uVar8 - ((int)uVar8 >> 2)) >> 2);
      goto LAB_00044ca9;
    }
    uVar10 = -((int)(((int)uVar8 >> 2) + uVar8) >> 2);
    uVar8 = uVar10 & 0xff;
    bVar2 = (char)uVar10 == '\0';
LAB_00044cd2:
    bVar5 = (byte)uVar8;
    if ((phy_tx_power_out < 0x131) || (!bVar2)) {
      correct_en = bVar5 != 0 && correct_en;
      goto LAB_00044d43;
    }
LAB_00044cf2:
    tsen_meas = tsens_code_read();
    sVar7 = get_temp_cal(btpwr_tsen_init,tsen_meas);
    if (-sVar7 < 0) {
      iVar12 = (int)-sVar7 - (int)chip7_sleep_params.loop_pwctrl_correct_power_qdb;
      bVar5 = (byte)(iVar12 >> 0x1f);
      correct_en = iVar12 < 0 && correct_en;
      goto LAB_00044d43;
    }
  }
  correct_en = false;
  bVar5 = 0;
LAB_00044d43:
  uVar4 = tx_rf_ana_gain[1];
  uVar3 = tx_rf_ana_gain[0];
  if (print_en) {
    iVar13 = (int)chip7_sleep_params.loop_pwctrl_correct_power_qdb;
    iVar14 = (int)chip7_sleep_params.phy_channel_num;
    iVar15 = (int)phy_tx_power_out;
    iVar16 = (int)phy_tx_pwr_error;
    sVar11 = *pwdet_error_accum;
    iVar12 = (int)chip7_sleep_params.loop_pwctrl_correct_atten;
    esp_dport_access_reg_read(&DAT_3ff46008);
    phy_printf("1,target_power,%d, %d, p_error,%d, correct_v,%d, error_accum, %d, tot_p,%d, coatt,%d, rf_g,%x,%x, txq_rate,%d, %d, chan,%d, rate_att,%d\n"
               ,(int)(char)uVar1,iVar15,iVar16,(int)(char)bVar5,(int)sVar11,iVar13,iVar12,uVar3,
               uVar4,uStack_40,uVar9,iVar14,-(int)extraout_var);
    if (correct_en) {
      chip7_sleep_params.loop_pwctrl_correct_power_qdb =
           bVar5 + chip7_sleep_params.loop_pwctrl_correct_power_qdb;
      chip7_sleep_params.loop_pwctrl_power_qdb_docal =
           bVar5 + chip7_sleep_params.loop_pwctrl_power_qdb_docal;
      memw();
      tx_gain_table_set();
      phy_printf("T:%d,0x%x,0x%x,%d\n",(int)chip7_sleep_params.loop_pwctrl_correct_power_qdb,
                 tx_rf_ana_gain[0],tx_rf_ana_gain[1],
                 (int)chip7_sleep_params.loop_pwctrl_correct_atten);
    }
  }
  else if (correct_en) {
    chip7_sleep_params.loop_pwctrl_correct_power_qdb =
         bVar5 + chip7_sleep_params.loop_pwctrl_correct_power_qdb;
    chip7_sleep_params.loop_pwctrl_power_qdb_docal =
         bVar5 + chip7_sleep_params.loop_pwctrl_power_qdb_docal;
    memw();
    tx_gain_table_set();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void tx_pwctrl_background(bool correct_en,bool print_en)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  CriticalType crit_level;
  U8 target_power [6];
  
  uVar1 = phy_enter_critical();
  if ((phy_set_most_tpw_disbg == false) && (phy_dis_pwdet_one == false)) {
    iVar2 = esp_dport_access_reg_read(&DAT_3ff4e050);
    if ((((iVar2 < 0) || (phy_pwdet_onetime_flag != true)) &&
        (uVar3 = esp_dport_access_reg_read(&DAT_3ff4e050), (uVar3 & 1) == 0)) ||
       (uVar3 = esp_dport_access_reg_read(&DAT_3ff4e050), (uVar3 >> 0x18 & 7) != 0)) {
      phy_tx_power_out = 0;
      memw();
    }
    else {
      get_phy_target_power(target_power,(short)phy_in_vdd33_offset);
      tx_pwctrl_cal(target_power,chip7_phy_init_ctrl.ratepwr_offset,
                    &chip7_sleep_params.loop_pwctrl_pwdet_error_accum,correct_en,print_en);
      if (tx_pwctrl_track_num < 0x14) {
        tx_pwctrl_track_num = tx_pwctrl_track_num + '\x01';
        memw();
      }
    }
  }
  if (phy_pwdet_onetime_flag == true) {
    iVar2 = esp_dport_access_reg_read(&DAT_3ff4e050);
    if (-1 < iVar2) {
      phy_pwdet_onetime_flag = false;
      memw();
    }
  }
  else {
    uVar3 = esp_dport_access_reg_read();
    if ((uVar3 & 1) == 0) {
      phy_pwdet_onetime_en();
    }
  }
  if (phy_dis_pwdet_one != false) {
    phy_dis_pwdet_one = false;
    memw();
  }
  wifi_track_pll_cap();
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Unknown calling convention

U8 ram_get_rf_gain_qdb(U8 rf_gain_ind)

{
  U8 UVar1;
  uint uVar2;
  
  uVar2 = rf_gain_ind - 1 & 0xff;
  UVar1 = '\x05';
  if (uVar2 < 6) {
    UVar1 = *(U8 *)((int)&CSWTCH_254 + uVar2);
  }
  return UVar1;
}



// WARNING: Unknown calling convention

uint8 wifi_11g_rate_chg(uint8 rate_11g)

{
  uint8 uVar1;
  uint uVar2;
  
  uVar2 = rate_11g - 8 & 0xff;
  uVar1 = '\0';
  if (uVar2 < 8) {
    uVar1 = *(uint8 *)((int)&CSWTCH_256 + uVar2);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void ram_set_txcap_reg(U8 *para_txcap,uint8 chan)

{
  U8 UVar1;
  int iVar2;
  U8 *pUVar3;
  U8 *pUVar4;
  sint8 *psVar5;
  U8 *pUVar6;
  sint8 chan_data [4];
  sint8 data [3];
  
  psVar5 = data;
  pUVar6 = para_txcap + 3;
  do {
    iVar2 = 4;
    pUVar3 = para_txcap;
    pUVar4 = (U8 *)chan_data;
    do {
      UVar1 = *pUVar3;
      pUVar3 = pUVar3 + 3;
      *pUVar4 = UVar1;
      memw();
      pUVar4 = pUVar4 + 1;
      iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
    para_txcap = para_txcap + 1;
    *psVar5 = chan_data[chan >> 2];
    memw();
    psVar5 = psVar5 + 1;
  } while (para_txcap != pUVar6);
  (*g_phyFuns->i2c_writeReg_)('k','\x02','\x01',data[0] | 0x60);
  (*g_phyFuns->i2c_writeReg_)('k','\x02','\x02',(byte)(((int)data[2] & 0xfU) << 4) | data[1]);
  return;
}



// WARNING: Unknown calling convention

uint32 get_i2c_read_mask(uint8 block)

{
  uint32 uVar1;
  uint uVar2;
  
  uVar2 = block - 0x62 & 0xff;
  uVar1 = 0;
  if (uVar2 < 0xc) {
    uVar1 = *(uint32 *)(CSWTCH_133 + uVar2 * 4);
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

sint8 pll_correct_dcap(uint8 freq,u8 *pll_cap_ext,bool wifi_chan_en)

{
  uint8 uVar1;
  byte bVar2;
  sint8 sVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  
  uVar1 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\0','\a','\a');
  if (uVar1 == '\0') {
    return '\0';
  }
  bVar2 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\x05','\a','\0');
  if ((bVar2 & 2) == 0) {
    iVar6 = 1;
    sVar3 = '\x01';
    if ((bVar2 & 1) == 0) {
      return '\0';
    }
  }
  else {
    iVar6 = 0xff;
    sVar3 = -1;
  }
  uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = uVar4 & 0xffffff00 | (uint)freq * 3 & 0xff;
  memw();
  uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0c0);
  uVar5 = uVar4 + iVar6 & 0xff;
  _DAT_3ff4e148 = uVar4 & 0xffff00 | uVar5 | (iVar6 + (uVar4 >> 0x18)) * 0x1000000;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x200;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffdff;
  memw();
  *pll_cap_ext = (u8)(uVar4 + iVar6);
  memw();
  if (!wifi_chan_en) {
    return sVar3;
  }
  uVar4 = esp_dport_access_reg_read(&DAT_3ff4e130);
  memw();
  _DAT_3ff4e130 = uVar4 & 0xffff00ff | uVar5 << 8;
  return sVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bb_rst_en_set(bool en)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5d03c);
  _DAT_3ff5d03c = (en & 1) << 0x1e | uVar1 & 0xbfffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5d040);
  memw();
  _DAT_3ff5d040 = uVar1 & 0x7fffffff | (uint)en << 0x1f;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_dis_hw_set_freq(void)

{
  int iVar1;
  uint uVar2;
  uint32_t val;
  
  do {
    iVar1 = esp_dport_access_reg_read(&DAT_3ff4e168);
    if (-1 < iVar1) break;
    uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  } while ((uVar2 & 0x100) == 0);
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x2000000;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
  memw();
  ets_delay_us(2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_force_wifi_chan(void)

{
  undefined4 uVar1;
  uint uVar2;
  int iVar3;
  u32 t0;
  CriticalType crit_level;
  
  uVar1 = phy_enter_critical();
  phy_force_wifi_chan_en = true;
  memw();
  force_hw_set_freq_flag = true;
  memw();
  bb_rst_en_set(true);
  _DAT_3ff51040 = esp_dport_access_reg_read(&DAT_3ff51040);
  iVar3 = _DAT_60033c00;
  _DAT_3ff51040 = _DAT_3ff51040 & 0xfffffffe;
  memw();
  memw();
  do {
    uVar2 = esp_dport_access_reg_read(0x3ff5d008);
    if ((uVar2 & 0x20000000) == 0) {
      phy_dis_hw_set_freq();
      goto LAB_00045342;
    }
    memw();
  } while ((uint)(_DAT_60033c00 - iVar3) < 0x65);
  phy_dis_hw_set_freq();
  if (phy_sw_set_chan_en == false) {
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
    memw();
    uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = uVar2 & 0xe7ffffff | 0x10000000;
    memw();
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x100;
    memw();
    do {
      iVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      if (iVar3 < 0) break;
      uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    } while ((uVar2 & 0x100) != 0);
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
    memw();
  }
LAB_00045342:
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_en_hw_set_freq(void)

{
  uint uVar1;
  
  if (!force_hw_set_freq_flag) {
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
    memw();
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c07c);
  memw();
  _DAT_3ff5c07c = uVar1 & 0xff00ffff | 0x9c0000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint8 ram_chip_i2c_readReg(uint8 block,uint8 host_id,uint8 reg_add)

{
  uint8 extraout_var;
  undefined4 uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  CriticalType crit_level;
  uint uVar5;
  
  uVar2 = (uint)host_id;
  uVar1 = phy_enter_critical();
  if ((phy_init_flag == false) && (uVar2 < 2)) {
    phy_dis_hw_set_freq();
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
    memw();
  }
  uVar4 = block - 0x62 & 0xff;
  uVar5 = 0xffffffff;
  if (uVar4 < 0xc) {
    uVar5 = *(uint *)(CSWTCH_133 + uVar4 * 4) ^ 0xffffffff;
  }
  uVar4 = esp_dport_access_reg_read(&DAT_3ff4e044);
  _DAT_3ff4e044 = uVar4 & 0xfffc00ff | 0x3f000;
  memw();
  _DAT_3ff4e044 = esp_dport_access_reg_read(&DAT_3ff4e044);
  _DAT_3ff4e044 = _DAT_3ff4e044 & uVar5;
  puVar3 = (uint *)((uVar2 + 0xffd3800) * 4);
  memw();
  do {
    uVar4 = esp_dport_access_reg_read(puVar3);
  } while ((uVar4 & 0x2000000) != 0);
  memw();
  *puVar3 = (uint)CONCAT11(reg_add,block);
  do {
    uVar4 = esp_dport_access_reg_read(puVar3);
  } while ((uVar4 & 0x2000000) != 0);
  esp_dport_access_reg_read(puVar3);
  if ((phy_init_flag == false) && (uVar2 < 2)) {
    phy_en_hw_set_freq();
  }
  phy_exit_critical(uVar1);
  return extraout_var;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_chip_i2c_writeReg(uint8 block,uint8 host_id,uint8 reg_add,uint8 pData)

{
  undefined4 uVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  CriticalType crit_level;
  
  uVar3 = (uint)host_id;
  uVar1 = phy_enter_critical();
  if ((phy_init_flag == false) && (uVar3 < 2)) {
    phy_dis_hw_set_freq();
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
    memw();
  }
  puVar4 = (uint *)((uVar3 + 0xffd3800) * 4);
  do {
    uVar2 = esp_dport_access_reg_read(puVar4);
  } while ((uVar2 & 0x2000000) != 0);
  memw();
  *puVar4 = (uint)reg_add << 8 | block | 0x1000000 | (uint)pData << 0x10;
  do {
    uVar2 = esp_dport_access_reg_read(puVar4);
  } while ((uVar2 & 0x2000000) != 0);
  if ((phy_init_flag == false) && (uVar3 < 2)) {
    phy_en_hw_set_freq();
  }
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_unforce_wifi_chan(void)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  CriticalType crit_level;
  
  uVar1 = phy_enter_critical();
  phy_force_wifi_chan_en = false;
  memw();
  force_hw_set_freq_flag = false;
  memw();
  bb_rst_en_set(false);
  if (phy_sw_set_chan_en == false) {
    do {
      iVar2 = esp_dport_access_reg_read(&DAT_3ff4e168);
      if (-1 < iVar2) break;
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    } while ((uVar3 & 0x100) == 0);
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xe7ffffff;
    memw();
  }
  phy_en_hw_set_freq();
  _DAT_3ff51040 = esp_dport_access_reg_read(&DAT_3ff51040);
  _DAT_3ff51040 = _DAT_3ff51040 | 1;
  memw();
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void wifi_track_pll_cap(void)

{
  sint8 sVar1;
  CriticalType crit_level;
  undefined4 uVar2;
  uint uVar3;
  uint8 freq;
  u8 pll_cap_ext;
  
  uVar2 = phy_enter_critical();
  pll_cap_ext = '\0';
  memw();
  if (((phy_wifi_pll_track_en != false) &&
      (uVar3 = esp_dport_access_reg_read(0x3ff5d008), (uVar3 & 0x20000000) == 0)) &&
     (phy_sw_set_chan_en == false)) {
    freq = 'T';
    if (chip7_sleep_params.phy_channel_num < '\x0e') {
      freq = chip7_sleep_params.phy_channel_num * '\x05' + '\a';
    }
    phy_dis_hw_set_freq();
    sVar1 = pll_correct_dcap(freq,&pll_cap_ext,true);
    if ((sVar1 != '\0') && (pll_cap_ext != '\0')) {
      (*g_phyFuns->i2c_writeReg_)('b','\x01','\x01',pll_cap_ext);
    }
    if (phy_force_wifi_chan_en == false) {
      phy_en_hw_set_freq();
    }
  }
  phy_exit_critical(uVar2);
  return;
}



// WARNING: Unknown calling convention

uint16 phy_get_fetx_delay(void)

{
  uint16 uVar1;
  uint uVar2;
  
  uVar2 = esp_dport_access_reg_read(&DAT_3ff450d0);
  uVar1 = 0x28;
  if ((uVar2 & 0x40000000) != 0) {
    uVar1 = 0;
  }
  return uVar1;
}



// WARNING: Unknown calling convention

sint16 get_temp_cal(u8 tsen_init,u8 tsen_meas)

{
  int iVar1;
  short sVar2;
  
  iVar1 = (int)((uint)tsen_init - (uint)tsen_meas) / 7;
  sVar2 = 0x18;
  if (iVar1 < 0x19) {
    sVar2 = (short)iVar1;
    sVar2 = (ushort)(sVar2 < -0x18) * -0x18 + (ushort)(sVar2 >= -0x18) * sVar2;
  }
  return sVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

sint8 btpwr_pll_track(uint8 freq,sint8 pll_cap_delta)

{
  char cVar1;
  s8 sVar2;
  uint uVar3;
  char extraout_var;
  int iVar4;
  int iVar5;
  
  if (bt_pwr_freq_old != freq) {
    uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = uVar3 & 0xffffff00 | (uint)(byte)(freq * '\x03');
    memw();
    esp_dport_access_reg_read(&DAT_3ff4e0c0);
    bt_pwr_track_num = bt_pwr_track_num + '\x01';
    bt_pwr_cap_sum = extraout_var + bt_pwr_cap_sum;
    memw();
    bt_pwr_freq_old = freq;
  }
  if (bt_pwr_track_num < 0x10) {
    return btpwr_atten_offset;
  }
  iVar5 = bt_pwr_cap_sum + 8 >> 4;
  iVar4 = (int)(short)iVar5;
  sVar2 = btpwr_atten_offset;
  if (bt_pwr_cap_sum_old != iVar4) {
    bt_pwr_cap_sum_old = (sint8)iVar5;
    if (iVar4 < 2) {
      sVar2 = '\0';
      if (-2 < iVar4) goto LAB_000457ac;
      cVar1 = bt_pwr_cap_sum_old * '\x06';
    }
    else {
      cVar1 = (char)(iVar5 << 3);
    }
    sVar2 = '\x18';
    if (cVar1 < '\x19') {
      sVar2 = (cVar1 < -0x12) * -0x12 + (cVar1 >= -0x12) * cVar1;
    }
  }
LAB_000457ac:
  memw();
  bt_pwr_cap_sum = 0;
  bt_pwr_track_num = '\0';
  return sVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_bt_ifs_set(void)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff450d0);
  uVar2 = 0x1ea000;
  if ((uVar1 & 0x40000000) != 0) {
    uVar2 = 0x1fe000;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5103c);
  memw();
  _DAT_3ff5103c = uVar1 & 0xffe007ff | uVar2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint8 tsens_code_read(void)

{
  uint uVar1;
  uint uVar2;
  uint32_t val;
  
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c | 0x4000000;
  memw();
  ets_delay_us(1);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff48844);
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c & 0xfbffffff;
  memw();
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c & 0xfeffffff;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4884c);
  memw();
  _DAT_3ff4884c = uVar2 | 0x1000000;
  return (uint8)((uVar1 & 0x3fc00000) >> 0x16);
}



// WARNING: Unknown calling convention

sint16 btpwr_tsens_track(void)

{
  int iVar1;
  byte bVar2;
  short sVar3;
  uint8 temp;
  
  bVar2 = tsens_code_read();
  btpwr_tsen_flag = '\x01';
  memw();
  if ((((uint)bVar2 - (uint)btpwr_tsen_old) + 5 & 0xffff) < 0xb) {
    sVar3 = 0x18;
    if (btpwr_atten_offset < '\x19') {
      sVar3 = (ushort)(btpwr_atten_offset < -0x18) * -0x18 +
              (ushort)(btpwr_atten_offset >= -0x18) * (short)btpwr_atten_offset;
    }
  }
  else {
    sVar3 = 0x18;
    iVar1 = (int)((uint)btpwr_tsen_init - (uint)bVar2) / 7;
    btpwr_tsen_old = bVar2;
    memw();
    if (iVar1 < 0x19) {
      sVar3 = (short)iVar1;
      return (ushort)(sVar3 < -0x18) * -0x18 + (ushort)(sVar3 >= -0x18) * sVar3;
    }
  }
  return sVar3;
}



// WARNING: Unknown calling convention

void bt_track_tx_power(uint8 freq,sint8 cap_delta)

{
  byte bVar1;
  ushort uVar2;
  
  uVar2 = btpwr_tsens_track();
  uVar2 = uVar2 & 0xff;
  if ((cap_delta != '\0') && (btpwr_tsen_flag == '\0')) {
    bVar1 = btpwr_pll_track(freq,cap_delta);
    uVar2 = (ushort)bVar1;
  }
  if ((byte)btpwr_atten_offset != uVar2) {
    btpwr_atten_offset = (s8)uVar2;
    memw();
    bt_tx_gain_cal_set();
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_track_pll_cap(void)

{
  sint8 cap_delta;
  CriticalType crit_level;
  undefined4 uVar1;
  uint uVar2;
  byte extraout_var;
  u8 pll_cap_ext;
  
  uVar1 = phy_enter_critical();
  if ((((phy_bt_pll_track_en != false) &&
       (uVar2 = esp_dport_access_reg_read(0x3ff5d008), (uVar2 & 0x20000000) != 0)) &&
      (phy_force_wifi_chan_en == false)) && (phy_sw_set_chan_en == false)) {
    esp_dport_access_reg_read(&DAT_3ff4e168);
    phy_dis_hw_set_freq();
    cap_delta = pll_correct_dcap(extraout_var & 0x7f,&pll_cap_ext,false);
    if (phy_bt_power_track_en != false) {
      bt_track_tx_power(extraout_var & 0x7f,cap_delta);
    }
    phy_en_hw_set_freq();
  }
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Unknown calling convention

uint16 chan_to_freq(int8 channel)

{
  uint16 uVar1;
  
  if ((channel != '\0') && (channel < '\x0f')) {
    uVar1 = 0x9b4;
    if (channel != '\x0e') {
      uVar1 = (channel + -1) * 5 + 0x96c;
    }
    return uVar1;
  }
  phy_printf("set_chan error! %d\n");
  return 0x96c;
}



// WARNING: Unknown calling convention

void get_i2c_write_data(uint8 index,uint8 block,uint8 host_id,uint8 reg_add,uint8 pData,
                       uint8 *block_m,uint8 *host_id_m,uint8 *reg_add_m,uint8 *pData_m)

{
  host_id_m[index] = host_id;
  memw();
  reg_add_m[index] = reg_add;
  block_m[index] = block;
  pData_m[index] = pData;
  memw();
  return;
}



// WARNING: Unknown calling convention

void i2c_write_master(uint8 *block,uint8 *host_id,uint8 *reg_add,uint8 *pData,uint8 num)

{
  byte bVar1;
  byte *pbVar2;
  uint8 *puVar3;
  ulonglong uVar4;
  
  if (num != '\0') {
    pbVar2 = host_id + (num - 1 & 0xff) + 1;
    puVar3 = host_id + 1;
    memw();
    *(uint *)((*host_id + 0xffd3800) * 4) =
         *block | 0x1000000 | (uint)*pData << 0x10 | (uint)*reg_add << 8;
    do {
      bVar1 = *host_id;
      do {
        uVar4 = esp_dport_access_reg_read((bVar1 + 0xffd3800) * 4,puVar3);
        puVar3 = (uint8 *)(uVar4 >> 0x20);
      } while ((uVar4 & 0x2000000) != 0);
      host_id = host_id + 1;
    } while (pbVar2 != host_id);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_pbus_debugmode(void)

{
  uint uVar1;
  
  (*g_phyFuns->pbus_force_mode_)(true);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46094);
  if ((uVar1 & 1) == 0) {
    phy_printf("debug mode FAIL\n");
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_pbus_force_test(u8 pbus_no,u8 bus_en,u16 config_data)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46094);
  _DAT_3ff46094 =
       ((uint)config_data << 6 | (uint)pbus_no << 2 | (uint)bus_en << 0xf) & 0x1fffc | 2 |
       uVar1 & 0xfffe0001;
  memw();
  do {
    iVar2 = esp_dport_access_reg_read(&DAT_3ff460a0);
  } while (iVar2 < 0);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46094);
  memw();
  _DAT_3ff46094 = uVar1 & 0xfffffffd;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void force_txrxoff(bool off_en)

{
  uint uVar1;
  
  if (off_en) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = uVar1 & 0xffffcfff | 0x2000;
    memw();
    ets_delay_us(1);
    uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = uVar1 & 0xfffff3ff | 0x800;
    memw();
    ets_delay_us(1);
    uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = uVar1 & 0xfffffcff | 0x200;
    memw();
    ets_delay_us(1);
    return;
  }
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 & 0xfffff3ff;
  memw();
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 & 0xfffffcff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
  memw();
  _DAT_3ff460a0 = uVar1 & 0xffffcfff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_bb_bss_cbw40_dig(int cbw40)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff00024);
  memw();
  _DAT_3ff00024 = (cbw40 & 1U) << 2 | uVar1 & 0xfffffff3;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_set_pbus_mem(void)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint *puVar5;
  uint uVar6;
  int iVar7;
  uint *puVar8;
  uint table_txon_bt [5];
  uint table_txon [5];
  uint table_rxon_bt [4];
  uint table_rxon [4];
  uint table_txoff_bt [3];
  uint table_rxoff_bt [3];
  uint table_txoff [3];
  uint table_rxoff [3];
  uint table_paoff [2];
  uint table_paon [2];
  int iStack_40;
  uint uStack_38;
  
  table_rxon[0] = 0x709ff;
  table_rxon[1] = 0x1713ff;
  table_rxon[2] = 0xf50000;
  table_rxon[3] = 0xf60000;
  table_rxoff[0] = (uint)&DAT_000401ff;
  table_rxoff[2] = 0x1801ff;
  table_rxoff[1] = 0x1401ff;
  memcpy(table_txon,&DAT_00052828,0x14);
  table_rxon_bt[0] = 0x709ff;
  table_rxon_bt[3] = 0xf60000;
  table_txoff[0] = (uint)&DAT_000401ff;
  table_txoff[2] = 0x1801ff;
  table_rxon_bt[1] = 0x1717ff;
  table_rxoff_bt[0] = (uint)&DAT_000401ff;
  table_rxoff_bt[2] = 0x1801ff;
  table_txoff[1] = 0x1401ff;
  table_paon[0] = 0x44ffff;
  table_paon[1] = 0xf30000;
  table_paoff[0] = 0x4401ff;
  table_paoff[1] = 0x5401ff;
  table_rxon_bt[2] = 0xf50000;
  table_rxoff_bt[1] = 0x1401ff;
  memcpy(table_txon_bt,&DAT_0005285c,0x14);
  table_txoff_bt[0] = (uint)&DAT_000401ff;
  table_txoff_bt[2] = 0x1801ff;
  iStack_40 = 0;
  table_txoff_bt[1] = 0x1401ff;
  uVar4 = 0;
  do {
    switch(iStack_40) {
    case 0:
      puVar5 = table_rxon;
      iVar7 = 4;
      uStack_38 = 0xffff0000;
      iVar1 = 0;
      puVar8 = (uint *)&DAT_3ff46030;
      break;
    case 1:
      iVar7 = 3;
      iVar1 = 0x10;
      puVar8 = (uint *)&DAT_3ff46030;
      uStack_38 = 0xffff;
      puVar5 = table_rxoff;
      break;
    case 2:
      iVar7 = 5;
      iVar1 = 0;
      uStack_38 = 0xffff0000;
      puVar5 = table_txon;
      puVar8 = (uint *)&DAT_3ff46034;
      break;
    case 3:
      puVar5 = table_txoff;
      iVar7 = 3;
      iVar1 = 0x10;
      uStack_38 = 0xffff;
      puVar8 = (uint *)&DAT_3ff46034;
      break;
    case 4:
      puVar5 = table_paon;
      iVar7 = 2;
      iVar1 = 0;
      uStack_38 = 0xffff0000;
      puVar8 = (uint *)&DAT_3ff46038;
      break;
    case 5:
      puVar5 = table_paoff;
      iVar7 = 2;
      iVar1 = 0x10;
      uStack_38 = 0xffff;
      puVar8 = (uint *)&DAT_3ff46038;
      break;
    case 6:
      puVar5 = table_rxon_bt;
      iVar7 = 4;
      uStack_38 = 0xffff0000;
      iVar1 = 0;
      puVar8 = (uint *)0x3ff4603c;
      break;
    case 7:
      iVar7 = 3;
      iVar1 = 0x10;
      uStack_38 = 0xffff;
      puVar5 = table_rxoff_bt;
      puVar8 = (uint *)0x3ff4603c;
      break;
    case 8:
      iVar7 = 5;
      iVar1 = 0;
      uStack_38 = 0xffff0000;
      puVar8 = (uint *)0x3ff46040;
      puVar5 = table_txon_bt;
      break;
    case 9:
      iVar7 = 3;
      iVar1 = 0x10;
      uStack_38 = 0xffff;
      puVar8 = (uint *)0x3ff46040;
      puVar5 = table_txoff_bt;
      break;
    case 10:
      iVar7 = 2;
      iVar1 = 0;
      uStack_38 = 0xffff0000;
      puVar8 = (uint *)&DAT_3ff46044;
      puVar5 = table_paon;
      break;
    default:
      iVar7 = 2;
      uStack_38 = 0xffff;
      iVar1 = 0x10;
      puVar8 = (uint *)&DAT_3ff46044;
      puVar5 = table_paoff;
    }
    uVar2 = esp_dport_access_reg_read(puVar8);
    memw();
    *puVar8 = ((((iVar7 + uVar4) - 1) * 0x100 | uVar4) & 0xffff) << 0x20 - (0x20 - iVar1) |
              uVar2 & uStack_38;
    uVar2 = uVar4 + 0x200;
    puVar8 = puVar5 + iVar7;
    do {
      _DAT_3ff45038 = *puVar5;
      puVar5 = puVar5 + 1;
      memw();
      uVar3 = esp_dport_access_reg_read(&DAT_3ff45034);
      uVar6 = uVar2 & 0x3ff;
      uVar2 = uVar2 + 1;
      _DAT_3ff45034 = uVar6 << 8 | uVar3 & 0xfffc00ff;
      memw();
      _DAT_3ff45034 = esp_dport_access_reg_read(&DAT_3ff45034);
      _DAT_3ff45034 = _DAT_3ff45034 & 0xfffcffff;
      memw();
    } while (puVar8 != puVar5);
    iStack_40 = iStack_40 + 1;
    uVar4 = iVar7 + uVar4;
  } while (iStack_40 != 0xc);
  return;
}



// WARNING: Unknown calling convention

void ram_start_tx_tone(int tone1_en,int freq_1_mhz,int tone1_atten,int tone2_en,int freq_2_mhz,
                      int tone2_atten)

{
  uint uVar1;
  ushort uVar2;
  ushort uVar3;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460b8);
  if ((uVar1 & 0x20000000) == 0) {
    uVar2 = (ushort)((freq_1_mhz << 5) / 5) & 0x3ff;
    uVar3 = (ushort)((freq_2_mhz << 5) / 5) & 0x3ff;
  }
  else {
    uVar2 = (ushort)((freq_1_mhz << 7) / 5) & 0xfff;
    uVar3 = (ushort)((freq_2_mhz << 7) / 5) & 0xfff;
  }
  (*g_phyFuns->start_tx_tone_step_)
            (SUB41(tone1_en,0),uVar2,(uint8)tone1_atten,SUB41(tone2_en,0),uVar3,(uint8)tone2_atten);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_bb_tx_ht20_cen(int tx_ht20_cen_en)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_60033c6c);
  memw();
  _DAT_60033c6c = (tx_ht20_cen_en & 1U) << 0x1b | uVar1 & 0xf7ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

sint16 ram_phy_get_noisefloor(void)

{
  ushort uVar1;
  uint uVar2;
  short sVar3;
  
  uVar1 = esp_dport_access_reg_read(0x3ff5c050);
  sVar3 = (uVar1 & 0x3ff) - 0x400;
  if (sVar3 < -0x15f) {
    sVar3 = (ushort)(sVar3 < -0x188) * -0x188 + (ushort)(sVar3 >= -0x188) * sVar3;
  }
  else {
    sVar3 = -0x160;
  }
  uVar2 = esp_dport_access_reg_read(&DAT_3ff5d050);
  memw();
  _DAT_3ff5d050 = uVar2 | 1;
  return sVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

sint16 ram_check_noise_floor(void)

{
  bool bVar1;
  int iVar2;
  bool bVar3;
  short sVar4;
  ushort uVar5;
  uint uVar6;
  short sVar7;
  u32 t0;
  
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = _DAT_3ff5c018 & 0xff7fffff;
  memw();
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = _DAT_3ff5c018 | 0x2000000;
  memw();
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = _DAT_3ff5c018 & 0xfdffffff;
  memw();
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  iVar2 = _DAT_60033c00;
  _DAT_3ff5c018 = _DAT_3ff5c018 | 0x800000;
  memw();
  memw();
  bVar3 = false;
  do {
    bVar1 = bVar3;
    uVar6 = esp_dport_access_reg_read(&DAT_3ff5c018);
    if ((uVar6 & 0x1000000) != 0) {
      uVar5 = esp_dport_access_reg_read(0x3ff5c050);
      sVar7 = (uVar5 & 0x3ff) - 0x400;
      sVar4 = -0x160;
      if (sVar7 < -0x15f) {
LAB_00046107:
        sVar4 = (ushort)(sVar7 < -0x188) * -0x188 + (ushort)(sVar7 >= -0x188) * sVar7;
      }
      if (!bVar1) {
        return sVar4;
      }
      return -sVar4;
    }
    if (bVar1) {
      uVar5 = esp_dport_access_reg_read(0x3ff5c050);
      sVar7 = (uVar5 & 0x3ff) - 0x400;
      if (-0x160 < sVar7) {
        return 0x160;
      }
      bVar1 = true;
      goto LAB_00046107;
    }
    memw();
    bVar3 = true;
    if ((uint)(_DAT_60033c00 - iVar2) < 0x2711) {
      bVar3 = bVar1;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_cbw2040_cfg(bool cbw20_sel)

{
  uint uVar1;
  
  if (cbw20_sel) {
    _DAT_60033c6c = esp_dport_access_reg_read(&DAT_60033c6c);
    _DAT_60033c6c = _DAT_60033c6c | 0x8000000;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5d000);
    memw();
    _DAT_3ff5d000 = uVar1 | 0x40;
    return;
  }
  _DAT_60033c6c = esp_dport_access_reg_read(&DAT_60033c6c);
  _DAT_60033c6c = _DAT_60033c6c & 0xf7ffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5d000);
  memw();
  _DAT_3ff5d000 = uVar1 & 0xffffffbf;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_bb_bss_bw_40_en(int bb_ht_2040)

{
  uint uVar1;
  
  if (bb_ht_2040 != 0) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff00024);
    _DAT_3ff00024 = uVar1 & 0xfffffff3 | 4;
    memw();
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_txdc_cal(void)

{
  u16 uVar1;
  _func_void_u8_u8_u16 *p_Var2;
  u16 *puVar3;
  uint16 *puVar4;
  u16 txdc [4];
  
  (*g_phyFuns->pbus_debugmode_)();
  (*g_phyFuns->pbus_xpd_tx_on_)(tx_rf_ana_gain[0],tx_rf_ana_gain[1]);
  p_Var2 = g_phyFuns->pbus_force_test_;
  uVar1 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
  (*p_Var2)('\x01','\x01',uVar1 | 2);
  puVar3 = (u16 *)&CSWTCH_360;
  uVar1 = 0;
  puVar4 = chip7_sleep_params.bt_txdc_table;
  while( true ) {
    (*g_phyFuns->pbus_force_test_)('\x01','\x02',uVar1);
    (*g_phyFuns->txdc_cal_v70_)((sint16 *)txdc);
    *puVar4 = txdc[0];
    memw();
    puVar3 = puVar3 + 1;
    puVar4 = puVar4 + 4;
    if (puVar3 == (u16 *)0x599de) break;
    uVar1 = *puVar3;
  }
  (*g_phyFuns->pbus_xpd_rx_on_)(0);
  (*g_phyFuns->pbus_workmode_)();
  chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x1000;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_txiq_cal(void)

{
  ushort *puVar1;
  short sVar2;
  uint16 *para_txiq;
  uint16 *txdc;
  uint uVar3;
  short sVar4;
  short sVar5;
  
  uVar3 = 0;
  sVar2 = (short)chip7_sleep_params.tx_pwctrl_atten[0x14];
  puVar1 = (ushort *)&CSWTCH_360;
  txdc = chip7_sleep_params.bt_txdc_table;
  para_txiq = chip7_sleep_params.bt_txiq;
  while( true ) {
    sVar4 = 0;
    if ((uVar3 & 1) != 0) {
      sVar4 = 6;
    }
    sVar5 = 0;
    if ((tx_rf_ana_gain[1] & 1) != 0) {
      sVar5 = 6;
    }
    sVar5 = ((((ushort)(uVar3 >> 6) & 0xff) + sVar4 & 0xff) -
            ((tx_rf_ana_gain[1] >> 6 & 0xff) + sVar5 & 0xff)) * 4 + sVar2 + 0x2b;
    sVar4 = 0;
    if ((-1 < sVar5) && (sVar4 = 0x78, sVar5 < 0x79)) {
      sVar4 = sVar5;
    }
    rfcal_txiq((uint16)uVar3,txdc,para_txiq,' ',(int8)sVar4,'\x01');
    puVar1 = puVar1 + 1;
    txdc = txdc + 4;
    para_txiq = para_txiq + 1;
    if (puVar1 == (ushort *)0x599de) break;
    uVar3 = (uint)*puVar1;
  }
  chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x800;
  return;
}



// WARNING: Unknown calling convention

int spur_cal(uint16 freq,int8 BW_h,uint16 spur_freq_cfg,uint8 spur_freq_cfg_div)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  
  uVar3 = (uint)spur_freq_cfg_div;
  uVar2 = (uint)spur_freq_cfg;
  uVar1 = (uint)freq;
  iVar4 = ((uVar3 * uVar1) / uVar2) * uVar2;
  iVar5 = uVar1 * 10 - (iVar4 * 10) / (int)uVar3;
  if (iVar5 < BW_h * 10) {
    return -iVar5;
  }
  iVar4 = uVar1 * -10 + (int)((uVar2 + iVar4) * 10) / (int)uVar3;
  if (BW_h * 10 <= iVar4) {
    iVar4 = 0;
  }
  return iVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int ram_spur_coef_cfg(int8 channel,uint16 freq,int8 sub_chan_cfg)

{
  int iVar1;
  uint16 uVar2;
  uint uVar3;
  int iVar4;
  _func_void_U8_int *p_Var5;
  int8 BW_h;
  uint uVar6;
  
  uVar3 = (uint)(byte)channel;
  BW_h = '\n';
  if ('\x01' < sub_chan_cfg) {
    BW_h = '\x14';
  }
  if (chip7_phy_init_ctrl.crystal_select == '\x03') {
    rtc_get_xtal();
  }
  _DAT_3ff5d014 = esp_dport_access_reg_read(&DAT_3ff5d014);
  uVar2 = chip7_phy_init_ctrl.spur_freq_en_1;
  _DAT_3ff5d014 = _DAT_3ff5d014 & 0xffffdfff;
  uVar6 = (uint)chip7_phy_init_ctrl.spur_freq_en_1;
  memw();
  if (((uVar6 == 0) || (chip7_phy_init_ctrl.spur_freq_cfg_div_1 == '\0')) ||
     (chip7_phy_init_ctrl.spur_freq_cfg_1 == 0)) {
LAB_000464a1:
    _DAT_3ff5d018 = esp_dport_access_reg_read(&DAT_3ff5d018);
    _DAT_3ff5d018 = _DAT_3ff5d018 & 0xffffdfff;
    memw();
  }
  else {
    iVar4 = spur_cal(freq,BW_h,chip7_phy_init_ctrl.spur_freq_cfg_1,
                     chip7_phy_init_ctrl.spur_freq_cfg_div_1);
    iVar1 = (iVar4 << 10) / 100;
    if ((((int)uVar6 >> (uVar3 + 0x1f & 0x1f) & (uint)(uVar2 >> 0xe) & (uint)(iVar4 != 0)) == 0) ||
       (iVar1 == 0)) goto LAB_000464a1;
    (*g_phyFuns->spur_reg_write_one_tone_)('\x01',iVar1);
  }
  uVar2 = chip7_phy_init_ctrl.spur_freq_en_2;
  uVar6 = (uint)chip7_phy_init_ctrl.spur_freq_en_2;
  if (((uVar6 == 0) || (chip7_phy_init_ctrl.spur_freq_cfg_div_2 == '\0')) ||
     (chip7_phy_init_ctrl.spur_freq_cfg_2 == 0)) {
LAB_00046519:
    _DAT_3ff5d01c = esp_dport_access_reg_read(&DAT_3ff5d01c);
    _DAT_3ff5d01c = _DAT_3ff5d01c & 0xffffdfff;
    memw();
  }
  else {
    iVar4 = spur_cal(freq,BW_h,chip7_phy_init_ctrl.spur_freq_cfg_2,
                     chip7_phy_init_ctrl.spur_freq_cfg_div_2);
    iVar1 = (iVar4 << 10) / 100;
    if ((((int)uVar6 >> (uVar3 + 0x1f & 0x1f) & (uint)(uVar2 >> 0xe) & (uint)(iVar4 != 0)) == 0) ||
       (iVar1 == 0)) goto LAB_00046519;
    (*g_phyFuns->spur_reg_write_one_tone_)('\x02',iVar1);
  }
  uVar2 = chip7_phy_init_ctrl.spur_freq_en_3;
  uVar6 = (uint)chip7_phy_init_ctrl.spur_freq_en_3;
  if (((uVar6 != 0) && (chip7_phy_init_ctrl.spur_freq_cfg_div_3 != '\0')) &&
     (chip7_phy_init_ctrl.spur_freq_cfg_3 != 0)) {
    iVar4 = spur_cal(freq,BW_h,chip7_phy_init_ctrl.spur_freq_cfg_3,
                     chip7_phy_init_ctrl.spur_freq_cfg_div_3);
    iVar1 = (iVar4 << 10) / 100;
    if ((((int)uVar6 >> (uVar3 + 0x1f & 0x1f) & (uint)(uVar2 >> 0xe) & (uint)(iVar4 != 0)) != 0) &&
       (iVar1 != 0)) {
      p_Var5 = g_phyFuns->spur_reg_write_one_tone_;
      (*p_Var5)('\x03',iVar1);
      goto LAB_000465a5;
    }
  }
  _DAT_3ff5d020 = esp_dport_access_reg_read(&DAT_3ff5d020);
  p_Var5 = (_func_void_U8_int *)&DAT_3ff5d020;
  _DAT_3ff5d020 = _DAT_3ff5d020 & 0xffffdfff;
  memw();
LAB_000465a5:
  uVar3 = esp_dport_access_reg_read(&DAT_3ff5cc48);
  uVar6 = esp_dport_access_reg_read(&DAT_3ff5cc48);
  memw();
  _DAT_3ff5cc48 =
       uVar6 & 0xff000000 |
       (0x50 << 0x20 - (0x20 - (uVar3 >> 0x18 & 0x1f))) / (int)(uint)freq & 0xffffffU;
  return (int)p_Var5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_chan_rxcomp(sint8 offset)

{
  char cVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  
  iVar4 = 0;
  if ((3 < (byte)chip7_sleep_params.phy_channel_num) &&
     (iVar4 = 2, (byte)chip7_sleep_params.phy_channel_num < 9)) {
    iVar4 = 1;
  }
  cVar1 = chip7_phy_init_ctrl.gain_cmp[iVar4];
  uVar2 = esp_dport_access_reg_read(&DAT_3ff5c02c);
  uVar3 = (int)cVar1 + (int)offset;
  _DAT_3ff5c02c = uVar2 & 0xffffff00 | uVar3 & 0xff;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff5c0a0);
  _DAT_3ff5c0a0 = uVar2 & 0xffffff | uVar3 * 0x1000000;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff5c0d0);
  memw();
  _DAT_3ff5c0d0 =
       (((int)chip7_phy_init_ctrl.gain_cmp_bt_ofs[iVar4] + uVar3) - 0x12 & 0xff) << 9 |
       uVar2 & 0xfffe01ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_ant_init(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c030);
  memw();
  _DAT_3ff5c030 = uVar1 & 0xfffc07ff | 0x1a000;
  memw();
  _DAT_3ff5c11c = 0xe000;
  memw();
  _DAT_3ff5c120 = 0x1e101e1c;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void tx_delay_cfg(bool ht40_en)

{
  uint uVar1;
  
  if (ht40_en) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5d030);
    _DAT_3ff5d030 = uVar1 & 0xfffffc00 | 0x87;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff450f0);
    _DAT_3ff450f0 = uVar1 & 0xfffffe00 | 0xf0;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5d000);
    _DAT_3ff5d000 = uVar1 & 0xe07fffff | 0xa000000;
    memw();
  }
  else {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5d030);
    _DAT_3ff5d030 = uVar1 & 0xfffffc00 | 100;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff450f0);
    _DAT_3ff450f0 = uVar1 & 0xfffffe00 | 100;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5d000);
    _DAT_3ff5d000 = uVar1 & 0xe07fffff | 0xf000000;
    memw();
  }
  phy_bt_ifs_set();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bb_bss_cbw40(int8 sub_chan_cfg)

{
  uint uVar1;
  
  if (sub_chan_cfg == '\0') {
    memw();
    chip7_sleep_params.ht40_mode_cfg = sub_chan_cfg;
    (*g_phyFuns->bb_bss_cbw40_dig_)(0);
    bb_bss_cbw40_ana(0);
    tx_delay_cfg(false);
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c450);
    memw();
    _DAT_3ff5c450 = uVar1 & 0xfffffff3;
    return;
  }
  chip7_sleep_params.ht40_mode_cfg = '\x01';
  memw();
  (*g_phyFuns->bb_bss_cbw40_dig_)(1);
  if (sub_chan_cfg == '\x01') {
    (*g_phyFuns->cbw2040_cfg_)(true);
    bb_bss_cbw40_ana(0);
  }
  else {
    (*g_phyFuns->cbw2040_cfg_)(false);
    bb_bss_cbw40_ana(1);
    if (sub_chan_cfg == '\x03') {
      _DAT_3ff5cc0c = esp_dport_access_reg_read(&DAT_3ff5cc0c);
      _DAT_3ff5cc0c = _DAT_3ff5cc0c | 1;
      memw();
      goto LAB_000468bd;
    }
  }
  _DAT_3ff5cc0c = esp_dport_access_reg_read(&DAT_3ff5cc0c);
  _DAT_3ff5cc0c = _DAT_3ff5cc0c & 0xfffffffe;
  memw();
LAB_000468bd:
  tx_delay_cfg(true);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c450);
  memw();
  _DAT_3ff5c450 = uVar1 | 0xc;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void tx_paon_set(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5d000);
  _DAT_3ff5d000 = uVar1 & 0xe00007ff | 0xf7e8000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46048);
  _DAT_3ff46048 = uVar1 & 0xffff00ff | 0xa400;
  memw();
  _DAT_3ff5c400 = esp_dport_access_reg_read(&DAT_3ff5c400);
  _DAT_3ff5c400 = _DAT_3ff5c400 & 0xfff8ffff;
  memw();
  _DAT_3ff450d0 = esp_dport_access_reg_read(&DAT_3ff450d0);
  _DAT_3ff450d0 = _DAT_3ff450d0 & 0xbfffffff;
  memw();
  memw();
  _DAT_3ff450c4 = 1000000;
  memw();
  _DAT_3ff450c8 = 1000000;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e054);
  _DAT_3ff4e054 = uVar1 & 0xffffff00 | 100;
  memw();
  tx_delay_cfg(false);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void agc_reg_init(void)

{
  uint uVar1;
  
  _DAT_3ff5c004 = esp_dport_access_reg_read(&DAT_3ff5c004);
  _DAT_3ff5c004 = _DAT_3ff5c004 & 0xfffeffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c0a4);
  _DAT_3ff5c0a4 = uVar1 & 0xffffc07f | 0x1e00;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c0a4);
  _DAT_3ff5c0a4 = uVar1 & 0xffffff80 | 0x3c;
  memw();
  memw();
  _DAT_3ff5c0c4 = 0x6450403f;
  memw();
  _DAT_3ff5c030 = 0x3c1a4d5;
  memw();
  _DAT_3ff5c094 = 0x1b8dd03;
  memw();
  _DAT_3ff5c02c = 0x324048fe;
  _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = _DAT_3ff5c02c | 0x800000;
  memw();
  _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = _DAT_3ff5c02c & 0xff7fffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = uVar1 & 0xfffffff8 | 4;
  memw();
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = _DAT_3ff5c018 | 0x40000000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c01c);
  _DAT_3ff5c01c = uVar1 & 0xffffff00 | 0xbf;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c028);
  _DAT_3ff5c028 = uVar1 & 0xfffffe00 | 0x1ba;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c0f8);
  _DAT_3ff5c0f8 = uVar1 & 0xfffc01ff | 0x37400;
  memw();
  _DAT_3ff5c038 = esp_dport_access_reg_read(&DAT_3ff5c038);
  _DAT_3ff5c038 = _DAT_3ff5c038 & 0xf7ffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c088);
  _DAT_3ff5c088 = uVar1 & 0xffffff00 | 5;
  memw();
  _DAT_3ff5c104 = esp_dport_access_reg_read(&DAT_3ff5c104);
  _DAT_3ff5c104 = _DAT_3ff5c104 & 0xffff7fff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c07c);
  memw();
  _DAT_3ff5c07c = uVar1 & 0xff00ffff | 0x9c0000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bb_reg_init(void)

{
  uint uVar1;
  
  memw();
  _DAT_3ff5cc48 = 0x170433af;
  _DAT_3ff5cce4 = esp_dport_access_reg_read(&DAT_3ff5cce4);
  _DAT_3ff5cce4 = _DAT_3ff5cce4 & 0xffbfffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c400);
  _DAT_3ff5c400 = uVar1 & 0xffff9f00 | 0x60a5;
  memw();
  memw();
  _DAT_3ff5cd04 = 0x51510556;
  memw();
  _DAT_3ff5cd08 = 0x51510556;
  memw();
  _DAT_3ff5cc0c = 0x1241fc;
  memw();
  _DAT_3ff5cc08 = 0x90b4d20;
  memw();
  _DAT_3ff5ccdc = 0x195c83c;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c044);
  _DAT_3ff5c044 = uVar1 & 0xfe00ffff | 0x1fb0000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c024);
  _DAT_3ff5c024 = uVar1 & 0xfffc01ff | 0x36800;
  memw();
  memw();
  _DAT_3ff5c094 = 0x1b8dd03;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5cc04);
  memw();
  _DAT_3ff5cc04 = uVar1 & 0xfffffe03 | 0x2c;
  memw();
  _DAT_3ff5ccd8 = 0x186;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void mac_enable_bb(void)

{
  uint uVar1;
  
  _DAT_3ff00024 = esp_dport_access_reg_read(&DAT_3ff00024);
  _DAT_3ff00024 = _DAT_3ff00024 | 0x10000000;
  memw();
  _DAT_3ff00024 = esp_dport_access_reg_read(&DAT_3ff00024);
  _DAT_3ff00024 = _DAT_3ff00024 & 0xfffffffd;
  memw();
  _DAT_3ff00024 = esp_dport_access_reg_read(&DAT_3ff00024);
  _DAT_3ff00024 = _DAT_3ff00024 | 2;
  memw();
  _DAT_3ff00024 = esp_dport_access_reg_read(&DAT_3ff00024);
  _DAT_3ff00024 = _DAT_3ff00024 & 0xfffffffd;
  memw();
  _DAT_3ff00024 = esp_dport_access_reg_read(&DAT_3ff00024);
  _DAT_3ff00024 = _DAT_3ff00024 | 2;
  memw();
  _DAT_3ff00024 = esp_dport_access_reg_read(&DAT_3ff00024);
  _DAT_3ff00024 = _DAT_3ff00024 & 0xfffffffd;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff00024);
  memw();
  _DAT_3ff00024 = uVar1 | 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bb_wdg_cfg(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5d040);
  memw();
  _DAT_3ff5d040 = uVar1 | 0x80000000;
  memw();
  _DAT_3ff5d03c = 0x401800aa;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rx_11b_opt(bool rx_11b_opt_en)

{
  uint uVar1;
  
  if (rx_11b_opt_en) {
    _DAT_3ff5c044 = esp_dport_access_reg_read(&DAT_3ff5c044);
    _DAT_3ff5c044 = _DAT_3ff5c044 | 0x1ff0000;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c044);
    _DAT_3ff5c044 = uVar1 & 0xffffc0ff | 0x2100;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c124);
    _DAT_3ff5c124 = uVar1 & 0xffff03ff | 0x8400;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c124);
    _DAT_3ff5c124 = uVar1 & 0xfffffff0 | 3;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c804);
    _DAT_3ff5c804 = uVar1 & 0xffff0fff | 0x9000;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c104);
    memw();
    _DAT_3ff5c104 = uVar1 & 0xfffffe00 | 0x1e2;
    return;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c044);
  _DAT_3ff5c044 = uVar1 & 0xfe00ffff | 0x1fb0000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c044);
  _DAT_3ff5c044 = uVar1 & 0xffffc0ff | 0x1800;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c124);
  _DAT_3ff5c124 = uVar1 & 0xffff03ff | 0x6000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c124);
  _DAT_3ff5c124 = uVar1 & 0xfffffff0 | 4;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c804);
  _DAT_3ff5c804 = uVar1 & 0xffff0fff | 0x6000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c104);
  memw();
  _DAT_3ff5c104 = uVar1 & 0xfffffe00 | 0x1d2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void opt_11b_resart(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c0a0);
  _DAT_3ff5c0a0 = uVar1 & 0xff00ffff | 0x800000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c01c);
  _DAT_3ff5c01c = uVar1 & 0xff00ffff | 0xc0000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c094);
  _DAT_3ff5c094 = uVar1 & 0xffff01ff | 0xdc00;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c0f0);
  _DAT_3ff5c0f0 = uVar1 & 0xffffff00 | 0x80;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c0b8);
  memw();
  _DAT_3ff5c0b8 = uVar1 | 0x800;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_reg_init(void)

{
  uint uVar1;
  
  tx_rf_ana_gain[0] = chip7_sleep_params.loop_tx_rf_ana_gain[0];
  tx_rf_ana_gain[1] = chip7_sleep_params.loop_tx_rf_ana_gain[1];
  memw();
  tx_paon_set();
  bb_reg_init();
  agc_reg_init();
  _DAT_3ff5d040 = esp_dport_access_reg_read(&DAT_3ff5d040);
  _DAT_3ff5d040 = _DAT_3ff5d040 | 0x80000000;
  memw();
  memw();
  _DAT_3ff5d03c = 0x401800aa;
  mac_enable_bb();
  phy_set_bbfreq_init(true);
  (*g_phyFuns->tx_pwctrl_bg_init_)();
  (*g_phyFuns->noise_floor_auto_set_)();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c030);
  _DAT_3ff5c030 = uVar1 & 0xfffc07ff | 0x1a000;
  memw();
  memw();
  _DAT_3ff5c11c = 0xe000;
  memw();
  _DAT_3ff5c120 = 0x1e101e1c;
  opt_11b_resart();
  rx_11b_opt(true);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void set_chan_reg(void)

{
  int8 channel;
  uint16 uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  _func_int_int8_uint16_int8 *p_Var6;
  
  channel = chip7_sleep_params.phy_channel_num;
  uVar1 = chan_to_freq(chip7_sleep_params.phy_channel_num);
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = uVar2 & 0xe7ffffff | 0x10000000;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfff0ffff;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xff0fffff;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
  memw();
  uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = (uVar1 - 0x60 & 0x7f) << 1 | uVar4 & 0xffffff00;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x100;
  memw();
  p_Var6 = g_phyFuns->spur_coef_cfg_;
  uVar1 = chan_to_freq(channel);
  (*p_Var6)(channel,uVar1,chip7_sleep_params.phy_sub_chan_cfg);
  (*g_phyFuns->set_noise_floor_)(chip7_sleep_params.rx_noise);
  set_chan_rxcomp('\0');
  (*g_phyFuns->set_txcap_reg_)((U8 *)0x5bbf8,channel);
  do {
    iVar5 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    if (iVar5 < 0) break;
    uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  } while ((uVar4 & 0x100) != 0);
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
  memw();
  bb_bss_cbw40(chip7_sleep_params.phy_sub_chan_cfg);
  uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = uVar4 & 0xfff0ffff | (uVar2 >> 0x10 & 0xf) << 0x10;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = uVar2 & 0xff0fffff | (uVar3 >> 0x14 & 0xf) << 0x14;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xe7ffffff;
  memw();
  if (chip7_phy_init_ctrl.force_freq_offset_enbale != '\0') {
    phy_freq_correct_opt();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2c_master_reset(void)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  uint32 t0;
  int iVar4;
  uint32_t val;
  
  iVar4 = 0;
  puVar2 = (undefined4 *)&DAT_3ff4e000;
  do {
    iVar1 = _DAT_60033c00;
    memw();
    do {
      uVar3 = esp_dport_access_reg_read(puVar2);
      if ((uVar3 & 0x2000000) == 0) goto LAB_000473eb;
      memw();
    } while ((uint)(_DAT_60033c00 - iVar1) < 3);
    phy_printf("i2c_master_reset %d\n",iVar4);
    memw();
    *puVar2 = 0;
    do {
      uVar3 = esp_dport_access_reg_read(puVar2);
    } while ((uVar3 & 0x2000000) != 0);
LAB_000473eb:
    iVar4 = iVar4 + 1;
    puVar2 = puVar2 + 1;
    if (iVar4 == 5) {
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

uint8 ram_gen_rx_gain_table
                (uint32 *rx_gain_table,uint8 gain_lpf_max,uint8 *rx_gain_swp,sint8 *rx_gain_swp_step
                ,uint8 rx_gain_swp_num,uint8 max_bb_gain,bool print_en)

{
  char cVar1;
  uint8 uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  char *pcVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint32 *puVar10;
  uint uVar11;
  int iVar12;
  uint uVar13;
  uint16 bb_coarse_gain [5];
  
  uVar7 = (uint)max_bb_gain;
  memcpy(bb_coarse_gain,&DAT_00052870,10);
  uVar5 = 0;
  uVar8 = 0;
  iVar3 = (uVar7 / 6) * 2;
  iVar9 = rx_gain_swp_num - 1;
  uVar4 = 0;
  pcVar6 = rx_gain_swp_step;
  do {
    if ((uVar5 == (int)*pcVar6) && ((int)uVar4 < iVar9)) {
      uVar4 = uVar4 + 1 & 0xff;
      pcVar6 = rx_gain_swp_step + uVar4;
      cVar1 = *pcVar6;
      while (uVar5 = uVar7, iVar12 = iVar3, uVar13 = uVar7 % 6, cVar1 == '\0') {
        if (iVar9 <= (int)uVar4) goto LAB_000474da;
        uVar4 = uVar4 + 1 & 0xff;
        pcVar6 = rx_gain_swp_step + uVar4;
        cVar1 = *pcVar6;
      }
      if ((int)uVar4 < iVar9) {
        uVar5 = 0;
        iVar12 = 0;
        uVar13 = 0;
      }
    }
    else {
      iVar12 = (uVar5 / 6) * 2;
      uVar13 = uVar5 % 6;
    }
LAB_000474da:
    iVar12 = (*(ushort *)((int)bb_coarse_gain + iVar12) & 0x1fff) * 8;
    uVar2 = (uint8)uVar8;
    uVar11 = (uint)rx_gain_swp[uVar4] * 0x100 + iVar12 + uVar13 & 0xffff;
    puVar10 = rx_gain_table + ((int)(char)uVar2 >> 1);
    if ((uVar8 & 1) == 0) {
      *puVar10 = uVar11;
    }
    else {
      *puVar10 = *puVar10 + uVar11 * 0x10000;
    }
    if (print_en) {
      phy_printf("index: %d value: 0x%x 0x%x 0x%x %d %d %d %d\n",uVar8,uVar11,rx_gain_swp[uVar4],
                 iVar12,uVar13,(uint)rx_gain_swp_num,uVar4,(int)*pcVar6);
    }
    if (gain_lpf_max < uVar5) {
      if (print_en) {
        phy_printf("max_gain: %d\n",uVar8 & 0xff);
        return uVar2;
      }
      return uVar2;
    }
    uVar8 = uVar8 + 1;
    uVar5 = uVar5 + 1 & 0xff;
    if (uVar8 == 0x7f) {
      return 'U';
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_rx_gain_cal_iq(bool bt_mode,S16 tone_freq,uint16 *rxbb_iq,bool rxiq_print_en)

{
  short sVar1;
  u16 uVar2;
  uint16 uVar3;
  _func_void_u8_u8_u16 *p_Var4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  byte bVar10;
  uint8 uVar11;
  u16 uVar12;
  byte bVar13;
  uint16 bbgain_m [5];
  sint16 rx_dc_comp [4];
  uint8 rftx_m [5];
  uint uStack_50;
  byte *pbStack_48;
  uint16 *puStack_40;
  
  memcpy(rftx_m,&DAT_0005287c,5);
  memcpy(bbgain_m,&DAT_00052884,10);
  (*g_phyFuns->loopback_mode_en_)(true);
  (*g_phyFuns->i2c_writeReg_Mask_)('d','\0','\x04','\a','\a','\x01');
  _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
  _DAT_3ff450dc = _DAT_3ff450dc | 0x8000000;
  memw();
  _DAT_3ff450dc = esp_dport_access_reg_read();
  _DAT_3ff450dc = _DAT_3ff450dc & 0xefffffff;
  memw();
  _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
  _DAT_3ff450dc = _DAT_3ff450dc & 0xffffefff;
  bVar13 = (byte)(chip7_sleep_params.lb_txiq >> 6) & 0x1f;
  memw();
  if (0xf < bVar13) {
    bVar13 = bVar13 - 0x20;
  }
  bVar10 = (byte)chip7_sleep_params.lb_txiq & 0x3f;
  if (0x1f < bVar10) {
    bVar10 = bVar10 - 0x40;
  }
  pbStack_48 = (byte *)((int)rx_dc_comp + 7);
  (*g_phyFuns->txiq_set_reg_)(bVar13,true);
  (*g_phyFuns->txiq_set_reg_)(bVar10,false);
  uStack_50 = 0;
  rx_dc_comp[0] = 0x100;
  rx_dc_comp[1] = 0x100;
  memw();
  puStack_40 = rxbb_iq;
  do {
    uVar3 = bbgain_m[uStack_50];
    uVar12 = (u16)pbStack_48[1];
    (*g_phyFuns->set_loopback_gain_)((ushort)pbStack_48[1],0x104,uVar3 + 0x80);
    if (bt_mode) {
      p_Var4 = g_phyFuns->pbus_force_test_;
      uVar2 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
      (*p_Var4)('\x01','\x01',uVar2 | 2);
    }
    (*g_phyFuns->pbus_rx_dco_cal_)(4000,rx_dc_comp,10,false,false);
    bVar13 = 0;
    iVar5 = 0x18;
    do {
      (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x1f1);
      (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x1f9);
      uVar11 = (uint8)iVar5;
      (*g_phyFuns->start_tx_tone_step_)(true,tone_freq,uVar11,false,0,'\0');
      (*g_phyFuns->iq_est_enable_)(true,0x3ff);
      iVar6 = esp_dport_access_reg_read(0x3ff460e4);
      iVar6 = iVar6 >> 7;
      if (rxiq_print_en) {
        iVar7 = esp_dport_access_reg_read(0x3ff460dc);
        iVar8 = esp_dport_access_reg_read(0x3ff460e0);
        phy_printf("total_pwr=%ld, min=%ld, max=%ld, rftx=0x%x, att=%d, dc_i=%d, dc_q=%d\n",iVar6,
                   0x1000,0x20000,uVar12,iVar5,iVar7 >> 0x10,iVar8 >> 0x10);
      }
      (*g_phyFuns->iq_est_disable_)();
      (*g_phyFuns->stop_tx_tone_)(1);
      sVar1 = (short)iVar5;
      if (iVar6 < 0x20001) {
        if (0xfff < iVar6) break;
        if (((bVar13 & 1) == 0) && ((uStack_50 & 0xff) != 0)) {
          iVar5 = (int)(short)((ushort)(iVar5 < 0x78) * sVar1 + (ushort)(iVar5 >= 0x78) * 0x78);
          uVar12 = (u16)*pbStack_48;
        }
        else {
          iVar5 = 0;
        }
LAB_00047902:
        (*g_phyFuns->pbus_force_test_)('\x05','\x01',uVar12);
      }
      else {
        if (((bVar13 & 1) == 0) && (uVar12 != 0)) {
          iVar5 = (int)(short)((ushort)(iVar5 < 0x78) * sVar1 + (ushort)(iVar5 >= 0x78) * 0x78);
          uVar12 = (u16)pbStack_48[2];
          goto LAB_00047902;
        }
        iVar6 = (int)(short)(sVar1 + 0x18);
        (*g_phyFuns->pbus_force_test_)('\x05','\x01',uVar12);
        iVar5 = 0;
        if (-1 < iVar6) {
          iVar5 = (uint)(iVar6 < 0x78) * iVar6 + (uint)(iVar6 >= 0x78) * 0x78;
        }
      }
      uVar11 = (uint8)iVar5;
      bVar13 = bVar13 + 1;
    } while (bVar13 != 2);
    if (rxiq_print_en) {
      phy_printf("rxiq: rftx=0x%x, rfrx=x%x, att=%d, bb=0x%x, %d, %d\n",uVar12,0x104,iVar5,
                 uVar3 + 0x80,uStack_50,2);
    }
    uStack_50 = uStack_50 + 1;
    pbStack_48 = pbStack_48 + 1;
    uVar3 = (*g_phyFuns->get_rfcal_rxiq_data_)(tone_freq,uVar11,rxiq_print_en);
    *puStack_40 = uVar3;
    puStack_40 = puStack_40 + 1;
    if (uStack_50 == 4) {
      (*g_phyFuns->loopback_mode_en_)(false);
      (*g_phyFuns->i2c_writeReg_Mask_)('d','\0','\x04','\a','\a','\0');
      _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
      _DAT_3ff450dc = _DAT_3ff450dc | 0x10000000;
      memw();
      uVar9 = esp_dport_access_reg_read();
      memw();
      _DAT_3ff450dc = uVar9 | 0x1000;
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void rx_chan_dc_sort(uint32 *chan_dc,uint8 *chan_flag)

{
  uint8 uVar1;
  sint32 sVar2;
  char cVar3;
  uint uVar4;
  uint uVar5;
  ushort uVar6;
  int iVar7;
  ushort uVar8;
  int iVar9;
  char cVar10;
  int iVar11;
  uint8 *puVar12;
  ushort *puVar13;
  uint16 chan_q [14];
  uint16 chan_i [14];
  ushort *puStack_50;
  sint32 sStack_4c;
  uint uStack_48;
  uint uStack_44;
  
  puVar13 = chan_q;
  chan_i[0] = (uint16)(*chan_dc >> 0x10);
  chan_q[0] = (ushort)*chan_dc & 0x1ff;
  memw();
  puVar12 = chan_flag + -1;
  cVar10 = '\x01';
  iVar11 = 0;
  do {
    if (puVar12[1] == '\0') {
      cVar3 = cVar10 + -2;
      iVar7 = (int)cVar3;
      if (iVar7 != -1) {
        uVar1 = *puVar12;
        while (uVar1 != '\x01') {
          cVar3 = cVar3 + -1;
          iVar7 = (int)cVar3;
          if (iVar7 == -1) break;
          uVar1 = chan_flag[iVar7];
        }
      }
      if (cVar10 == '\x0e') {
LAB_00047aac:
        puStack_50 = chan_i + iVar11;
        uVar6 = *puVar13;
        uVar5 = (uint)uVar6;
        uVar8 = *puStack_50;
        uVar4 = (uint)uVar8;
        if (iVar7 != -1) {
LAB_000479b4:
          iVar9 = iVar7;
          goto LAB_000479bd;
        }
        sStack_4c = 0;
        iVar7 = sStack_4c;
        uStack_48 = uVar4;
        uStack_44 = uVar5;
      }
      else {
        iVar9 = (int)cVar10;
        uVar1 = puVar12[2];
        cVar3 = cVar10;
        while (uVar1 != '\x01') {
          cVar3 = cVar3 + '\x01';
          iVar9 = (int)cVar3;
          if (cVar3 == '\x0e') goto LAB_00047aac;
          uVar1 = chan_flag[iVar9];
        }
        puStack_50 = chan_i + iVar11;
        uVar4 = (uint)*puStack_50;
        uVar5 = (uint)*puVar13;
        if ((iVar7 != -1) && (iVar11 - iVar7 < iVar9 - iVar11)) goto LAB_000479b4;
LAB_000479bd:
        uVar8 = chan_i[iVar9];
        uVar6 = chan_q[iVar9];
        sStack_4c = uVar5 - uVar6;
        iVar7 = uVar4 - uVar8;
        uStack_48 = (uint)uVar8;
        uStack_44 = (uint)uVar6;
      }
      sVar2 = (*g_phyFuns->abs_temp_)(iVar7);
      if (5 < sVar2) {
        *puStack_50 = uVar8;
        memw();
        uVar4 = uStack_48;
      }
      sVar2 = (*g_phyFuns->abs_temp_)(sStack_4c);
      if (5 < sVar2) {
        *puVar13 = uVar6;
        uVar5 = uStack_44;
      }
      *chan_dc = uVar4 << 0x10 | uVar5;
    }
    cVar10 = cVar10 + '\x01';
    iVar11 = iVar11 + 1;
    chan_dc = chan_dc + 1;
    puVar13 = puVar13 + 1;
    puVar12 = puVar12 + 1;
    if (cVar10 == '\x0f') {
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void set_rx_gain_cal_dc(bool bt_mode,uint8 mode_start,uint8 mode_end,uint8 *rx_gain_swp,
                       uint32 *rxrf_dc,uint32 *rxbb_dc,uint32 *chan_dc,uint8 rf_dc_num,
                       uint8 bb_dc_num,uint8 chan_dc_num)

{
  bool bVar1;
  byte bVar2;
  ushort uVar3;
  byte channel;
  byte bVar4;
  uint8 uVar5;
  uint uVar6;
  uint uVar7;
  _func_void_uint8_uint8_uint8_uint8 *p_Var8;
  byte *pbVar9;
  ushort *puVar10;
  uint *puVar11;
  uint8 chan_flag [14];
  int32 dc_est [3];
  uint16 bbc_m [5];
  sint16 rx_dc_comp [2];
  uint uStack_50;
  uint uStack_40;
  uint uStack_3c;
  
  rx_dc_comp[0] = 0x100;
  rx_dc_comp[1] = 0x100;
  memw();
  memcpy(bbc_m,&DAT_00052870,10);
  (*g_phyFuns->set_rxclk_en_)(true);
  (*g_phyFuns->set_txclk_en_)(true);
  chip_v7_set_chan_ana('\x0e');
  if (mode_start < mode_end) {
    uVar7 = 9;
    if (bt_mode) {
      uVar7 = 0;
    }
    do {
      if (mode_start == 1) {
        (*g_phyFuns->pbus_force_test_)('\x02','\x01',*(u16 *)((int)rxrf_dc + 0x2a));
        (*g_phyFuns->pbus_force_test_)('\x03','\x01',*(u16 *)(rxrf_dc + 10));
        uStack_50 = 4;
LAB_00047bc2:
        bVar4 = 1;
        rx_dc_comp[0] = 0x100;
        rx_dc_comp[1] = 0x100;
        memw();
      }
      else {
        if (mode_start == 0) {
          (*g_phyFuns->pbus_force_test_)('\x02','\x02',0x100);
          (*g_phyFuns->pbus_force_test_)('\x03','\x02',0x100);
          uStack_50 = (uint)rf_dc_num;
          goto LAB_00047bc2;
        }
        if (mode_start == 2) {
          (*g_phyFuns->pbus_force_test_)('\x02','\x02',*(u16 *)((int)rxbb_dc + 6));
          (*g_phyFuns->pbus_force_test_)('\x03','\x02',(ushort)rxbb_dc[1] & 0x1ff);
          bVar4 = 0xe;
        }
        else {
          (*g_phyFuns->pbus_force_test_)('\x02','\x02',*(u16 *)((int)rxbb_dc + 6));
          (*g_phyFuns->pbus_force_test_)('\x03','\x02',(ushort)rxbb_dc[1] & 0x1ff);
          bVar4 = 1;
        }
        uStack_50 = 1;
        rx_dc_comp[0] = (sint16)(rxrf_dc[10] >> 0x10);
        rx_dc_comp[1] = (sint16)rxrf_dc[10];
        memw();
      }
      uVar6 = 0;
      uStack_3c = 0;
      uStack_40 = uVar7;
      channel = 1;
      do {
        if (mode_start == 2) {
          chip_v7_set_chan_ana(channel);
        }
        if (bt_mode) {
          p_Var8 = g_phyFuns->i2c_writeReg_;
          uVar5 = get_rfrx_dcap_bt('\x04');
          (*p_Var8)('d','\0','\x04',uVar5);
          p_Var8 = g_phyFuns->i2c_writeReg_;
          uVar5 = get_rfrx_dcap_bt('\a');
          (*p_Var8)('d','\0','\a',uVar5);
        }
        if (uStack_50 != 0) {
          puVar10 = bbc_m;
          pbVar9 = rx_gain_swp;
          do {
            if (mode_start == 1) {
              bVar2 = rx_gain_swp[1];
              uVar3 = *puVar10;
              (*g_phyFuns->pbus_force_test_)('\0','\x01',0x184);
              (*g_phyFuns->pbus_set_rxgain_)((uint)bVar2 << 8 | (uVar3 & 0x1fff) << 3);
              pbus_rx_dco_cal_1step(bt_mode,'\x01',0x800,rx_dc_comp,dc_est,chan_flag + uVar6);
              rxbb_dc[uStack_3c] = (int)rx_dc_comp[0] << 0x10 | (int)rx_dc_comp[1];
              uStack_3c = uStack_3c + 1 & 0xff;
            }
            else {
              if (mode_start == 2) {
                bVar2 = rx_gain_swp[rf_dc_num - 1];
                (*g_phyFuns->pbus_force_test_)('\0','\x01',0x184);
                (*g_phyFuns->pbus_set_rxgain_)((uint)bVar2 << 8);
                (*g_phyFuns->pbus_force_test_)('\x02','\x02',*(u16 *)((int)rxbb_dc + 6));
                (*g_phyFuns->pbus_force_test_)('\x03','\x02',(ushort)rxbb_dc[1] & 0x1ff);
                pbus_rx_dco_cal_1step(bt_mode,'\x02',0x800,rx_dc_comp,dc_est,chan_flag + uVar6);
              }
              else {
                bVar2 = *pbVar9;
                (*g_phyFuns->pbus_force_test_)('\0','\x01',0x184);
                (*g_phyFuns->pbus_set_rxgain_)((uint)bVar2 << 8);
                pbus_rx_dco_cal_1step(bt_mode,mode_start,0x800,rx_dc_comp,dc_est,chan_flag + uVar6);
                if (mode_start == 0) {
                  rxrf_dc[uStack_40] = (int)rx_dc_comp[0] << 0x10 | (int)rx_dc_comp[1];
                  uStack_40 = uStack_40 + 1 & 0xff;
                  goto LAB_00047dd6;
                }
              }
              puVar11 = chan_dc + uVar6;
              uVar6 = uVar6 + 1 & 0xff;
              *puVar11 = (int)rx_dc_comp[0] << 0x10 | (int)rx_dc_comp[1];
            }
LAB_00047dd6:
            pbVar9 = pbVar9 + 1;
            puVar10 = puVar10 + 1;
          } while (rx_gain_swp + (uStack_50 - 1 & 0xff) + 1 != pbVar9);
        }
        bVar1 = channel < bVar4;
        channel = channel + 1;
      } while (bVar1);
      mode_start = mode_start + 1;
    } while (mode_start < mode_end);
  }
  if (bt_mode) {
    chip_v7_set_chan_ana('\x0e');
  }
  else {
    rx_chan_dc_sort(chan_dc,chan_flag);
  }
  (*g_phyFuns->set_rxclk_en_)(false);
  (*g_phyFuns->set_txclk_en_)(false);
  return;
}



// WARNING: Unknown calling convention

void wr_rx_gain_mem(bool bt_mode,bool rfbb_dc_upd_only,uint8 *rx_gain_swp,uint32 *rxrf_dc,
                   uint32 *rxbb_dc,uint32 *chan_dc,uint8 table_num,uint32 *rx_gain_table)

{
  ushort uVar1;
  char cVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  uint uVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  uint16 bbgain_m [5];
  uint8 upd_num;
  uint8 addr_offset;
  
  uVar3 = (uint)table_num;
  cVar2 = -0x80;
  if (!bt_mode) {
    cVar2 = '\0';
  }
  memcpy(bbgain_m,&DAT_00052870,10);
  uVar4 = (uVar3 - wifi_bbgain_max) - 2 & 0xff;
  uVar7 = uVar4;
  if (!rfbb_dc_upd_only) {
    uVar7 = 0;
  }
  if (uVar7 < uVar3) {
    uVar5 = 0;
    uVar6 = 0;
    do {
      if (rfbb_dc_upd_only) {
        uVar9 = (uint)*(byte *)(bbgain_m + uVar5 / 6) * 8 + uVar5 % 6 & 0xff |
                (uint)*rx_gain_swp << 8;
      }
      else {
        if ((uVar7 & 1) == 0) {
          uVar1 = *(ushort *)(rx_gain_table + (uVar7 >> 1));
        }
        else {
          uVar1 = *(ushort *)((int)rx_gain_table + (uVar7 >> 1) * 4 + 2);
        }
        uVar9 = (uint)uVar1;
        uVar5 = ((int)uVar9 >> 3 & 1U) * 6 + (uVar9 & 7);
      }
      if ((uVar7 < uVar4) || (bt_mode)) {
        if ((uVar9 & 0xffffff00) != (uint)rx_gain_swp[uVar6] << 8) {
          uVar6 = uVar6 + 1 & 0xff;
        }
        iVar15 = 0;
        iVar16 = 0x80;
        uVar10 = rxrf_dc[uVar6] >> 0x10;
        uVar8 = rxrf_dc[uVar6] & 0xffff;
        iVar14 = 0x200000;
        if (!bt_mode) goto LAB_00048020;
      }
      else {
        uVar10 = chan_dc[(int)chip7_sleep_params.phy_channel_num - 1U & 0xffff] >> 0x10;
        uVar8 = chan_dc[(int)chip7_sleep_params.phy_channel_num - 1U & 0xffff] & 0xffff;
LAB_00048020:
        uVar11 = uVar5 / 6;
        uVar13 = rxbb_dc[(uVar11 < 3) * uVar11 + (uint)(uVar11 >= 3) * 3] >> 0x10;
        iVar16 = (int)uVar13 >> 1;
        iVar14 = (rxbb_dc[(uVar11 < 3) * uVar11 + (uint)(uVar11 >= 3) * 3] & 0xffff) << 0xd;
        iVar15 = uVar13 << 0x1f;
      }
      iVar12 = 0;
      if (!bt_mode) {
        uVar13 = uVar9 >> 3 & 0x1f;
        uVar13 = (uVar13 >> 4) + (uVar9 >> 3 & 1) + (uVar13 >> 3 & 1) + (uVar13 >> 2 & 1) +
                 (uVar13 >> 1 & 1);
        iVar12 = (chip7_sleep_params.wifi_rxiq[(uVar13 < 3) * uVar13 + (uint)(uVar13 >= 3) * 3] &
                 0x7ff) << 2;
      }
      (*g_phyFuns->write_gain_mem_)
                (uVar9 * 0x20000 + uVar10 * 0x100 + iVar16,
                 uVar8 * 0x400000 + iVar15 + iVar14 + iVar12,(char)uVar7 + cVar2);
      if (rfbb_dc_upd_only) {
        uVar5 = uVar5 + 1 & 0xff;
      }
      uVar7 = uVar7 + 1 & 0xff;
    } while (uVar7 < uVar3);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_rx_gain_testchip_70
               (bool bt_mode,uint32 *param_flag,uint8 *rx_gain_swp,uint8 table_num,
               uint32 *rx_gain_table,uint8 rf_dc_num)

{
  uint8 uVar1;
  u16 uVar2;
  _func_void_u8_u8_u16 *p_Var3;
  
  if (!bt_mode) {
    _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = _DAT_3ff460a0 | 0x4000;
    memw();
    _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = _DAT_3ff460a0 | 0x8000;
    memw();
    (*g_phyFuns->pbus_debugmode_)();
    (*g_phyFuns->pbus_xpd_rx_on_)((ushort)bt_mode);
    if ((chip7_sleep_params.param_flag & 0x400) == 0) {
      set_rx_gain_cal_iq(false,0x80,chip7_sleep_params.wifi_rxiq,false);
      chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x400;
    }
    _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
    _DAT_3ff450dc = _DAT_3ff450dc & 0xf7ffffff;
    memw();
    (*g_phyFuns->pbus_xpd_rx_on_)(0);
    set_rx_gain_cal_dc(false,'\0','\x03',rx_gain_swp,phy_rxrf_dc,phy_rxbb_dc,phy_rxrf_dc + 0x14,
                       rf_dc_num,'\x04','\x0e');
    _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = _DAT_3ff460a0 & 0xffff7fff;
    memw();
    (*g_phyFuns->pbus_xpd_rx_on_)(0);
    (*g_phyFuns->pbus_workmode_)();
    return;
  }
  uVar1 = (*g_phyFuns->i2c_readReg_Mask_)('g','\x01','\x0f','\x02','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x0f','\x02','\0','\0');
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 | 0x4000;
  memw();
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 | 0x8000;
  memw();
  (*g_phyFuns->pbus_debugmode_)();
  (*g_phyFuns->pbus_xpd_rx_on_)(0);
  p_Var3 = g_phyFuns->pbus_force_test_;
  uVar2 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
  (*p_Var3)('\x01','\x01',uVar2 | 2);
  _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
  _DAT_3ff450dc = _DAT_3ff450dc & 0xf7ffffff;
  memw();
  (*g_phyFuns->pbus_xpd_rx_on_)(0);
  p_Var3 = g_phyFuns->pbus_force_test_;
  uVar2 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
  (*p_Var3)('\x01','\x01',uVar2 | 2);
  set_rx_gain_cal_dc(true,'\0','\x01',rx_gain_swp,phy_rxrf_dc,phy_rxbb_dc,phy_rxrf_dc + 0x14,
                     rf_dc_num,'\0','\0');
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 & 0xffff7fff;
  memw();
  (*g_phyFuns->pbus_xpd_rx_on_)(0);
  (*g_phyFuns->pbus_workmode_)();
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x0f','\x02','\0',uVar1);
  return;
}



// WARNING: Unknown calling convention

void bt_correct_bbgain(uint16 *bbgain,sint8 *dig_atten_in)

{
  char cVar1;
  uint16 uVar2;
  char cVar3;
  uint uVar4;
  sint8 sVar5;
  sint8 dig_atten [8];
  
  sVar5 = *dig_atten_in;
  memw();
  uVar4 = 0;
  if ((*bbgain != 0) && (uVar4 = 1, *bbgain == 0x30)) {
    uVar4 = 2;
  }
  cVar1 = '\x02';
  cVar3 = '\0';
  do {
    if (sVar5 < '1') {
      if (sVar5 < '\f') {
        if (uVar4 < 3) {
          uVar4 = uVar4 + 1 & 0xff;
          cVar3 = cVar3 + '\x18';
          sVar5 = sVar5 + '\x18';
        }
      }
    }
    else if (uVar4 != 0) {
      uVar4 = uVar4 - 1 & 0xff;
      cVar3 = cVar3 + -0x18;
      sVar5 = sVar5 + -0x18;
    }
    cVar1 = cVar1 + -1;
  } while (cVar1 != '\0');
  uVar2 = 0x20;
  if (uVar4 < 3) {
    uVar2 = *(uint16 *)((int)&CSWTCH_360 + uVar4 * 2);
  }
  *bbgain = uVar2;
  memw();
  *dig_atten_in = cVar3 + *dig_atten_in;
  memw();
  return;
}



// WARNING: Unknown calling convention

uint16 bt_index_to_bb(uint16 index)

{
  uint16 uVar1;
  
  uVar1 = 0x20;
  if (index < 3) {
    uVar1 = *(uint16 *)((int)&CSWTCH_360 + (uint)index * 2);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

uint16 bt_bb_to_index(uint16 bbgain)

{
  uint16 uVar1;
  
  uVar1 = 0;
  if ((bbgain != 0) && (uVar1 = 1, bbgain == 0x30)) {
    uVar1 = 2;
  }
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_txdc_cal(void)

{
  if ((chip7_sleep_params.param_flag & 0x1000) == 0) {
    bt_txdc_cal();
  }
  return;
}



// WARNING: Unknown calling convention

uint8 get_bbgain_db(uint16 bbgain)

{
  char cVar1;
  
  cVar1 = '\0';
  if ((bbgain & 1) != 0) {
    cVar1 = '\x06';
  }
  return cVar1 + (char)(bbgain >> 6);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_txiq_cal(void)

{
  if ((chip7_sleep_params.param_flag & 0x800) == 0) {
    bt_txiq_cal();
  }
  return;
}



// WARNING: Unknown calling convention

void force_bttx_gain(bool force_en,uint8 pa_in,uint8 bb_in,uint8 dig_in)

{
  sint8 bt_dig_atten [8];
  
  if (force_en) {
    memw();
    bt_dig_atten[0] = dig_in;
    wr_bt_tx_gain_mem(pa_in,bb_in);
    bt_dig_gain_force = false;
    memw();
    wr_bt_tx_atten(bt_dig_atten);
    bt_dig_gain_force = true;
    memw();
    phy_bt_power_track_en = false;
    memw();
    return;
  }
  phy_bt_power_track_en = true;
  memw();
  memw();
  bt_dig_gain_force = force_en;
  wr_bt_tx_gain_mem(0xff,0xff);
  wr_bt_tx_atten(chip7_sleep_params.bt_dig_atten);
  return;
}



// WARNING: Unknown calling convention

void phy_bttx_low_power(bool force_en,uint8 level)

{
  uint uVar1;
  int iVar2;
  uint8 pa_in;
  uint uVar3;
  uint uVar4;
  
  if (level < 6) {
    if ((force_en) && (level == '\0')) {
      (*g_phyFuns->i2c_writeReg_)('k','\x02','\x01','`');
      (*g_phyFuns->i2c_writeReg_)('k','\x02','\x02','\0');
      pa_in = '\0';
      goto LAB_00048599;
    }
    (*g_phyFuns->set_txcap_reg_)((U8 *)0x5bbf8,chip7_sleep_params.phy_channel_num);
    iVar2 = level - 1;
    pa_in = '\0';
    if (iVar2 < 1) goto LAB_00048599;
  }
  else {
    (*g_phyFuns->set_txcap_reg_)((U8 *)0x5bbf8,chip7_sleep_params.phy_channel_num);
    iVar2 = 4;
  }
  uVar1 = 0;
  uVar3 = 0;
  do {
    uVar4 = uVar3 + (1 << 0x20 - (0x20 - (uVar1 & 0x1f)));
    uVar1 = uVar1 + 1 & 0xff;
    uVar3 = uVar4 & 0xff;
    pa_in = (uint8)uVar4;
  } while ((int)uVar1 < iVar2);
LAB_00048599:
  force_bttx_gain(force_en,pa_in,'\0','(');
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_wifitx_low_power(bool force_en,uint8 level,sint8 gain_atten)

{
  uint uVar1;
  char cVar2;
  uint uVar3;
  uint uVar4;
  U16 pa_gain;
  U16 bbgain;
  uint uVar5;
  uint uVar6;
  sint8 gain_table [8];
  
  if (10 < level) {
    level = '\v';
  }
  if (gain_atten < '\a') {
    if (gain_atten < -5) {
      gain_atten = -5;
    }
  }
  else {
    gain_atten = '\x06';
  }
  if (!force_en) {
    phy_tx_pwr_track_en = true;
    memw();
    memw();
    force_tx_gain_en = force_en;
    tx_gain_table_set();
    return;
  }
  uVar3 = (uint)(byte)(level - 1);
  if (uVar3 < 0xb) {
    uVar4 = 0;
    uVar5 = 0;
    uVar6 = *(ushort *)(CSWTCH_371 + uVar3 * 2) / 6;
    uVar1 = (uint)*(ushort *)(CSWTCH_371 + uVar3 * 2) % 6;
    cVar2 = CSWTCH_373[uVar3];
    pa_gain = *(U16 *)(CSWTCH_372 + uVar3 * 2);
    if (uVar6 == 0) {
      bbgain = (U16)(uVar1 << 6);
    }
    else {
      do {
        uVar3 = uVar5 + (1 << 0x20 - (0x20 - (5 - uVar4 & 0x1f)));
        uVar4 = uVar4 + 1 & 0xff;
        uVar5 = uVar3 & 0xffff;
      } while (uVar4 < uVar6);
      bbgain = (short)uVar3 + (short)uVar1 * 0x40;
    }
  }
  else {
    bbgain = 0;
    cVar2 = -0xe;
    pa_gain = 0;
  }
  set_tx_gain_table(pa_gain,bbgain);
  gain_table[0] = (phy_chan_gain_table[0] - (phy_chan_gain_table[5] - cVar2)) - gain_atten;
  memw();
  memw();
  DAT_3ff46004 = gain_table[0];
  DAT_3ff46004_1._0_1_ = gain_table[1];
  DAT_3ff46004_1._1_1_ = gain_table[2];
  DAT_3ff46004_1._2_1_ = gain_table[3];
  memw();
  _DAT_3ff46008 = gain_table._4_4_;
  phy_tx_pwr_track_en = false;
  memw();
  force_tx_gain_en = true;
  memw();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void set_tx_gain_table_bt(void)

{
  if ((chip7_sleep_params.param_flag & 0x1000) == 0) {
    bt_txdc_cal();
  }
  if ((chip7_sleep_params.param_flag & 0x800) == 0) {
    bt_txiq_cal();
  }
  bt_tx_pwctrl_init();
  if (bt_dig_gain_force == false) {
    bt_tx_gain_cal_set();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_tx_dig_gain(int force_en,int force_value)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46000);
  _DAT_3ff46000 = (force_value & 0xffU) << 2 | uVar1 & 0xfffffc03;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46000);
  memw();
  _DAT_3ff46000 = uVar1 & 0xfffffffe | force_en & 1U;
  return;
}



// WARNING: Unknown calling convention

int spur_cal(uint16 freq,int8 BW_h,uint16 spur_freq_cfg,uint8 spur_freq_cfg_div)

{
  int iVar1;
  
  if ((spur_freq_cfg_div != '\0') && (spur_freq_cfg != 0)) {
    iVar1 = spur_cal(freq,BW_h,spur_freq_cfg,spur_freq_cfg_div);
    return iVar1;
  }
  return 0;
}



// WARNING: Unknown calling convention

int set_chanfreq(uint16 chanFreq,int8 sub_chan_cfg)

{
  int8 channel;
  
  channel = (*g_phyFuns->mhz2ieee_)(chanFreq,0x80);
  chip_v7_set_chan(channel,sub_chan_cfg);
  return 0;
}



// WARNING: Unknown calling convention

int set_chanfreq_nomac(uint16 chanFreq,int8 sub_chan_cfg)

{
  int8 channel;
  
  channel = (*g_phyFuns->mhz2ieee_)(chanFreq,0x80);
  chip_v7_set_chan_nomac(channel,sub_chan_cfg);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void chip_sleep_prot_en(void)

{
  uint uVar1;
  
  _DAT_60033cb8 = esp_dport_access_reg_read(&DAT_60033cb8);
  _DAT_60033cb8 = _DAT_60033cb8 | 0x8000;
  memw();
  while (uVar1 = esp_dport_access_reg_read(&DAT_60033cb8), (uVar1 & 0x6000) != 0) {
    ets_delay_us(2);
  }
  _DAT_60033cb8 = esp_dport_access_reg_read(&DAT_60033cb8);
  _DAT_60033cb8 = _DAT_60033cb8 | 0x7ff8000;
  memw();
  while (uVar1 = esp_dport_access_reg_read(&DAT_60033cb8), (uVar1 & 0x6000) != 0) {
    ets_delay_us(2);
  }
  (*g_phyFuns->disable_agc_)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void chip_sleep_prot_dis(void)

{
  uint uVar1;
  
  (*g_phyFuns->enable_agc_)();
  uVar1 = esp_dport_access_reg_read(&DAT_60033cb8);
  memw();
  _DAT_60033cb8 = uVar1 & 0xf8007fff;
  return;
}



void chip_v7_rxmax_ext_dig(void)

{
  return;
}



// WARNING: Unknown calling convention

void chip_v7_rxmax_ext(uint8 ext_level)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_cca(bool en,s8 cca_thr)

{
  uint uVar1;
  
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = _DAT_3ff5c018 | 0x40000000;
  memw();
  if ((en) && (cca_thr != '\0' && en)) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c01c);
    memw();
    _DAT_3ff5c01c = uVar1 & 0xffffff00 | (uint)(byte)cca_thr;
    return;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c01c);
  memw();
  _DAT_3ff5c01c = uVar1 & 0xffffff00 | 0xbf;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_rx_sense(sint8 sense_thr)

{
  bool bVar1;
  uint uVar2;
  uint uVar3;
  short sVar4;
  short sVar5;
  uint uVar6;
  
  memw();
  corr_cca_thr = sense_thr;
  uVar2 = esp_dport_access_reg_read(&DAT_3ff5c018);
  uVar6 = corr_cca_thr * 2 - (int)((uVar2 >> 5 & 0x3ff) - 0x3ff) / 2;
  bVar1 = sense_thr == 0;
  uVar2 = (sense_thr + 0x100) * 4;
  sVar4 = (short)uVar6;
  sVar5 = (short)uVar2;
  if ((sVar4 < 0x13) || (bVar1)) {
    uVar3 = esp_dport_access_reg_read(&DAT_3ff5c01c);
    _DAT_3ff5c01c = uVar3 & 0xff00ffff | 0x120000;
    memw();
  }
  else {
    uVar3 = esp_dport_access_reg_read(&DAT_3ff5c01c);
    _DAT_3ff5c01c = (uVar6 & 0xff) << 0x10 | uVar3 & 0xff00ffff;
    memw();
  }
  if ((sVar4 < 0xd) || (bVar1)) {
    uVar3 = esp_dport_access_reg_read(&DAT_3ff5c010);
    _DAT_3ff5c010 = uVar3 & 0x7fffff | 0x6000000;
    memw();
  }
  else {
    uVar3 = esp_dport_access_reg_read(&DAT_3ff5c010);
    _DAT_3ff5c010 = uVar3 & 0x7fffff | (uVar6 & 0xffff) << 0x17;
    memw();
  }
  if ((sVar4 < 3) || (bVar1)) {
    uVar3 = esp_dport_access_reg_read(&DAT_3ff5c014);
    _DAT_3ff5c014 = uVar3 & 0x7fffff | 0x1000000;
    memw();
  }
  else {
    uVar3 = esp_dport_access_reg_read();
    _DAT_3ff5c014 = uVar3 & 0x7fffff | (uVar6 & 0xffff) << 0x17;
    memw();
  }
  if (!bVar1 && 0x2a8 < sVar5) {
    uVar3 = esp_dport_access_reg_read(&DAT_3ff5c0cc);
    _DAT_3ff5c0cc = uVar3 & 0xfffffc00 | uVar2 & 0x3ff;
    memw();
  }
  else {
    uVar3 = esp_dport_access_reg_read(&DAT_3ff5c0cc);
    _DAT_3ff5c0cc = uVar3 & 0xfffffc00 | 0x2a8;
    memw();
  }
  if ((sVar5 < 0x28f) || (bVar1)) {
    uVar3 = esp_dport_access_reg_read(&DAT_3ff5c0cc);
    _DAT_3ff5c0cc = uVar3 & 0xfff003ff | 0xa3800;
    memw();
  }
  else {
    uVar3 = esp_dport_access_reg_read();
    _DAT_3ff5c0cc = (uVar2 & 0x3ff) << 10 | uVar3 & 0xfff003ff;
    memw();
  }
  if (!bVar1 && 0x2a8 < sVar5) {
    uVar3 = esp_dport_access_reg_read();
    _DAT_3ff5c0cc = (uVar2 & 0x3ff) << 0x14 | uVar3 & 0xc00fffff;
    memw();
  }
  else {
    uVar2 = esp_dport_access_reg_read(&DAT_3ff5c0cc);
    _DAT_3ff5c0cc = uVar2 & 0xc00fffff | 0x2a800000;
    memw();
  }
  if ((sVar4 < -1) || (bVar1)) {
    uVar2 = esp_dport_access_reg_read(&DAT_3ff5c044);
    _DAT_3ff5c044 = uVar2 & 0xffffff00 | 0xfe;
    memw();
  }
  else {
    uVar2 = esp_dport_access_reg_read();
    _DAT_3ff5c044 = uVar2 & 0xffffff00 | uVar6 & 0xff;
    memw();
  }
  if ((0x20 < sVar4) && (!bVar1)) {
    uVar2 = esp_dport_access_reg_read(&DAT_3ff5c124);
    memw();
    _DAT_3ff5c124 = (uVar6 & 0xff) << 0x10 | uVar2 & 0xff00ffff;
    return;
  }
  uVar2 = esp_dport_access_reg_read(&DAT_3ff5c124);
  memw();
  _DAT_3ff5c124 = uVar2 & 0xff00ffff | 0x200000;
  return;
}



// WARNING: Unknown calling convention

sint16 read_hw_noisefloor(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c018);
  return ((ushort)(uVar1 >> 5) & 0x3ff) - 0x400;
}



// WARNING: Unknown calling convention

void phy_get_txpwr_param(S8 *txpwr_backoff,S8 *txpwr_diff_flash,U16 *txpwr_ana_gain,
                        sint8 *txpwr_dig_atten,S8 *txpwr_correct_pwr,S16 *txpwr_meas_error)

{
  *txpwr_backoff = (S8)chip7_sleep_params.target_power_chan_backoff[0];
  memw();
  *txpwr_dig_atten = chip7_sleep_params.tx_pwctrl_atten[5];
  *txpwr_diff_flash = '\0';
  txpwr_diff_flash[1] = '\0';
  memw();
  *txpwr_ana_gain =
       chip7_sleep_params.loop_tx_rf_ana_gain[0] << 9 | chip7_sleep_params.loop_tx_rf_ana_gain[1];
  memw();
  *txpwr_correct_pwr = chip7_sleep_params.loop_pwctrl_correct_power_qdb;
  memw();
  *txpwr_meas_error = phy_tx_pwr_error;
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void noise_check_loop(uint8 check_level,bool set_noise_en)

{
  sint16 sVar1;
  ushort uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  _DAT_3ff5d044 = esp_dport_access_reg_read(&DAT_3ff5d044);
  _DAT_3ff5d044 = _DAT_3ff5d044 & 0xfffffffe;
  memw();
  _DAT_3ff5d050 = esp_dport_access_reg_read(&DAT_3ff5d050);
  _DAT_3ff5d050 = _DAT_3ff5d050 | 1;
  memw();
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = _DAT_3ff5c018 | 0x8000000;
  memw();
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  sVar1 = chip7_sleep_params.loop_noisefloor;
  _DAT_3ff5c018 = _DAT_3ff5c018 & 0xf7ffffff;
  memw();
  uVar2 = esp_dport_access_reg_read(0x3ff5c050);
  phy_meas_noise_floor = (uVar2 & 0x3ff) - 0x400;
  iVar5 = (int)phy_meas_noise_floor;
  memw();
  iVar4 = (int)sVar1;
  if (0x3e < (ushort)((uVar2 & 0x3ff) - 0x26d)) goto LAB_00048eb6;
  iVar6 = -0x160;
  if (iVar5 < -0x15f) {
    iVar6 = (uint)(iVar5 < -0x188) * -0x188 + (uint)(iVar5 >= -0x188) * iVar5;
  }
  if (iVar4 < iVar6) {
    iVar6 = iVar4 * 3 + iVar6;
LAB_00048e49:
    iVar4 = iVar6 + -2;
    if (iVar6 + -2 < 0) {
      iVar4 = iVar6 + 1;
    }
    chip7_sleep_params.loop_noisefloor = (sint16)(iVar4 >> 2);
    iVar4 = (int)chip7_sleep_params.loop_noisefloor;
    memw();
  }
  else if (iVar6 < iVar4) {
    if (iVar4 + -0x10 <= iVar6) {
      iVar6 = iVar6 * 3 + iVar4;
      goto LAB_00048e49;
    }
    chip7_sleep_params.loop_noisefloor = sVar1 + -0xc;
    iVar4 = (int)chip7_sleep_params.loop_noisefloor;
    memw();
  }
  else {
    iVar4 = (int)chip7_sleep_params.loop_noisefloor;
  }
  if (sw_scan_mode == false) {
    if ((iVar4 <= chip7_sleep_params.rx_noise + 4) && (chip7_sleep_params.rx_noise + -4 <= iVar4))
    goto LAB_00048eb6;
LAB_00048e98:
    chip7_sleep_params.rx_noise = (sint16)iVar4;
    memw();
  }
  else {
    if (iVar4 < -0x17f) goto LAB_00048e98;
    chip7_sleep_params.rx_noise = (sint16)((iVar4 + -0x180) / 2);
    memw();
  }
  if (set_noise_en) {
    (*g_phyFuns->set_noise_floor_)(chip7_sleep_params.rx_noise);
  }
LAB_00048eb6:
  uVar3 = esp_dport_access_reg_read(&DAT_3ff5d044);
  memw();
  _DAT_3ff5d044 = uVar3 | 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void noise_init(void)

{
  sint16 sVar1;
  uint uVar2;
  char channel;
  int iVar3;
  sint16 *psVar4;
  int iVar5;
  _func_sint16_varargs *p_Var6;
  
  _DAT_3ff5c018 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = _DAT_3ff5c018 | 0x10000000;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff5c018);
  _DAT_3ff5c018 = uVar2 & 0xfffffff8 | 4;
  memw();
  if ((chip7_sleep_params.param_flag & 0x200000) == 0) {
    psVar4 = noise_array;
    channel = '\x01';
    uVar2 = 0;
    do {
      chip7_sleep_params.phy_sub_chan_cfg = '\0';
      memw();
      chip_v7_set_chan_nomac(channel,'\n');
      p_Var6 = g_phyFuns->check_noise_floor_;
      *psVar4 = 0;
      memw();
      sVar1 = (*p_Var6)();
      if (sVar1 < 1) {
        if (sVar1 < *psVar4) {
          *psVar4 = sVar1;
          memw();
        }
      }
      else {
        if (-sVar1 < *psVar4) {
          *psVar4 = -sVar1;
          memw();
        }
        noise_timeout_flag = (byte)(1 << 0x20 - (0x20 - (uVar2 & 0x1f))) | noise_timeout_flag;
        memw();
      }
      uVar2 = uVar2 + 1;
      channel = channel + '\x05';
      psVar4 = psVar4 + 1;
    } while (uVar2 != 3);
    iVar5 = (uint)(noise_array[0] < 0) * (int)noise_array[0];
    iVar3 = (int)noise_array[1];
    iVar5 = (uint)(iVar5 < iVar3) * iVar5 + (uint)(iVar5 >= iVar3) * iVar3;
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x200000;
    chip7_sleep_params.rx_noise =
         (ushort)(iVar5 < noise_array[2]) * (short)iVar5 +
         (ushort)(iVar5 >= noise_array[2]) * noise_array[2];
    chip7_sleep_params.loop_noisefloor = chip7_sleep_params.rx_noise;
  }
  (*g_phyFuns->set_noise_floor_)(chip7_sleep_params.rx_noise);
  return;
}



// WARNING: Unknown calling convention

void target_power_backoff(S8 backoff_qdb)

{
  chip7_sleep_params.loop_pwctrl_correct_atten =
       (short)backoff_qdb +
       (chip7_sleep_params.loop_pwctrl_correct_atten - target_power_backoff_qdb);
  target_power_backoff_qdb = (sint16)backoff_qdb;
  memw();
  set_chan_dig_gain(chip7_sleep_params.phy_channel_num);
  return;
}



// WARNING: Unknown calling convention

void phy_set_rfrx_dcap(bool enable)

{
  if ((rfrx_dcap_enable == '\0') && (enable)) {
    rfrx_vga_lna_dcap[0] = (*g_phyFuns->i2c_readReg_Mask_)('d','\0','\a','\x03','\0');
    memw();
    rfrx_vga_lna_dcap[1] = (*g_phyFuns->i2c_readReg_Mask_)('d','\0','\x04','\x03','\0');
    memw();
  }
  else if (!enable) {
    if (rfrx_dcap_enable != '\0') {
      (*g_phyFuns->i2c_writeReg_Mask_)('d',enable,'\a','\x03',enable,rfrx_vga_lna_dcap[0]);
      (*g_phyFuns->i2c_writeReg_Mask_)('d',enable,'\x04','\x03',enable,rfrx_vga_lna_dcap[1]);
      set_chan_rxcomp(enable);
    }
    rfrx_dcap_enable = '\0';
    memw();
    return;
  }
  (*g_phyFuns->i2c_writeReg_Mask_)('d','\0','\a','\x03','\0','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('d','\0','\x04','\x03','\0','\0');
  set_chan_rxcomp(-0x1c);
  rfrx_dcap_enable = '\x01';
  memw();
  return;
}



// WARNING: Unknown calling convention

void chip_v7_set_chan_misc(int8 channel)

{
  (*g_phyFuns->set_noise_floor_)(chip7_sleep_params.rx_noise);
  if ((re_entry == '\0') || (phy_init_flag == false)) {
    wr_rx_gain_mem(false,true,&rfbb_gain_swp,phy_rxrf_dc + 9,phy_rxbb_dc,phy_rxrf_dc + 0x14,
                   chip7_sleep_params.wifi_rx_gain_max + '\x01',(uint32 *)0x0);
  }
  set_chan_rxcomp('\0');
  (*g_phyFuns->set_txcap_reg_)((U8 *)0x5bbf8,channel);
  if ((re_entry == '\0') || (phy_init_flag == false)) {
    set_chan_dig_gain(channel);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_rx_gain_table(u16 freq,uint8 wifi_gain_offset)

{
  uint uVar1;
  byte rx_gain_swp_num;
  uint32 phy_rx_gain_gen [85];
  uint8 bt_rx_gain_swp_step [12];
  uint8 wifi_rx_gain_swp_step [12];
  
  rx_gain_swp_num = 0xc - wifi_gain_offset;
  wifi_bbgain_max = '\x16';
  if (2 < wifi_gain_offset) {
    wifi_bbgain_max = '\x1c';
  }
  memw();
  memcpy(wifi_rx_gain_swp_step,&DAT_00052894,0xc);
  memcpy(bt_rx_gain_swp_step,&DAT_000528a0,0xc);
  rfbb_gain_swp = *(uint8 *)(rx_gain_swp_num + 0x59c5b);
  memw();
  if ((chip7_sleep_params.param_flag & 0x200) == 0) {
    (*g_phyFuns->set_rf_freq_offset_)(chip7_phy_init_ctrl.crystal_select,freq,0);
    chip7_sleep_params.bt_rx_gain_max =
         ram_gen_rx_gain_table
                   (phy_rx_gain_gen,'\x1c',bt_rx_gain_swp,(sint8 *)bt_rx_gain_swp_step,'\t','\x06',
                    false);
    chip7_sleep_params.wifi_rx_gain_max =
         ram_gen_rx_gain_table
                   (phy_rx_gain_gen + 0x28,wifi_bbgain_max,wifi_rx_gain_swp,
                    (sint8 *)wifi_rx_gain_swp_step,rx_gain_swp_num,'\0',false);
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x200;
  }
  if ((chip7_sleep_params.param_flag & 0x100) == 0) {
    set_rx_gain_testchip_70
              (true,&chip7_sleep_params.param_flag,bt_rx_gain_swp,
               chip7_sleep_params.bt_rx_gain_max + '\x01',phy_rx_gain_gen,'\t');
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x100;
  }
  if ((chip7_sleep_params.param_flag & 0x20000) == 0) {
    set_rx_gain_testchip_70
              (false,&chip7_sleep_params.param_flag,wifi_rx_gain_swp,
               chip7_sleep_params.wifi_rx_gain_max + '\x01',phy_rx_gain_gen + 0x28,rx_gain_swp_num);
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x20000;
  }
  if ((chip7_sleep_params.param_flag & 0x20) == 0) {
    wr_rx_gain_mem(true,false,bt_rx_gain_swp,phy_rxrf_dc,phy_rxbb_dc,phy_rxrf_dc + 0x14,
                   chip7_sleep_params.bt_rx_gain_max + '\x01',phy_rx_gain_gen);
    wr_rx_gain_mem(false,false,wifi_rx_gain_swp,phy_rxrf_dc + 9,phy_rxbb_dc,phy_rxrf_dc + 0x14,
                   chip7_sleep_params.wifi_rx_gain_max + '\x01',phy_rx_gain_gen + 0x28);
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x20;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = (chip7_sleep_params.wifi_rx_gain_max & 0x7f) << 8 | uVar1 & 0xffff80ff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c0a4);
  _DAT_3ff5c0a4 = (chip7_sleep_params.bt_rx_gain_max & 0x7f) << 0xf | uVar1 & 0xffc07fff;
  memw();
  _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
  _DAT_3ff450dc = _DAT_3ff450dc | 0x800;
  memw();
  _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
  _DAT_3ff450dc = _DAT_3ff450dc | 0x1000;
  memw();
  _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
  _DAT_3ff450dc = _DAT_3ff450dc | 0x8000000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff450dc);
  memw();
  _DAT_3ff450dc = uVar1 | 0x10000000;
  return;
}



// WARNING: Unknown calling convention

void rx_blocking_set(uint8 level)

{
  chip7_sleep_params.param_flag = chip7_sleep_params.param_flag & 0xfffdfddf;
  set_rx_gain_table(0x985,level);
  return;
}



// WARNING: Unknown calling convention

void rx_gain_level(bool level)

{
  if (level) {
    level = true;
  }
  rx_blocking_set(level);
  return;
}



// WARNING: Removing unreachable block (ram,0x00049501)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void txiq_cal_init(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  short sVar4;
  int iVar5;
  uint16 bbgain;
  uint16 lb_txdc [4];
  
  if ((chip7_sleep_params.param_flag & 0x4000) == 0) {
    iVar5 = (int)chip7_sleep_params.tx_pwctrl_atten[0x14];
    iVar2 = 0;
    do {
      bbgain = 0x20;
      iVar1 = 4;
      if (iVar2 != 0) {
        bbgain = 0x30;
        iVar1 = 0x10;
      }
      sVar4 = 0;
      if ((tx_rf_ana_gain[1] & 1) != 0) {
        sVar4 = 6;
      }
      sVar4 = ((tx_rf_ana_gain[1] >> 6 & 0xff) + sVar4 & 0xff) * -4 +
              (ushort)(-1 < iVar5 + 0x2b) * (short)(iVar5 + 0x2b);
      if (sVar4 < 0) {
        sVar4 = 0;
      }
      else if (0x78 < sVar4) {
        sVar4 = 0x78;
      }
      iVar3 = iVar2 + 1;
      rfcal_txiq(bbgain,chip7_sleep_params.txdc_table + iVar1,chip7_sleep_params.wifi_txiq + iVar2,
                 0x80,(int8)sVar4,'\0');
      iVar2 = iVar3;
    } while (iVar3 != 2);
    rfcal_txiq(bbgain,lb_txdc,&chip7_sleep_params.lb_txiq,0x80,
               (-1 < (short)(sVar4 + -0x28)) * (char)(sVar4 + -0x28),'\x02');
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x4000;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_rx11blr_cfg(uint8 en)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c860);
  _DAT_3ff5c860 = (en & 1) << 10 | uVar1 & 0xfffffbff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c860);
  uVar2 = (en & 1) << 0xb;
  _DAT_3ff5c860 = uVar1 & 0xfffff7ff | uVar2;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c87c);
  memw();
  _DAT_3ff5c87c = uVar1 & 0xfffff7ff | uVar2;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void analog_gain_init(void)

{
  char cVar1;
  uint16 dco [4];
  
  dco[2] = 0x100;
  dco[3] = 0x100;
  dco[0] = 0x100;
  dco[1] = 0x100;
  memw();
  (*g_phyFuns->pbus_debugmode_)();
  (*g_phyFuns->pbus_force_test_)('\x04','\x01',0);
  (*g_phyFuns->pbus_force_test_)('\x05','\x01',0);
  (*g_phyFuns->pbus_force_test_)('\0','\x01',0x184);
  cVar1 = '\x01';
  do {
    if (cVar1 == '\x01') {
      (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x189);
      (*g_phyFuns->pbus_force_test_)('\x01','\x02',0);
      (*g_phyFuns->pbus_set_dco_)(dco);
    }
    else {
      (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x18b);
      (*g_phyFuns->pbus_force_test_)('\x01','\x02',0);
      (*g_phyFuns->pbus_set_dco_)(dco);
      if (cVar1 == '\x02') {
        (*g_phyFuns->pbus_workmode_)();
        return;
      }
    }
    cVar1 = cVar1 + '\x01';
  } while( true );
}



// WARNING: Unknown calling convention

void phy_param_set(uint8 mode_set)

{
  if (mode_set == '\0') {
    wifi_txband = '_';
    memw();
    wifi_txband_ht40 = 0xc3;
    memw();
    return;
  }
  wifi_txband = 'K';
  memw();
  wifi_txband_ht40 = 0x96;
  memw();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bb_init(void)

{
  if ((chip7_sleep_params.param_flag & 0x10000) == 0) {
    (*g_phyFuns->set_pbus_mem_)();
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x10000;
  }
  rc_cal();
  if ((chip7_sleep_params.param_flag & 0x80000) == 0) {
    (*g_phyFuns->txdc_cal_init_)
              (chip7_sleep_params.txdc_table,tx_rf_ana_gain[0],tx_rf_ana_gain[1],false);
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x80000;
  }
  tx_cap_init();
  txpwr_offset(0);
  tx_pwctrl_init('\x01');
  txiq_cal_init();
  if ((re_entry == '\0') || (phy_init_flag == false)) {
    set_tx_gain_table(tx_rf_ana_gain[0],tx_rf_ana_gain[1]);
    write_txrate_power_offset(false);
    set_tx_gain_table_bt();
  }
  tsens_read_init();
  set_rx_gain_table(0x985,'\x03');
  analog_gain_init();
  force_txrxoff(false);
  phy_reg_init();
  chip7_sleep_params.rx_noise = -0x180;
  chip7_sleep_params.loop_noisefloor = -0x180;
  memw();
  chip_v7_set_chan('\v','\0');
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void wifi_rifs_mode_en(bool enable)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c0f4);
  memw();
  _DAT_3ff5c0f4 = uVar1 & 0xfffffffe | enable & 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_chan_filt_set(bool filt_en,bool merge_en)

{
  uint uVar1;
  
  if (filt_en) {
    _DAT_3ff5cc0c = esp_dport_access_reg_read(&DAT_3ff5cc0c);
    _DAT_3ff5cc0c = _DAT_3ff5cc0c & 0xffdfffff;
    memw();
    _DAT_3ff5cc0c = esp_dport_access_reg_read(&DAT_3ff5cc0c);
    _DAT_3ff5cc0c = _DAT_3ff5cc0c & 0xffbfffff;
    memw();
  }
  else {
    _DAT_3ff5cc0c = esp_dport_access_reg_read(&DAT_3ff5cc0c);
    _DAT_3ff5cc0c = _DAT_3ff5cc0c | 0x200000;
    memw();
    _DAT_3ff5cc0c = esp_dport_access_reg_read(&DAT_3ff5cc0c);
    _DAT_3ff5cc0c = _DAT_3ff5cc0c | 0x400000;
    memw();
    _DAT_3ff5cd08 = esp_dport_access_reg_read(&DAT_3ff5cd08);
    _DAT_3ff5cd08 = _DAT_3ff5cd08 & 0xfffffff8;
    memw();
    _DAT_3ff5cd04 = esp_dport_access_reg_read(&DAT_3ff5cd04);
    _DAT_3ff5cd04 = _DAT_3ff5cd04 & 0xfffffff8;
    memw();
  }
  if (merge_en) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c074);
    memw();
    _DAT_3ff5c074 = uVar1 & 0xffffdfff;
    return;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c074);
  memw();
  _DAT_3ff5c074 = uVar1 | 0x2000;
  return;
}



// WARNING: Unknown calling convention

uint8 phy_get_tx_rate(void)

{
  byte extraout_var;
  uint32_t val;
  
  esp_dport_access_reg_read(&DAT_3ff4e060);
  return extraout_var & 0x7f;
}



// WARNING: Unknown calling convention

int register_chipv7_phy_init_param(s8 *init_param)

{
  char cVar1;
  uint8 uVar2;
  phy_init_ctrl_t *ppVar3;
  char *pcVar4;
  char *pcVar5;
  
  chip7_phy_init_ctrl.param_ver_id = *init_param;
  uVar2 = init_param[1];
  memw();
  if (uVar2 == '\x03') {
    cVar1 = rtc_get_xtal();
    uVar2 = '\x02';
    if (cVar1 != '\x18') {
      uVar2 = cVar1 == '\x1a';
    }
  }
  memw();
  ppVar3 = &chip7_phy_init_ctrl;
  pcVar4 = init_param + 0x20;
  chip7_phy_init_ctrl.crystal_select = uVar2;
  do {
    cVar1 = *pcVar4;
    pcVar5 = pcVar4 + 1;
    ppVar3->gain_cmp[0] = cVar1;
    memw();
    ppVar3->gain_cmp_ext2[0] = cVar1 + pcVar4[3];
    ppVar3->gain_cmp_ext3[0] = -0x1e;
    memw();
    ppVar3 = (phy_init_ctrl_t *)&ppVar3->crystal_select;
    pcVar4 = pcVar5;
  } while (pcVar5 != init_param + 0x23);
  chip7_phy_init_ctrl.gain_cmp_bt_ofs[0] = init_param[0x29];
  chip7_phy_init_ctrl.gain_cmp_bt_ofs[1] = init_param[0x2a];
  chip7_phy_init_ctrl.gain_cmp_bt_ofs[2] = init_param[0x2b];
  memw();
  chip7_phy_init_ctrl.target_power_init[0] = init_param[0x2c];
  memw();
  chip7_phy_init_ctrl.ratepwr_offset[0] = init_param[0x32];
  memw();
  chip7_phy_init_ctrl.pwr_ind_11b_en = init_param[0x3a];
  chip7_phy_init_ctrl.pwr_ind_11b[0] = init_param[0x3b];
  chip7_phy_init_ctrl.pwr_ind_11b[1] = init_param[0x3c];
  chip7_phy_init_ctrl.fcc_enable = init_param[0x3d];
  memw();
  chip7_phy_init_ctrl.chan_pwr_limit_cbw20[0] = init_param[0x3e];
  memw();
  chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40[0] = init_param[0x4c];
  memw();
  chip7_phy_init_ctrl.pwrdet_new_en = init_param[0x51];
  memw();
  chip7_phy_init_ctrl.fc_chan_pwr_limit_cbw40_h[0] = init_param[0x52];
  memw();
  chip7_phy_init_ctrl.spur_freq_cfg_div_1 = init_param[0x5c];
  memw();
  chip7_phy_init_ctrl.spur_freq_cfg_div_2 = init_param[0x61];
  memw();
  chip7_phy_init_ctrl.spur_freq_cfg_div_3 = init_param[0x66];
  memw();
  chip7_phy_init_ctrl.force_freq_offset_enbale = init_param[0x69];
  chip7_phy_init_ctrl.spur_freq_cfg_1 = CONCAT11(init_param[0x5a],init_param[0x5b]);
  chip7_phy_init_ctrl.spur_freq_en_1 =
       (ushort)(((byte)init_param[0x5d] & 0x7f) << 8) | (ushort)(byte)init_param[0x5e];
  chip7_phy_init_ctrl.spur_freq_cfg_2 = CONCAT11(init_param[0x5f],init_param[0x60]);
  chip7_phy_init_ctrl.spur_freq_en_2 =
       (ushort)(((byte)init_param[0x62] & 0x7f) << 8) | (ushort)(byte)init_param[99];
  chip7_phy_init_ctrl.spur_freq_cfg_3 = CONCAT11(init_param[100],init_param[0x65]);
  chip7_phy_init_ctrl.spur_freq_en_3 =
       (ushort)(((byte)init_param[0x67] & 0x7f) << 8) | (ushort)(byte)init_param[0x68];
  chip7_phy_init_ctrl.force_freq_offset_num = init_param[0x6a];
  memw();
  chip7_phy_init_ctrl.chan_pwr_limit_cbw20_gn[0] = init_param[0x6b];
  memw();
  return (uint)(byte)init_param[0x6b];
}



// WARNING: Unknown calling convention

void uart_wait_idle(U8 uart_no)

{
  uint uVar1;
  
  do {
    uVar1 = esp_dport_access_reg_read((uart_no + 0x3ff4) * 0x10000 + 0x1c);
  } while ((uVar1 & 0xff0000) != 0);
  ets_delay_us(100);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_get_romfunc_addr(void)

{
  phy_romfuncs *ppVar1;
  
  ppVar1 = (phy_romfuncs *)phy_get_romfuncs();
  g_phyFuns = ppVar1;
  ppVar1->pbus_force_mode_ = ram_pbus_force_mode;
  ppVar1->rfpll_reset_ = ram_rfpll_reset;
  ppVar1->restart_cal_ = ram_restart_cal;
  ppVar1->wait_rfpll_cal_end_ = ram_wait_rfpll_cal_end;
  ppVar1->phy_get_vdd33_ = ram_phy_get_vdd33;
  ppVar1->set_chan_cal_interp_ = ram_set_chan_cal_interp;
  ppVar1->pbus_rx_dco_cal_ = ram_pbus_rx_dco_cal;
  ppVar1->txdc_cal_v70_ = ram_txdc_cal_v70;
  ppVar1->spur_coef_cfg_ = ram_spur_coef_cfg;
  ppVar1->set_pbus_mem_ = ram_set_pbus_mem;
  ppVar1->write_gain_mem_ = ram_write_gain_mem;
  ppVar1->bb_bss_bw_40_en_ = ram_bb_bss_bw_40_en;
  ppVar1->bb_tx_ht20_cen_ = ram_bb_tx_ht20_cen;
  ppVar1->bb_bss_cbw40_dig_ = ram_bb_bss_cbw40_dig;
  ppVar1->cbw2040_cfg_ = ram_cbw2040_cfg;
  ppVar1->enable_agc_ = ram_enable_agc;
  ppVar1->phy_enable_agc_ = ram_enable_agc;
  ppVar1->dc_iq_est_ = ram_dc_iq_est;
  ppVar1->tx_pwctrl_bg_init_ = ram_tx_pwctrl_bg_init;
  ppVar1->start_tx_tone_ = ram_start_tx_tone;
  ppVar1->get_fm_sar_dout_ = ram_get_fm_sar_dout;
  ppVar1->txiq_get_mis_pwr_ = ram_txiq_get_mis_pwr;
  ppVar1->iq_est_enable_ = ram_iq_est_enable;
  ppVar1->iq_est_disable_ = ram_iq_est_disable;
  ppVar1->check_noise_floor_ = ram_check_noise_floor;
  ppVar1->rfcal_pwrctrl_ = ram_rfcal_pwrctrl;
  ppVar1->phy_get_noisefloor_ = ram_phy_get_noisefloor;
  ppVar1->en_pwdet_ = ram_en_pwdet;
  ppVar1->set_noise_floor_ = ram_set_noise_floor;
  ppVar1->disable_agc_ = ram_disable_agc;
  ppVar1->phy_disable_agc_ = ram_disable_agc;
  ppVar1->read_sar_dout_ = ram_read_sar_dout;
  ppVar1->pbus_xpd_tx_on_ = ram_pbus_xpd_tx_on;
  ppVar1->rfcal_txcap_ = ram_rfcal_txcap;
  ppVar1->txbbgain_to_index_ = ram_txbbgain_to_index;
  ppVar1->index_to_txbbgain_ = ram_index_to_txbbgain;
  ppVar1->chip_i2c_readReg_ = ram_chip_i2c_readReg;
  ppVar1->chip_i2c_writeReg_ = ram_chip_i2c_writeReg;
  ppVar1->txcal_work_mode_ = ram_txcal_work_mode;
  ppVar1->set_txcap_reg_ = ram_set_txcap_reg;
  ppVar1->meas_tone_pwr_db_ = ram_meas_tone_pwr_db;
  ppVar1->pbus_debugmode_ = ram_pbus_debugmode;
  ppVar1->pbus_force_test_ = ram_pbus_force_test;
  ppVar1->set_txclk_en_ = ram_set_txclk_en;
  ppVar1->set_rxclk_en_ = ram_set_rxclk_en;
  ppVar1->rfpll_set_freq_ = ram_rfpll_set_freq;
  ppVar1->get_rf_gain_qdb_ = ram_get_rf_gain_qdb;
  return;
}



// WARNING: Unknown calling convention

uint32 phy_byte_to_word(uint8 *data)

{
  return *(uint32 *)data;
}



// WARNING: Unknown calling convention

void rf_cal_data_recovery(uint8 *rf_cal_data)

{
  chip7_sleep_params.param_flag = *(uint32 *)(rf_cal_data + 0x40c);
  phy_rxrf_dc[0] = *(uint32 *)(rf_cal_data + 0x4d0);
  phy_rxbb_dc[0] = *(uint32 *)(rf_cal_data + 0x558);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rf_cal_data_backup(uint8 *rf_cal_data)

{
  uint8 uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint8 *puVar7;
  sleep_param_t *psVar8;
  uint32 *puVar9;
  uint8 *puVar10;
  int iVar11;
  uint local_30;
  
  local_30 = 0xc;
  iVar5 = 0x55;
  if (phy_freq_wifi_only) {
    iVar5 = 0xe;
  }
  iVar2 = 0;
  do {
    if (phy_freq_wifi_only == false) {
      iVar11 = (iVar2 + 1) * 0xc;
      uVar6 = iVar2 * 3 & 0xff;
    }
    else if (iVar2 < 0xd) {
      iVar11 = (local_30 + 1) * 0xc;
      uVar6 = local_30 * 3 & 0xff;
    }
    else {
      uVar6 = 0xfc;
      iVar11 = 0x3fc;
    }
    iVar2 = iVar2 + 1;
    uVar3 = uVar6 + 3;
    puVar10 = rf_cal_data + iVar11;
    do {
      uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      _DAT_3ff4e0c4 = uVar4 & 0xffffff00 | uVar6;
      memw();
      uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c0);
      *puVar10 = uVar1;
      memw();
      uVar6 = uVar6 + 1 & 0xff;
      puVar10 = puVar10 + 4;
    } while (uVar6 != (uVar3 & 0xff));
    local_30 = local_30 + 5 & 0xff;
  } while (iVar2 != iVar5);
  puVar10 = rf_cal_data + 0x40c;
  psVar8 = &chip7_sleep_params;
  do {
    *puVar10 = (uint8)psVar8->param_flag;
    memw();
    psVar8 = (sleep_param_t *)psVar8->target_power_chan_backoff;
    puVar10 = puVar10 + 4;
  } while (psVar8 != (sleep_param_t *)bt_wifi_chan_data);
  puVar10 = rf_cal_data + 0x4d0;
  puVar9 = phy_rxrf_dc;
  do {
    uVar6 = 0;
    iVar5 = 4;
    puVar7 = puVar10;
    do {
      uVar3 = uVar6 & 0x1f;
      uVar6 = uVar6 + 8;
      *puVar7 = (uint8)(*puVar9 >> uVar3);
      memw();
      puVar7 = puVar7 + 1;
      iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    puVar9 = puVar9 + 1;
    puVar10 = puVar10 + 4;
  } while (puVar9 != (uint32 *)&para_num);
  puVar10 = rf_cal_data + 0x558;
  puVar9 = phy_rxbb_dc;
  do {
    uVar6 = 0;
    iVar5 = 4;
    puVar7 = puVar10;
    do {
      uVar3 = uVar6 & 0x1f;
      uVar6 = uVar6 + 8;
      *puVar7 = (uint8)(*puVar9 >> uVar3);
      memw();
      puVar7 = puVar7 + 1;
      iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    puVar9 = (uint32 *)((int)puVar9 + 4);
    puVar10 = puVar10 + 4;
  } while ((code *)puVar9 != ets_isr_attach);
  return;
}



// WARNING: Unknown calling convention

uint32 phy_get_rf_cal_version(void)

{
  return 0x12e8;
}



// WARNING: Unknown calling convention

bool phy_rfcal_data_check(bool check_flag,uint8 *rf_cal_data,uint8 *init_param)

{
  uint32 check_sum;
  uint uVar1;
  
  *rf_cal_data = 0xe8;
  rf_cal_data[1] = '\x12';
  rf_cal_data[2] = '\0';
  rf_cal_data[3] = '\0';
  memw();
  uVar1 = *(int *)rf_cal_data + *(int *)init_param ^ 0xffffffff;
  if (check_flag) {
    return uVar1 != *(uint *)(rf_cal_data + 0x568);
  }
  rf_cal_data[0x568] = (uint8)uVar1;
  rf_cal_data[0x569] = (uint8)(uVar1 >> 8);
  rf_cal_data[0x56a] = (uint8)(uVar1 >> 0x10);
  rf_cal_data[0x56b] = (uint8)(uVar1 >> 0x18);
  memw();
  return check_flag;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2cmst_reg_init(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = uVar1 & 0xfff0ffff | 0x20000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = uVar1 & 0xff0fffff | 0x400000;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x1000000;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x40000000;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xdfffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  memw();
  _DAT_3ff4e0c4 = uVar1 & 0xffff83ff | 0x2c00;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void fe_reg_init(void)

{
  uint uVar1;
  
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 | 0x1000000;
  memw();
  _DAT_3ff45114 = esp_dport_access_reg_read(&DAT_3ff45114);
  _DAT_3ff45114 = _DAT_3ff45114 | 0x200;
  memw();
  _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
  _DAT_3ff450dc = _DAT_3ff450dc | 0xc0000000;
  memw();
  _DAT_3ff450d8 = esp_dport_access_reg_read(&DAT_3ff450d8);
  _DAT_3ff450d8 = _DAT_3ff450d8 | 0x2000000;
  memw();
  _DAT_3ff460b8 = esp_dport_access_reg_read(&DAT_3ff460b8);
  _DAT_3ff460b8 = _DAT_3ff460b8 | 0x20000000;
  memw();
  _DAT_3ff4609c = esp_dport_access_reg_read(&DAT_3ff4609c);
  _DAT_3ff4609c = _DAT_3ff4609c | 0x4000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4604c);
  memw();
  _DAT_3ff4604c = uVar1 & 0xffff00ff | 0xc800;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void reg_init_begin(bool wakeup)

{
  (*g_phyFuns->i2c_writeReg_)('f','\x04','\f','\0');
  _DAT_3ff48030 = esp_dport_access_reg_read(&DAT_3ff48030);
  _DAT_3ff48030 = _DAT_3ff48030 | 0xf8000000;
  memw();
  _DAT_3ff66000 = esp_dport_access_reg_read(&DAT_3ff66000);
  _DAT_3ff66000 = _DAT_3ff66000 | 0x400;
  memw();
  if (!wakeup) {
    fe_reg_init();
    i2cmst_reg_init();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_wakeup_init(void)

{
  undefined4 uVar1;
  uint uVar2;
  CriticalType crit_level;
  
  uVar1 = phy_enter_critical();
  phy_init_flag = true;
  force_hw_set_freq_flag = true;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = uVar2 & 0xfffff0ff | 0xa00;
  memw();
  phy_dis_hw_set_freq();
  i2c_master_reset();
  reg_init_begin(true);
  phy_i2c_init();
  phy_reg_init();
  set_chan_reg();
  _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
  _DAT_3ff460a0 = _DAT_3ff460a0 & 0xfffff0ff;
  memw();
  (*g_phyFuns->i2c_readReg_)('c','\0','\0');
  enable_wifi_agc();
  phy_init_flag = false;
  force_hw_set_freq_flag = false;
  memw();
  phy_en_hw_set_freq();
  if (init_wifi_disable != false) {
    _DAT_3ff5c080 = esp_dport_access_reg_read(&DAT_3ff5c080);
    _DAT_3ff5c080 = _DAT_3ff5c080 | 0xc0;
    memw();
  }
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Unknown calling convention

char * get_phy_version_str(void)

{
  sprintf(phy_version_str,"%d,%s,%s,%s");
  return phy_version_str;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_version_print(void)

{
  phy_printf("phy_version: %d, %s, %s, %s\n",0x12e8,"02e0d70","Sep  2 2024","19:39:07");
  return;
}



// WARNING: Unknown calling convention

void get_iq_value(sint8 *iq_out,uint16 iq_in)

{
  sint8 sVar1;
  ushort uVar2;
  
  uVar2 = iq_in >> 6 & 0x1f;
  sVar1 = (sint8)uVar2;
  if (0xf < uVar2) {
    sVar1 = sVar1 + -0x20;
  }
  *iq_out = sVar1;
  memw();
  sVar1 = (sint8)(iq_in & 0x3f);
  if (0x1f < (iq_in & 0x3f)) {
    sVar1 = sVar1 + -0x40;
  }
  iq_out[1] = sVar1;
  memw();
  return;
}



// WARNING: Unknown calling convention

uint16 phy_rfcal_data_check_value(uint8 *rf_cal_data,sleep_param_t *cal_param,bool check_en)

{
  byte bVar1;
  sint16 *psVar2;
  uint16 uVar3;
  sint32 sVar4;
  uint16 *puVar5;
  sleep_param_t *psVar6;
  sint8 *psVar7;
  uint8 *puVar8;
  sleep_param_t *psVar9;
  uint16 *puVar10;
  sint8 *psVar11;
  char cVar12;
  char cVar13;
  ushort uVar14;
  sint16 *psVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  sint8 iq_out [2];
  sint8 iq_out_old [2];
  uint16 *puStack_30;
  
  if (check_en) {
    uVar3 = 0;
    puStack_30 = (uint16 *)cal_param->target_power_chan_backoff;
    psVar9 = &chip7_sleep_params;
    puVar5 = puStack_30;
    do {
      psVar6 = psVar9;
      psVar15 = (sint16 *)(puVar5 + -2);
      do {
        psVar2 = psVar15 + 1;
        sVar4 = (*g_phyFuns->abs_temp_)((uint)(ushort)psVar15[6] - (uint)psVar6->txdc_table[0]);
        if (4 < sVar4) {
          uVar3 = uVar3 + 1;
        }
        psVar6 = (sleep_param_t *)((int)&psVar6->param_flag + 2);
        psVar15 = psVar2;
      } while (puVar5 != (uint16 *)psVar2);
      psVar9 = (sleep_param_t *)(psVar9->target_power_chan_backoff + 2);
      puVar5 = puVar5 + 4;
      psVar6 = &chip7_sleep_params;
    } while (psVar9 != (sleep_param_t *)(chip7_sleep_params.txdc_table + 0xe));
    do {
      psVar9 = psVar6;
      psVar15 = (sint16 *)(puStack_30 + -2);
      do {
        psVar2 = psVar15 + 1;
        sVar4 = (*g_phyFuns->abs_temp_)
                          ((uint)(ushort)psVar15[0x4c] - (uint)psVar9->bt_txdc_table[0]);
        if (4 < sVar4) {
          uVar3 = uVar3 + 1;
        }
        psVar9 = (sleep_param_t *)((int)&psVar9->param_flag + 2);
        psVar15 = psVar2;
      } while (puStack_30 != (uint16 *)psVar2);
      puStack_30 = puStack_30 + 4;
      psVar15 = psVar6->target_power_chan_backoff;
      psVar6 = (sleep_param_t *)(psVar15 + 2);
    } while ((sleep_param_t *)(psVar15 + 2) != (sleep_param_t *)(chip7_sleep_params.txdc_table + 6))
    ;
    puVar5 = cal_param->wifi_txiq;
    puVar10 = cal_param->wifi_rxiq;
    psVar9 = &chip7_sleep_params;
    do {
      uVar17 = *puVar5 >> 6 & 0x1f;
      uVar16 = (uint)(char)uVar17;
      if (0xf < uVar16) {
        uVar16 = uVar17 - 0x20;
      }
      uVar14 = *puVar5 & 0x3f;
      cVar12 = (char)uVar14;
      if (0x1f < uVar14) {
        cVar12 = cVar12 + -0x40;
      }
      memw();
      uVar18 = psVar9->wifi_txiq[0] >> 6 & 0x1f;
      uVar17 = (uint)(char)uVar18;
      if (0xf < uVar17) {
        uVar17 = uVar18 - 0x20;
      }
      uVar14 = psVar9->wifi_txiq[0] & 0x3f;
      cVar13 = (char)uVar14;
      if (0x1f < uVar14) {
        cVar13 = cVar13 + -0x40;
      }
      memw();
      sVar4 = (*g_phyFuns->abs_temp_)(uVar16 - uVar17);
      if (4 < sVar4) {
        uVar3 = uVar3 + 1;
      }
      sVar4 = (*g_phyFuns->abs_temp_)((int)cVar12 - (int)cVar13);
      if (4 < sVar4) {
        uVar3 = uVar3 + 1;
      }
      puVar5 = puVar5 + 1;
      psVar9 = (sleep_param_t *)((int)&psVar9->param_flag + 2);
      psVar6 = &chip7_sleep_params;
    } while (puVar5 != puVar10);
    do {
      uVar17 = *puVar10 >> 6 & 0x1f;
      uVar16 = (uint)(char)uVar17;
      if (0xf < uVar16) {
        uVar16 = uVar17 - 0x20;
      }
      uVar14 = *puVar10 & 0x3f;
      cVar12 = (char)uVar14;
      if (0x1f < uVar14) {
        cVar12 = cVar12 + -0x40;
      }
      memw();
      uVar18 = psVar6->wifi_rxiq[0] >> 6 & 0x1f;
      uVar17 = (uint)(char)uVar18;
      if (0xf < uVar17) {
        uVar17 = uVar18 - 0x20;
      }
      uVar14 = psVar6->wifi_rxiq[0] & 0x3f;
      cVar13 = (char)uVar14;
      if (0x1f < uVar14) {
        cVar13 = cVar13 + -0x40;
      }
      memw();
      sVar4 = (*g_phyFuns->abs_temp_)(uVar16 - uVar17);
      if (4 < sVar4) {
        uVar3 = uVar3 + 1;
      }
      sVar4 = (*g_phyFuns->abs_temp_)((int)cVar12 - (int)cVar13);
      if (4 < sVar4) {
        uVar3 = uVar3 + 1;
      }
      psVar6 = (sleep_param_t *)((int)&psVar6->param_flag + 2);
      puVar10 = puVar10 + 1;
    } while (psVar6 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
    puVar5 = cal_param->bt_txiq;
    psVar9 = &chip7_sleep_params;
    do {
      uVar17 = *puVar5 >> 6 & 0x1f;
      uVar16 = (uint)(char)uVar17;
      if (0xf < uVar16) {
        uVar16 = uVar17 - 0x20;
      }
      uVar14 = *puVar5 & 0x3f;
      cVar12 = (char)uVar14;
      if (0x1f < uVar14) {
        cVar12 = cVar12 + -0x40;
      }
      memw();
      uVar18 = psVar9->bt_txiq[0] >> 6 & 0x1f;
      uVar17 = (uint)(char)uVar18;
      if (0xf < uVar17) {
        uVar17 = uVar18 - 0x20;
      }
      uVar14 = psVar9->bt_txiq[0] & 0x3f;
      cVar13 = (char)uVar14;
      if (0x1f < uVar14) {
        cVar13 = cVar13 + -0x40;
      }
      memw();
      sVar4 = (*g_phyFuns->abs_temp_)(uVar16 - uVar17);
      if (4 < sVar4) {
        uVar3 = uVar3 + 1;
      }
      sVar4 = (*g_phyFuns->abs_temp_)((int)cVar12 - (int)cVar13);
      if (4 < sVar4) {
        uVar3 = uVar3 + 1;
      }
      psVar9 = (sleep_param_t *)((int)&psVar9->param_flag + 2);
      puVar5 = puVar5 + 1;
    } while (psVar9 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 1));
    psVar7 = cal_param->tx_pwctrl_atten;
    psVar11 = chip7_sleep_params.tx_pwctrl_atten;
    do {
      cVar12 = *psVar7;
      psVar7 = psVar7 + 1;
      cVar13 = *psVar11;
      psVar11 = psVar11 + 1;
      sVar4 = (*g_phyFuns->abs_temp_)((int)cVar12 - (int)cVar13);
      if (4 < sVar4) {
        uVar3 = uVar3 + 1;
      }
    } while ((uint8 *)psVar11 != chip7_sleep_params.bt_pa_gain);
    sVar4 = (*g_phyFuns->abs_temp_)
                      ((uint)cal_param->bt_txpwr_atten - (uint)chip7_sleep_params.bt_txpwr_atten);
    if (4 < sVar4) {
      uVar3 = uVar3 + 1;
    }
    puVar8 = cal_param->para_txcap;
    psVar9 = &chip7_sleep_params;
    do {
      psVar6 = (sleep_param_t *)((int)&psVar9->param_flag + 1);
      bVar1 = *puVar8;
      puVar8 = puVar8 + 1;
      sVar4 = (*g_phyFuns->abs_temp_)((uint)bVar1 - (uint)psVar9->para_txcap[0]);
      if (4 < sVar4) {
        uVar3 = uVar3 + 1;
      }
      psVar9 = psVar6;
    } while (psVar6 != (sleep_param_t *)((int)chip7_sleep_params.target_power_chan_backoff + 5));
    return uVar3;
  }
  memcpy(cal_param,rf_cal_data + 0x40c,0xc4);
  return (ushort)check_en;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void tx_cont_en(void)

{
  if (chip7_sleep_params.ht40_mode_cfg == '\0') {
    (*g_phyFuns->i2c_writeReg_Mask_)
              ('g','\x01','\x03','\x06','\0',chip7_sleep_params.filter_dcap_wifi[0] + '\x16');
    (*g_phyFuns->i2c_writeReg_Mask_)
              ('g','\x01','\x04','\x06','\0',chip7_sleep_params.filter_dcap_wifi[0] + '\x18');
    return;
  }
  (*g_phyFuns->i2c_writeReg_Mask_)
            ('g','\x01','\x03','\x06','\0',chip7_sleep_params.filter_dcap_wifi[2] + '\x12');
  (*g_phyFuns->i2c_writeReg_Mask_)
            ('g','\x01','\x04','\x06','\0',chip7_sleep_params.filter_dcap_wifi[2] + '\x11');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void tx_cont_dis(void)

{
  int iVar1;
  
  iVar1 = 2;
  if (chip7_sleep_params.ht40_mode_cfg == '\0') {
    iVar1 = 0;
  }
  (*g_phyFuns->i2c_writeReg_Mask_)
            ('g','\x01','\x03','\x06','\0',chip7_sleep_params.filter_dcap_wifi[iVar1] + 0xfe);
  (*g_phyFuns->i2c_writeReg_Mask_)
            ('g','\x01','\x04','\x06','\0',chip7_sleep_params.filter_dcap_wifi[iVar1]);
  return;
}



// WARNING: Unknown calling convention

void tx_cont_cfg(uint8 set_en)

{
  if (set_en == '\x01') {
    tx_cont_en();
    return;
  }
  tx_cont_dis();
  return;
}



// WARNING: Unknown calling convention

S16 phy_get_tx_pwr(void)

{
  U16 e [8];
  
  (*g_phyFuns->read_sar_dout_)(e);
  phy_printf("%d, %d, ");
  return (S16)(((int)(short)((e[2] + e[3]) - (e[6] + e[7])) << 10) /
              (int)(short)((e[4] + e[5]) - (e[6] + e[7])));
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_init_pwr_print(void)

{
  char cVar1;
  sleep_param_t *psVar2;
  sleep_param_t *psVar3;
  sint8 *psVar4;
  
  phy_printf("cal_rf_ana_gain, rf_gain=0x%x, ana_gain=0x%x\n",tx_rf_ana_gain[0],tx_rf_ana_gain[1]);
  phy_printf("TX_POWER_BACKOFF, ");
  psVar2 = &chip7_sleep_params;
  do {
    psVar3 = (sleep_param_t *)((int)&psVar2->param_flag + 2);
    phy_printf(&DAT_0005899c,(int)psVar2->target_power_chan_backoff[0]);
    psVar2 = psVar3;
  } while (psVar3 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  phy_printf(&DAT_000589a4);
  phy_printf("TX_PWRCTRL_ATTEN, ");
  psVar4 = chip7_sleep_params.tx_pwctrl_atten;
  do {
    cVar1 = *psVar4;
    psVar4 = psVar4 + 1;
    phy_printf(&DAT_0005899c,(int)cVar1);
  } while ((uint8 *)psVar4 != chip7_sleep_params.bt_pa_gain);
  phy_printf(&DAT_000589a4);
  phy_printf("BT_PA_GAIN, ");
  psVar2 = &chip7_sleep_params;
  do {
    psVar3 = (sleep_param_t *)((int)&psVar2->param_flag + 1);
    phy_printf("0x%x, ",psVar2->bt_pa_gain[0]);
    psVar2 = psVar3;
  } while (psVar3 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  phy_printf(&DAT_000589a4);
  phy_printf("BT_DIG_ATTEN, ");
  psVar2 = &chip7_sleep_params;
  do {
    psVar3 = (sleep_param_t *)((int)&psVar2->param_flag + 1);
    phy_printf(&DAT_0005899c,(int)psVar2->bt_dig_atten[0]);
    psVar2 = psVar3;
  } while (psVar3 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  phy_printf(&DAT_000589a4);
  phy_printf("BT_TX_BB, 0x%x\n",chip7_sleep_params.bt_bb_gain);
  phy_printf("bt_txpwr_atten, %d\n",chip7_sleep_params.bt_txpwr_atten);
  return;
}



// WARNING: Unknown calling convention

sint16 phy_get_rx_freq(u8 rate,u32 bb_info)

{
  ushort uVar1;
  uint uVar2;
  
  if (rate < 8) {
    return (short)bb_info / 0x30;
  }
  uVar1 = (ushort)(bb_info >> 10) & 0x3ff;
  uVar2 = (uint)(short)uVar1;
  if (0x1ff < uVar2) {
    uVar2 = (uint)(short)(uVar1 - 0x400);
  }
  return (sint16)((int)(uVar2 << 4) / 0xd);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void reset_rf_dig(void)

{
  disable_wifi_agc();
  _DAT_3ff00024 = esp_dport_access_reg_read(&DAT_3ff00024);
  _DAT_3ff00024 = _DAT_3ff00024 & 0xfffffffd;
  memw();
  _DAT_3ff000d0 = esp_dport_access_reg_read(&DAT_3ff000d0);
  _DAT_3ff000d0 = _DAT_3ff000d0 | 3;
  memw();
  ets_delay_us(1);
  _DAT_3ff000d0 = esp_dport_access_reg_read(&DAT_3ff000d0);
  _DAT_3ff000d0 = _DAT_3ff000d0 & 0xfffffffc;
  memw();
  _DAT_3ff48030 = esp_dport_access_reg_read(&DAT_3ff48030);
  _DAT_3ff48030 = _DAT_3ff48030 & 0x27ffffff;
  memw();
  ets_delay_us(1);
  force_txrxoff(true);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

int register_chipv7_phy(u8 *init_param,uint8 *rf_cal_data,uint8 rf_cal_level)

{
  bool bVar1;
  uint32 uVar2;
  bool bVar3;
  uint16 uVar4;
  u32 t0;
  uint uVar5;
  bool bVar6;
  sleep_param_t cal_param;
  
  memw();
  if ((init_param == (u8 *)0x0) || (re_entry == '\x01')) {
    phy_wakeup_init();
    return 0;
  }
  phy_init_flag = true;
  force_hw_set_freq_flag = true;
  memw();
  if (re_entry == '\0') {
    phy_get_romfunc_addr();
    reset_rf_dig();
  }
  phy_dis_hw_set_freq();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
  memw();
  i2c_master_reset();
  if (re_entry == '\0') {
    bVar3 = phy_rfcal_data_check(true,rf_cal_data,init_param);
    uVar5 = (uint)bVar3;
    bVar1 = rf_cal_level < 2;
    bVar6 = bVar1 && uVar5 != 0;
    bVar3 = !bVar1 || uVar5 == 0;
    if (bVar3) {
      bVar6 = rf_cal_level != '\x01' || bVar6;
    }
    else {
      rf_cal_level = 2;
    }
    bVar3 = bVar3 && bVar1;
    if ((uVar5 == 0) && (bVar6)) {
      phy_rfcal_data_check_value(rf_cal_data,&cal_param,false);
      chip7_sleep_params.param_flag = 0;
    }
    register_chipv7_phy_init_param((s8 *)init_param);
    if (chip7_phy_init_ctrl.pwrdet_new_en == '\x01') {
      pwrdet_offset = 0x138;
      memw();
    }
    else {
      pwrdet_offset = 0x120;
      memw();
    }
    bVar1 = bVar3 && re_entry == '\0';
    phy_in_most_power = chip7_phy_init_ctrl.target_power_init[0];
    memw();
    if (bVar1) {
      rf_cal_data_recovery(rf_cal_data);
      bVar3 = bVar1;
    }
    uVar2 = chip7_sleep_params.param_flag;
    if (re_entry == '\0') {
      if (rf_cal_level == 0) {
        uVar2 = 0x200008;
      }
      else {
        uVar2 = 8;
        if (rf_cal_level < 2) {
          if ((chip7_sleep_params.param_flag & 0x10) == 0) {
            uVar2 = chip7_sleep_params.param_flag & 0xfffeddd7 | 8;
          }
          else {
            chip7_sleep_params.param_flag = chip7_sleep_params.param_flag & 0xfffeddd7;
            write_freq_mem_all(rf_cal_data + 0xc);
            uVar2 = chip7_sleep_params.param_flag;
          }
        }
      }
    }
    chip7_sleep_params.param_flag = uVar2;
    rf_init();
    bb_init();
    if ((re_entry != '\0') || (!bVar6)) goto LAB_0004aee8;
    if (uVar5 == 0) goto LAB_0004aeba;
  }
  else {
    bVar3 = rf_cal_level < 2;
    rf_init();
    bb_init();
    if ((rf_cal_level == '\x01') || (re_entry != '\0')) {
      uVar5 = 0;
      goto LAB_0004aee8;
    }
LAB_0004aeba:
    uVar4 = phy_rfcal_data_check_value(rf_cal_data,&cal_param,true);
    uVar5 = (uint)(uVar4 != 0);
  }
  rf_cal_data_backup(rf_cal_data);
  phy_rfcal_data_check(false,rf_cal_data,init_param);
LAB_0004aee8:
  if (re_entry == '\x01') {
    (*g_phyFuns->i2c_writeReg_)('e','\x04','\0','c');
    chip_v7_set_chan_nomac(chip7_sleep_params.phy_channel_num,'\n');
    force_txrxoff(false);
  }
  else {
    if (bVar3) {
      chip_v7_set_chan_nomac(chip7_sleep_params.phy_channel_num,'\n');
    }
    if (chip7_phy_init_ctrl.force_freq_offset_enbale != '\0') {
      chip_v7_set_chan_offset(0);
    }
  }
  (*g_phyFuns->i2c_readReg_)('c','\0','\0');
  if (re_entry == '\0') {
    btpwr_tsen_old = tsens_code_read();
    memw();
    memw();
    btpwr_tsen_init = btpwr_tsen_old;
  }
  phy_init_flag = false;
  force_hw_set_freq_flag = false;
  re_entry = '\x01';
  memw();
  phy_en_hw_set_freq();
  enable_wifi_agc();
  if (init_wifi_disable != false) {
    _DAT_3ff5c080 = esp_dport_access_reg_read(&DAT_3ff5c080);
    _DAT_3ff5c080 = _DAT_3ff5c080 | 0xc0;
    memw();
  }
  return uVar5;
}



// WARNING: Unknown calling convention

void phy_set_most_tpw(s8 most_target_power)

{
  memw();
  phy_in_most_power = most_target_power;
  phy_set_most_tpw_index = set_most_pwr_reg();
  memw();
  set_chan_dig_gain(chip7_sleep_params.phy_channel_num);
  phy_set_most_tpw_flag = true;
  memw();
  return;
}



// WARNING: Unknown calling convention

s8 phy_get_most_tpw(void)

{
  if (!phy_set_most_tpw_flag) {
    return chip7_phy_init_ctrl.target_power_init[0];
  }
  return set_most_tpw;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_rx_sense_set(uint8 sense_thr)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c010);
  uVar2 = (uint)sense_thr << 0x17;
  _DAT_3ff5c010 = uVar1 & 0x7fffff | uVar2;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c014);
  _DAT_3ff5c014 = uVar1 & 0x7fffff | uVar2;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c044);
  _DAT_3ff5c044 = uVar1 & 0xffffff00 | (uint)sense_thr;
  memw();
  if (sense_thr == '\0') {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c108);
    memw();
    _DAT_3ff5c108 = uVar1 | 0x200;
    return;
  }
  uVar1 = esp_dport_access_reg_read();
  memw();
  _DAT_3ff5c108 = uVar1 & 0xfffffdff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ant_dft_cfg(bool default_ant)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c11c);
  memw();
  _DAT_3ff5c11c = (default_ant & 1) << 0xb | uVar1 & 0xfffff7ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ant_wifitx_cfg(uint8 ant0,uint8 ant1)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45104);
  _DAT_3ff45104 = (ant0 & 0xf) << 8 | uVar1 & 0xfffff0ff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45104);
  memw();
  _DAT_3ff45104 = (ant1 & 0xf) << 0x10 | uVar1 & 0xfff0ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ant_wifirx_cfg(bool auto_en,uint8 ant0,uint8 ant1)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c11c);
  _DAT_3ff5c11c = (auto_en & 1) << 1 | uVar1 & 0xfffffffd;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45104);
  _DAT_3ff45104 = uVar1 & 0xf0ffffff | (ant0 & 0xf) << 0x18;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45108);
  _DAT_3ff45108 = uVar1 & 0xfffffff0 | ant0 & 0xf;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45108);
  _DAT_3ff45108 = uVar1 & 0xfffff0ff | (ant1 & 0xf) << 8;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45108);
  memw();
  _DAT_3ff45108 = uVar1 & 0xfff0ffff | (ant1 & 0xf) << 0x10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ant_bttx_cfg(uint8 ant0)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45108);
  _DAT_3ff45108 = uVar1 & 0xf0ffffff | (ant0 & 0xf) << 0x18;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4510c);
  memw();
  _DAT_3ff4510c = uVar1 & 0xfffffff0 | ant0 & 0xf;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ant_btrx_cfg(bool auto_en,uint8 ant0,uint8 ant1)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c11c);
  _DAT_3ff5c11c = (auto_en & 1) << 3 | uVar1 & 0xfffffff7;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4510c);
  _DAT_3ff4510c = uVar1 & 0xfffff0ff | (ant0 & 0xf) << 8;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4510c);
  _DAT_3ff4510c = uVar1 & 0xfff0ffff | (ant0 & 0xf) << 0x10;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4510c);
  _DAT_3ff4510c = uVar1 & 0xf0ffffff | (ant1 & 0xf) << 0x18;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45110);
  memw();
  _DAT_3ff45110 = uVar1 & 0xfffffff0 | ant1 & 0xf;
  return;
}



// WARNING: Unknown calling convention

void ant_tx_cfg(uint8 ant0)

{
  ant_wifitx_cfg(ant0,ant0);
  ant_bttx_cfg(ant0);
  return;
}



// WARNING: Unknown calling convention

void ant_rx_cfg(bool auto_en,uint8 ant0,uint8 ant1)

{
  ant_wifirx_cfg(auto_en,ant0,ant1);
  ant_btrx_cfg(auto_en,ant0,ant1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void esp_tx_state_out(uint8 wifi_gpio_num,uint8 bt_gpio_num)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  
  puVar3 = (uint *)((wifi_gpio_num + 0xffd114c) * 4);
  uVar1 = esp_dport_access_reg_read(puVar3);
  memw();
  *puVar3 = uVar1 & 0xfffffe00 | 0xde;
  if ((uint)wifi_gpio_num == (uint)bt_gpio_num) {
    uVar1 = 0x40000000;
    uVar4 = 0x40;
  }
  else {
    puVar3 = (uint *)((bt_gpio_num + 0xffd114c) * 4);
    uVar1 = esp_dport_access_reg_read(puVar3);
    memw();
    *puVar3 = uVar1 & 0xfffffe00 | 0xdf;
    uVar4 = 0x80;
    uVar1 = 0x80000000;
  }
  uVar2 = esp_dport_access_reg_read(&DAT_3ff45104);
  _DAT_3ff45104 = uVar2 & 0x3f3f3f3f | 0x404000;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff45108);
  _DAT_3ff45108 = uVar2 & 0x3f3f3f3f | uVar1;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4510c);
  _DAT_3ff4510c = uVar1 & 0x3f3f3f3f | uVar4;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff45110);
  memw();
  _DAT_3ff45110 = uVar1 & 0xffffff3f;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_chan_dump_cfg(bool shift_force_en,uint8 shift_force,bool lltf_dump_en,bool htltf_dump_en,
                      bool stbcltf2_dump_en)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5cd0c);
  _DAT_3ff5cd0c = (shift_force_en & 1) << 3 | uVar1 & 0xfffffff7;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5cd0c);
  _DAT_3ff5cd0c = (shift_force & 0xf) << 4 | uVar1 & 0xffffff0f;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5cd0c);
  _DAT_3ff5cd0c = (lltf_dump_en & 1) << 1 | uVar1 & 0xfffffffd;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5cd0c);
  _DAT_3ff5cd0c = uVar1 & 0xfffffffe | htltf_dump_en & 1;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5cd0c);
  memw();
  _DAT_3ff5cd0c = (stbcltf2_dump_en & 1) << 2 | uVar1 & 0xfffffffb;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void chan14_mic_cfg(u8 set_en)

{
  uint uVar1;
  int iVar2;
  char cVar3;
  
  if (set_en != '\x01') {
    _DAT_3ff5c400 = esp_dport_access_reg_read(&DAT_3ff5c400);
    cVar3 = '\x02';
    iVar2 = 2;
    if (chip7_sleep_params.ht40_mode_cfg == '\0') {
      iVar2 = 0;
    }
    else {
      cVar3 = '\x01';
    }
    _DAT_3ff5c400 = _DAT_3ff5c400 | 0x6000;
    memw();
    (*g_phyFuns->i2c_writeReg_Mask_)
              ('g','\x01','\x03','\x06','\0',chip7_sleep_params.filter_dcap_wifi[iVar2] - cVar3);
    (*g_phyFuns->i2c_writeReg_Mask_)
              ('g','\x01','\x04','\x06','\0',chip7_sleep_params.filter_dcap_wifi[iVar2]);
    phy_set_most_tpw(phy_in_most_power_bk);
    return;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c400);
  _DAT_3ff5c400 = uVar1 & 0xffff9fff | 0x2000;
  memw();
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x03','\x06','\0','L');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x04','\x06','\0','N');
  phy_set_most_tpw(chan14_mic_most_power);
  return;
}



// WARNING: Unknown calling convention

void chan14_mic_enable(bool en,s8 most_pwr)

{
  chan14_mic_en = en;
  memw();
  if (!en) {
    chan14_mic_cfg(en);
    return;
  }
  if (chan14_mic_flag == '\0') {
    chan14_mic_flag = '\x01';
    memw();
    phy_in_most_power_bk = phy_in_most_power;
    memw();
  }
  chan14_mic_most_power = (most_pwr < '0') * most_pwr + (most_pwr >= '0') * '0';
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_get_adc_rand(bool start_flag)

{
  U16 dco [4];
  sint16 rx_dc_comp [4];
  
  rx_dc_comp[0] = 0x100;
  rx_dc_comp[3] = 0x100;
  rx_dc_comp[1] = 0x100;
  rx_dc_comp[2] = 0x100;
  memw();
  adc_ana_conf_org = esp_dport_access_reg_read(&DAT_3ff48030);
  if (start_flag) {
    (*g_phyFuns->set_rxclk_en_)(true);
    _DAT_3ff48030 = esp_dport_access_reg_read(&DAT_3ff48030);
    _DAT_3ff48030 = _DAT_3ff48030 | 0xf8000000;
    memw();
    _DAT_3ff460a0 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = _DAT_3ff460a0 | 0x1000000;
    memw();
    _DAT_3ff66000 = esp_dport_access_reg_read(&DAT_3ff66000);
    _DAT_3ff66000 = _DAT_3ff66000 | 0x400;
    memw();
    (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x01','\a','\a','\0');
    (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x02','\a','\a','\0');
    (*g_phyFuns->pbus_debugmode_)();
    dco[0] = 0x100;
    dco[1] = 0x100;
    dco[2] = 0x100;
    dco[3] = 0x100;
    memw();
    (*g_phyFuns->pbus_set_dco_)(dco);
    (*g_phyFuns->pbus_xpd_rx_on_)(0);
    (*g_phyFuns->pbus_force_test_)('\0','\x01',0);
    (*g_phyFuns->pbus_rx_dco_cal_)(4000,rx_dc_comp,10,false,false);
    return;
  }
  (*g_phyFuns->pbus_xpd_rx_off_)();
  (*g_phyFuns->pbus_workmode_)();
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x01','\a','\a','\x01');
  (*g_phyFuns->i2c_writeReg_Mask_)('g','\x01','\x02','\a','\a','\x01');
  memw();
  _DAT_3ff48030 = adc_ana_conf_org;
  (*g_phyFuns->set_rxclk_en_)(start_flag);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_enable_low_rate(void)

{
  lr_enable = true;
  memw();
  _DAT_3ff5c860 = esp_dport_access_reg_read(&DAT_3ff5c860);
  _DAT_3ff5c860 = _DAT_3ff5c860 | 0x400;
  memw();
  _DAT_3ff5c860 = esp_dport_access_reg_read(&DAT_3ff5c860);
  _DAT_3ff5c860 = _DAT_3ff5c860 | 0x800;
  memw();
  _DAT_3ff5c87c = esp_dport_access_reg_read(&DAT_3ff5c87c);
  _DAT_3ff5c87c = _DAT_3ff5c87c | 0x800;
  memw();
  write_txrate_power_offset(true);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_disable_low_rate(void)

{
  lr_enable = false;
  memw();
  _DAT_3ff5c860 = esp_dport_access_reg_read(&DAT_3ff5c860);
  _DAT_3ff5c860 = _DAT_3ff5c860 & 0xfffffbff;
  memw();
  _DAT_3ff5c860 = esp_dport_access_reg_read(&DAT_3ff5c860);
  _DAT_3ff5c860 = _DAT_3ff5c860 & 0xfffff7ff;
  memw();
  _DAT_3ff5c87c = esp_dport_access_reg_read(&DAT_3ff5c87c);
  _DAT_3ff5c87c = _DAT_3ff5c87c & 0xfffff7ff;
  memw();
  write_txrate_power_offset(true);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_close_pa(bool force_close)

{
  uint uVar1;
  
  if (force_close) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
    _DAT_3ff460a0 = uVar1 & 0xfffff3ff | 0x800;
    memw();
    _DAT_3ff4609c = esp_dport_access_reg_read(&DAT_3ff4609c);
    _DAT_3ff4609c = _DAT_3ff4609c & 0xfffffffb;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4609c);
    memw();
    _DAT_3ff4609c = uVar1 & 0xffffffef;
    return;
  }
  _DAT_3ff4609c = esp_dport_access_reg_read(&DAT_3ff4609c);
  _DAT_3ff4609c = _DAT_3ff4609c | 4;
  memw();
  _DAT_3ff4609c = esp_dport_access_reg_read(&DAT_3ff4609c);
  _DAT_3ff4609c = _DAT_3ff4609c | 0x10;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff460a0);
  memw();
  _DAT_3ff460a0 = uVar1 & 0xfffff3ff;
  return;
}



// WARNING: Unknown calling convention

void btpwr_backoff(s8 backoff)

{
  chip7_sleep_params.bt_dig_atten[0] =
       (backoff - bt_txpwr_backoff) + chip7_sleep_params.bt_dig_atten[0];
  if (chip7_sleep_params.bt_dig_atten[0] < '\0') {
    chip7_sleep_params.bt_dig_atten[0] = '\0';
    memw();
  }
  else if (chip7_sleep_params.bt_dig_atten[0] < 'A') {
    memw();
  }
  else {
    chip7_sleep_params.bt_dig_atten[0] = '@';
    memw();
  }
  wr_bt_tx_atten(chip7_sleep_params.bt_dig_atten);
  bt_txpwr_backoff = backoff;
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint8 phy_dig_reg_backup(bool backup_en,uint32 *mem_addr)

{
  uint32 uVar1;
  
  if (backup_en) {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5cd0c);
    *mem_addr = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5cc0c);
    mem_addr[1] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5cd08);
    mem_addr[2] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5cd04);
    mem_addr[3] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c074);
    mem_addr[4] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c11c);
    mem_addr[5] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff45104);
    mem_addr[6] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff45108);
    mem_addr[7] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4510c);
    mem_addr[8] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff45110);
    mem_addr[9] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c860);
    mem_addr[10] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c87c);
    mem_addr[0xb] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
    mem_addr[0xc] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c018);
    mem_addr[0xd] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c01c);
    mem_addr[0xe] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c010);
    mem_addr[0xf] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c014);
    mem_addr[0x10] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c044);
    mem_addr[0x11] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c108);
    mem_addr[0x12] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c0cc);
    mem_addr[0x13] = uVar1;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c124);
    mem_addr[0x14] = uVar1;
  }
  else {
    _DAT_3ff5cd0c = *mem_addr;
    _DAT_3ff5cc0c = mem_addr[1];
    memw();
    _DAT_3ff5cd08 = mem_addr[2];
    memw();
    _DAT_3ff5cd04 = mem_addr[3];
    memw();
    _DAT_3ff5c074 = mem_addr[4];
    memw();
    _DAT_3ff5c11c = mem_addr[5];
    memw();
    _DAT_3ff45104 = mem_addr[6];
    memw();
    _DAT_3ff45108 = mem_addr[7];
    memw();
    _DAT_3ff4510c = mem_addr[8];
    memw();
    _DAT_3ff45110 = mem_addr[9];
    memw();
    _DAT_3ff5c860 = mem_addr[10];
    memw();
    memw();
    _DAT_3ff5c87c = mem_addr[0xb];
    _DAT_3ff5c02c = mem_addr[0xc];
    memw();
    _DAT_3ff5c018 = mem_addr[0xd];
    memw();
    _DAT_3ff5c01c = mem_addr[0xe];
    memw();
    _DAT_3ff5c010 = mem_addr[0xf];
    memw();
    _DAT_3ff5c014 = mem_addr[0x10];
    memw();
    _DAT_3ff5c044 = mem_addr[0x11];
    memw();
    _DAT_3ff5c108 = mem_addr[0x12];
    memw();
    _DAT_3ff5c0cc = mem_addr[0x13];
    memw();
    _DAT_3ff5c124 = mem_addr[0x14];
    memw();
    memw();
  }
  return '\x15';
}



// WARNING: Unknown calling convention

void get_iq_est_snr_1(uint64 *get_power,uint8 shift_bits,bool print_en)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  ulonglong uVar22;
  ulonglong uVar23;
  ulonglong uVar24;
  ulonglong uVar25;
  
  iVar1 = esp_dport_access_reg_read(0x3ff46080);
  iVar2 = esp_dport_access_reg_read(0x3ff4608c);
  uVar16 = iVar1 + iVar2;
  uVar22 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar1 = (int)uVar22;
  iVar2 = esp_dport_access_reg_read(0x3ff46084);
  iVar3 = esp_dport_access_reg_read(0x3ff46088);
  uVar16 = iVar2 - iVar3;
  uVar23 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar2 = (int)uVar23;
  iVar3 = esp_dport_access_reg_read(0x3ff460cc);
  iVar4 = esp_dport_access_reg_read(0x3ff460d8);
  uVar16 = iVar3 + iVar4;
  uVar24 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar3 = (int)uVar24;
  iVar4 = esp_dport_access_reg_read(0x3ff460d0);
  iVar5 = esp_dport_access_reg_read(0x3ff460d4);
  uVar16 = iVar4 - iVar5;
  uVar25 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar4 = (int)uVar25;
  uVar18 = iVar1 * iVar1 + iVar2 * iVar2;
  uVar16 = uVar18 + iVar3 * iVar3;
  uVar11 = uVar16 + iVar4 * iVar4;
  iVar6 = (uint)(uVar11 < uVar16) +
          (uint)(uVar16 < uVar18) +
          (uint)(uVar18 < (uint)(iVar1 * iVar1)) +
          (int)(uVar22 >> 0x20) * iVar1 * 2 +
          (int)((uVar22 & 0xffffffff) * (uVar22 & 0xffffffff) >> 0x20) +
          (int)(uVar23 >> 0x20) * iVar2 * 2 +
          (int)((uVar23 & 0xffffffff) * (uVar23 & 0xffffffff) >> 0x20) +
          (int)(uVar24 >> 0x20) * iVar3 * 2 +
          (int)((uVar24 & 0xffffffff) * (uVar24 & 0xffffffff) >> 0x20) +
          (int)(uVar25 >> 0x20) * iVar4 * 2 +
          (int)((uVar25 & 0xffffffff) * (uVar25 & 0xffffffff) >> 0x20);
  *(uint *)(get_power + 4) = uVar11;
  *(int *)((int)get_power + 0x24) = iVar6;
  iVar1 = esp_dport_access_reg_read(0x3ff46080);
  iVar2 = esp_dport_access_reg_read(0x3ff4608c);
  uVar16 = iVar1 - iVar2;
  uVar22 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar1 = (int)uVar22;
  iVar2 = esp_dport_access_reg_read(0x3ff46084);
  iVar3 = esp_dport_access_reg_read(0x3ff46088);
  uVar16 = iVar2 + iVar3;
  uVar23 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar2 = (int)uVar23;
  iVar3 = esp_dport_access_reg_read(0x3ff460cc);
  iVar4 = esp_dport_access_reg_read(0x3ff460d8);
  uVar16 = iVar3 - iVar4;
  uVar24 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar3 = (int)uVar24;
  iVar4 = esp_dport_access_reg_read(0x3ff460d0);
  iVar5 = esp_dport_access_reg_read(0x3ff460d4);
  uVar16 = iVar4 + iVar5;
  uVar25 = __divdi3(uVar16 * 0x4000,uVar16 >> 0x12 | ((int)uVar16 >> 0x1f) << 0xe,0x7fe03,0);
  iVar4 = (int)uVar25;
  uVar16 = iVar1 * iVar1 + iVar2 * iVar2;
  uVar18 = uVar16 + iVar3 * iVar3;
  uVar8 = uVar18 + iVar4 * iVar4;
  iVar1 = (uint)(uVar8 < uVar18) +
          (uint)(uVar18 < uVar16) +
          (uint)(uVar16 < (uint)(iVar1 * iVar1)) +
          (int)(uVar22 >> 0x20) * iVar1 * 2 +
          (int)((uVar22 & 0xffffffff) * (uVar22 & 0xffffffff) >> 0x20) +
          (int)(uVar23 >> 0x20) * iVar2 * 2 +
          (int)((uVar23 & 0xffffffff) * (uVar23 & 0xffffffff) >> 0x20) +
          (int)(uVar24 >> 0x20) * iVar3 * 2 +
          (int)((uVar24 & 0xffffffff) * (uVar24 & 0xffffffff) >> 0x20) +
          (int)(uVar25 >> 0x20) * iVar4 * 2 +
          (int)((uVar25 & 0xffffffff) * (uVar25 & 0xffffffff) >> 0x20);
  *(uint *)(get_power + 3) = uVar8;
  uVar8 = uVar11 + uVar8;
  *(int *)((int)get_power + 0x1c) = iVar1;
  uVar7 = (uint)(uVar8 < uVar11) + iVar6 + iVar1;
  iVar1 = esp_dport_access_reg_read(0x3ff460dc);
  iVar1 = iVar1 >> 4;
  iVar2 = esp_dport_access_reg_read(0x3ff460e0);
  iVar2 = iVar2 >> 4;
  uVar18 = iVar1 * iVar1 + iVar2 * iVar2;
  uVar9 = (uint)(uVar18 < (uint)(iVar1 * iVar1)) +
          (int)((ulonglong)((longlong)iVar1 * (longlong)iVar1) >> 0x20) +
          (int)((ulonglong)((longlong)iVar2 * (longlong)iVar2) >> 0x20);
  uVar16 = esp_dport_access_reg_read(0x3ff460e4);
  uVar12 = shift_bits + 7;
  uVar10 = uVar16 << 0x20 - (0x20 - (uVar12 & 0x1f));
  uVar11 = uVar10;
  uVar16 = (uVar16 >> 1) >> ((uVar12 & 0xff ^ 0xffffffff) & 0x1f) |
           ((int)uVar16 >> 0x1f) << 0x20 - (0x20 - (uVar12 & 0x1f));
  if ((uVar12 & 0x20) != 0) {
    uVar11 = 0;
    uVar16 = uVar10;
  }
  if (print_en) {
    uVar13 = (uVar12 & 0xff) + 0xb;
    uVar17 = uVar13 ^ 0xffffffff;
    iVar1 = 0 >> (uVar13 & 0x1f);
    uVar15 = uVar13 & 0x20;
    uVar21 = uVar7 >> (uVar13 & 0x1f);
    uVar19 = uVar16 >> (uVar13 & 0x1f);
    uVar14 = uVar9 >> (uVar13 & 0x1f);
    uVar12 = uVar21;
    uVar10 = uVar7 * 2 << 0x20 - (0x20 - (uVar17 & 0x1f)) | uVar8 >> (uVar13 & 0x1f);
    if (uVar15 != 0) {
      uVar12 = 0;
      uVar10 = uVar21;
    }
    uVar20 = uVar19;
    uVar21 = (uVar16 << 1) << 0x20 - (0x20 - (uVar17 & 0x1f)) | uVar11 >> (uVar13 & 0x1f);
    if (uVar15 != 0) {
      uVar20 = 0;
      uVar21 = uVar19;
    }
    uVar19 = uVar14;
    iVar2 = iVar1;
    if (uVar15 == 0) {
      iVar2 = 0;
      uVar19 = uVar9 * 2 << 0x20 - (0x20 - (uVar17 & 0x1f)) | uVar18 >> (uVar13 & 0x1f);
    }
    if (uVar15 != 0) {
      uVar14 = 0;
      iVar1 = 0;
    }
    phy_printf("total_power=%lld, sig_power=%lld, dc_power=%lld, noise_power=%lld\n",uVar19,uVar21,
               uVar20,uVar10,uVar12,uVar19,uVar14,iVar2,iVar1);
  }
  *(uint *)get_power = uVar11;
  *(uint *)((int)get_power + 4) = uVar16;
  *(uint *)(get_power + 1) = uVar8;
  *(uint *)((int)get_power + 0xc) = uVar7;
  *(uint *)(get_power + 2) = uVar18;
  *(uint *)((int)get_power + 0x14) = uVar9;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint64 freq_offset_get_pwr_1
                 (U8 loop_bits,S16 tone_step,U8 corr_cycle_bits,uint64 *tot_pwr_o,bool rxiq_sign,
                 bool print_en)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint64 get_power [7];
  uint uStack_4c;
  
  uVar1 = (uint)loop_bits;
  uVar3 = (uint)tone_step;
  (*g_phyFuns->set_txclk_en_)(true);
  uVar2 = esp_dport_access_reg_read(&DAT_3ff450a8);
  _DAT_3ff450a8 = uVar2 & 0xfffffffc | uVar3 & 3;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff460b8);
  iVar6 = 1 << 0x20 - (0x20 - (uVar1 & 0x1f));
  _DAT_3ff460b8 = (int)uVar3 >> 2 & 0xfdbffffU | 0x240000 | uVar2 & 0xf0000000;
  memw();
  if (iVar6 < 1) {
    uVar2 = 0;
    uVar3 = 0;
    uVar1 = 0;
    uVar11 = 0;
  }
  else {
    uVar4 = 0;
    uVar5 = 0;
    uStack_4c = 0;
    uVar2 = 0;
    uVar11 = 0;
    do {
      (*g_phyFuns->iq_est_enable_)(true,(uint16)(1 << 0x20 - (0x20 - (corr_cycle_bits & 0x1f))));
      get_iq_est_snr_1(get_power,corr_cycle_bits,print_en);
      uVar8 = uVar11 + (int)get_power[1];
      uVar7 = uVar2 + (int)get_power[0];
      uVar5 = (uint)(uVar8 < uVar11) + uVar5 + get_power[1]._4_4_;
      uVar4 = (uint)(uVar7 < uVar2) + uVar4 + get_power[0]._4_4_;
      (*g_phyFuns->iq_est_disable_)();
      if (print_en) {
        phy_printf("step=%d, %d\n",uVar3,uStack_4c);
      }
      uStack_4c = uStack_4c + 1 & 0xff;
      uVar2 = uVar7;
      uVar11 = uVar8;
    } while ((int)uStack_4c < iVar6);
    uVar9 = uVar4 >> (uVar1 & 0x1f);
    uVar10 = uVar5 >> (uVar1 & 0x1f);
    uVar2 = uVar4 * 2 << 0x20 - (0x20 - ((uVar1 ^ 0xffffffff) & 0x1f)) | uVar7 >> (uVar1 & 0x1f);
    uVar3 = uVar9;
    uVar1 = uVar5 * 2 << 0x20 - (0x20 - ((uVar1 ^ 0xffffffff) & 0x1f)) | uVar8 >> (uVar1 & 0x1f);
    uVar11 = uVar10;
    if ((loop_bits & 0x20) != 0) {
      uVar11 = 0;
      uVar3 = 0;
      uVar2 = uVar9;
      uVar1 = uVar10;
    }
  }
  *(uint *)tot_pwr_o = uVar2;
  *(uint *)((int)tot_pwr_o + 4) = uVar3;
  _DAT_3ff460b8 = esp_dport_access_reg_read(&DAT_3ff460b8);
  _DAT_3ff460b8 = _DAT_3ff460b8 & 0xfffbffff;
  memw();
  (*g_phyFuns->set_txclk_en_)(false);
  return CONCAT44(uVar11,uVar1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void get_spur4m_pwr(uint32 *out_pwr)

{
  uint uVar1;
  uint extraout_a2;
  int extraout_a2_00;
  int extraout_a3;
  int extraout_a3_00;
  uint64 tot_pwr;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = uVar1 & 0xffffff | 0x3c000000;
  memw();
  _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = _DAT_3ff5c02c | 0x800000;
  memw();
  freq_offset_get_pwr_1('\x05',-0x67,'\n',&tot_pwr,false,false);
  freq_offset_get_pwr_1('\x05',-0x66,'\n',&tot_pwr,false,false);
  tot_pwr._0_4_ = tot_pwr._4_4_ << 0xf | (uint)tot_pwr >> 0x11;
  tot_pwr._4_4_ = tot_pwr._4_4_ >> 0x11;
  out_pwr[1] = (uint)tot_pwr;
  *out_pwr = ((uint)(extraout_a2 + extraout_a2_00 < extraout_a2) + extraout_a3 + extraout_a3_00) *
             0x8000 | extraout_a2 + extraout_a2_00 >> 0x11;
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = uVar1 & 0xffffff | 0x32000000;
  memw();
  _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
  _DAT_3ff5c02c = _DAT_3ff5c02c | 0x800000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
  memw();
  _DAT_3ff5c02c = uVar1 & 0xff7fffff;
  return;
}



// WARNING: Unknown calling convention

uint8 rx_spur_cal(bool flag,bool print_en,uint32 *rx_power_min)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint32 in_a6;
  uint8 uVar4;
  uint32 rx_pwr [2];
  uint8 end;
  uint uStack_2c;
  uint32 uStack_28;
  
  uVar2 = 0xb;
  if (flag) {
    uVar2 = 8;
  }
  uVar1 = 5;
  uVar3 = 5;
  do {
    if (flag) {
      (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\x02','\0',(uint8)uVar1);
    }
    else {
      (*g_phyFuns->i2c_writeReg_Mask_)('h','\x03',flag,'\x05','\x02',(uint8)uVar1);
    }
    ets_delay_us(100);
    get_spur4m_pwr(rx_pwr);
    if (uVar1 == 5) {
      uStack_28 = rx_pwr[1];
      in_a6 = rx_pwr[0];
      uStack_2c = 5;
    }
    else if (rx_pwr[0] < in_a6) {
      uStack_28 = rx_pwr[1];
      in_a6 = rx_pwr[0];
      uStack_2c = uVar3;
    }
    if (print_en) {
      phy_printf("%d-%d,",uVar1,rx_pwr[0]);
    }
    uVar1 = uVar1 + 1;
    uVar3 = uVar1 & 0xff;
  } while (uVar3 < uVar2);
  *rx_power_min = in_a6;
  rx_power_min[1] = uStack_28;
  uVar4 = (uint8)uStack_2c;
  if (flag) {
    (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\x02','\0',uVar4);
  }
  else {
    (*g_phyFuns->i2c_writeReg_Mask_)('h','\x03',flag,'\x05','\x02',uVar4);
  }
  return uVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bt_opt_write_mem(uint8 chan_freq,uint8 xtal_dac,uint8 oc_bw)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = (uint)chan_freq * 3 + 2 & 0xff | uVar1 & 0xffffff00;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c0);
  _DAT_3ff4e148 = (uint)xtal_dac << 0x18 | (uint)oc_bw << 0x10 | uVar1 & 0xffff;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x200;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  memw();
  _DAT_3ff4e0c4 = uVar1 & 0xfffffdff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bt_rx_spur_opt(bool enable)

{
  uint8 uVar1;
  uint8 oc_bw;
  _func_void_uint8_uint8_uint8_uint8 *p_Var2;
  uint uVar3;
  uint32 rx_pwr [2];
  
  if (enable) {
    phy_dac_org = (*g_phyFuns->i2c_readReg_)('h','\x03','\0');
    memw();
    phy_dcur_org = (*g_phyFuns->i2c_readReg_)('f','\x04','\x05');
    memw();
    set_chan_freq_sw_start(',',0,chip7_phy_init_ctrl.crystal_select);
    rx_spur_cal(false,false,rx_pwr);
    uVar1 = (*g_phyFuns->i2c_readReg_)('h','\x03','\0');
    bt_opt_write_mem('*',uVar1,phy_dcur_org);
    (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\a','\x06','\0');
    set_chan_freq_sw_start('T',0,chip7_phy_init_ctrl.crystal_select);
    rx_spur_cal(false,false,rx_pwr);
    uVar1 = (*g_phyFuns->i2c_readReg_)('h','\x03','\0');
    rx_spur_cal(true,false,rx_pwr);
    oc_bw = (*g_phyFuns->i2c_readReg_)('f','\x04','\x05');
    bt_opt_write_mem('R',uVar1,oc_bw);
    (*g_phyFuns->i2c_writeReg_)('h','\x03','\0',phy_dac_org);
    p_Var2 = g_phyFuns->i2c_writeReg_;
  }
  else {
    (*g_phyFuns->i2c_writeReg_)('h','\x03',enable,phy_dac_org);
    p_Var2 = g_phyFuns->i2c_writeReg_;
  }
  (*p_Var2)('f','\x04','\x05',phy_dcur_org);
  uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  memw();
  _DAT_3ff4e0c4 = uVar3 & 0xffff83ff | 0x2c00;
  return;
}



// WARNING: Unknown calling convention

void phy_init_param_set(uint8 param)

{
  init_wifi_disable = (bool)(param & 1);
  memw();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void pbus_print(void)

{
  u16 uVar1;
  u16 uVar2;
  u16 uVar3;
  u16 uVar4;
  
  uVar1 = (*g_phyFuns->pbus_rd_)('\0','\x01');
  phy_printf("rfrx:0x%x;",uVar1);
  uVar1 = (*g_phyFuns->pbus_rd_)('\x04','\x01');
  uVar2 = (*g_phyFuns->pbus_rd_)('\x05','\x01');
  phy_printf("rftx:0x%x,0x%x;",uVar1,uVar2);
  uVar1 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
  uVar2 = (*g_phyFuns->pbus_rd_)('\x01','\x02');
  phy_printf("bb:0x%x,0x%x;",uVar1,uVar2);
  uVar1 = (*g_phyFuns->pbus_rd_)('\x02','\x01');
  uVar2 = (*g_phyFuns->pbus_rd_)('\x03','\x01');
  uVar3 = (*g_phyFuns->pbus_rd_)('\x02','\x02');
  uVar4 = (*g_phyFuns->pbus_rd_)('\x03','\x02');
  phy_printf("dco:%d,%d,%d,%d\n",uVar1,uVar2,uVar3,uVar4);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_reg_check(void)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff48000 + iVar3);
    iVar2 = iVar3 + 4;
    phy_printf("RTC 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0xd8);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff48800 + iVar3);
    iVar2 = iVar3 + 4;
    phy_printf("SAR 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0xa4);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff66000 + iVar3);
    iVar2 = iVar3 + 4;
    phy_printf("APB 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0x3c);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(iVar3 + 0x3ff00000);
    iVar2 = iVar3 + 4;
    phy_printf("DPORT 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0x5bc);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff46000 + iVar3);
    iVar2 = iVar3 + 4;
    phy_printf("fe 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0xfc);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(iVar3 + 0x3ff45000);
    iVar2 = iVar3 + 4;
    phy_printf("fe2 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0x11c);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(iVar3 + 0x3ff5c000);
    iVar2 = iVar3 + 4;
    phy_printf("agc 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0x128);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5d000 + iVar3);
    iVar2 = iVar3 + 4;
    phy_printf("bb 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0x6c);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c400 + iVar3);
    iVar2 = iVar3 + 4;
    phy_printf("bbtx 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 100);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(iVar3 + 0x3ff5c800);
    iVar2 = iVar3 + 4;
    phy_printf("brx 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0x9c);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(iVar3 + 0x3ff5cc00);
    iVar2 = iVar3 + 4;
    phy_printf("nrx 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0x118);
  iVar3 = 0;
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff51000 + iVar3);
    iVar2 = iVar3 + 4;
    phy_printf("bt_reg 0x%x: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 300);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_i2c_check(void)

{
  uint8 uVar1;
  int iVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('j','\x02',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_bias %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 10);
  iVar3 = 0;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('g','\x01',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_bbtop %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0x10);
  iVar3 = 0;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('f','\x04',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_bbpll %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0xd);
  iVar3 = 1;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('k','\x02',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_txrf %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0xc);
  iVar3 = 0;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('d','\0',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_rfrx %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0xb);
  iVar3 = 0;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('b','\x01',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_rfpll %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 0xc);
  iVar3 = 0;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('c','\0',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_rfpll_sdm %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 6);
  iVar3 = 0;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('e','\x04',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_ckgen %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 7);
  iVar3 = 0;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('h','\x03',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_xtal %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 3);
  iVar3 = 0;
  do {
    uVar1 = (*g_phyFuns->i2c_readReg_)('m','\x03',(uint8)iVar3);
    iVar2 = iVar3 + 1;
    phy_printf("i2c_plla %02d: 0x%x\n",iVar3,uVar1);
    iVar3 = iVar2;
  } while (iVar2 != 10);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_cal_print(void)

{
  char cVar1;
  short sVar2;
  uint16 *puVar3;
  uint32 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  sint16 *psVar7;
  sleep_param_t *psVar8;
  uint32 *puVar9;
  sleep_param_t *psVar10;
  uint32 *puVar11;
  sleep_param_t *psVar12;
  sint8 *psVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint32 uVar17;
  int iVar18;
  uint uVar19;
  int iVar20;
  
  phy_printf("phy_version: %d, %s, %s, %s\n",0x12e8,"02e0d70","Sep  2 2024","19:39:07");
  uVar5 = esp_dport_access_reg_read(0x3ff5a008);
  uVar6 = esp_dport_access_reg_read(0x3ff5a004);
  phy_printf("CHIP_ID: 0x%x, 0x%x\n\n",uVar5,uVar6);
  uVar4 = chip7_sleep_params.vdd33_code;
  phy_printf("param_flag: 0x%x\n",chip7_sleep_params.param_flag);
  phy_printf("vdd33=%d, temp_code=%d, offset=%d\n",uVar4 >> 0x10,uVar4 & 0xff,
             (int)(char)(uVar4 >> 8));
  phy_printf("rc_dout, %d; wifi: %d, %d, %d, %d, bt: %d, %d\n",chip7_sleep_params.rc_dout,
             chip7_sleep_params.filter_dcap_wifi[0],chip7_sleep_params.filter_dcap_wifi[1],
             chip7_sleep_params.filter_dcap_wifi[2],chip7_sleep_params.filter_dcap_wifi[3],
             chip7_sleep_params.filter_dcap_bt[0],chip7_sleep_params.filter_dcap_bt[1]);
  phy_printf("cal_rf_ana_gain, rf_gain=0x%x, ana_gain=0x%x\n",tx_rf_ana_gain[0],tx_rf_ana_gain[1]);
  psVar7 = noise_array;
  do {
    sVar2 = *psVar7;
    psVar7 = psVar7 + 1;
    phy_printf("RX_NOISEFLOOR, %d\n",(int)sVar2);
  } while (psVar7 != (sint16 *)&wifi_bbgain_max);
  phy_printf("TXCAP_TMX2G_CCT_LOAD, ");
  psVar10 = &chip7_sleep_params;
  psVar8 = &chip7_sleep_params;
  do {
    psVar12 = (sleep_param_t *)((int)&psVar8->param_flag + 3);
    phy_printf(&DAT_0005899c,psVar8->para_txcap[0]);
    psVar8 = psVar12;
  } while (psVar12 != (sleep_param_t *)chip7_sleep_params.txdc_table);
  phy_printf(&DAT_000589a4);
  phy_printf("TXCAP_PA2G_CCT_STG1, ");
  psVar8 = psVar10;
  do {
    psVar12 = (sleep_param_t *)((int)&psVar8->param_flag + 3);
    phy_printf(&DAT_0005899c,psVar8->para_txcap[1]);
    psVar8 = psVar12;
  } while (psVar12 != (sleep_param_t *)chip7_sleep_params.txdc_table);
  phy_printf(&DAT_000589a4);
  phy_printf("TXCAP_PA2G_CCT_STG2, ");
  psVar8 = psVar10;
  do {
    psVar12 = (sleep_param_t *)((int)&psVar8->param_flag + 3);
    phy_printf(&DAT_0005899c,psVar8->para_txcap[2]);
    psVar8 = psVar12;
  } while (psVar12 != (sleep_param_t *)chip7_sleep_params.txdc_table);
  phy_printf(&DAT_000589a4);
  phy_printf("TX_POWER_BACKOFF, ");
  psVar8 = psVar10;
  do {
    psVar12 = (sleep_param_t *)((int)&psVar8->param_flag + 2);
    phy_printf(&DAT_0005899c,(int)psVar8->target_power_chan_backoff[0]);
    psVar8 = psVar12;
  } while (psVar12 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  phy_printf(&DAT_000589a4);
  phy_printf("TX_PWRCTRL_ATTEN, ");
  psVar13 = chip7_sleep_params.tx_pwctrl_atten;
  do {
    cVar1 = *psVar13;
    psVar13 = psVar13 + 1;
    phy_printf(&DAT_0005899c,(int)cVar1);
  } while ((uint8 *)psVar13 != chip7_sleep_params.bt_pa_gain);
  phy_printf(&DAT_000589a4);
  phy_printf("TXIQ,");
  psVar8 = psVar10;
  do {
    psVar12 = (sleep_param_t *)((int)&psVar8->param_flag + 2);
    uVar15 = psVar8->wifi_txiq[0] >> 6 & 0x1f;
    uVar16 = (uint)(char)uVar15;
    uVar14 = psVar8->wifi_txiq[0] & 0x3f;
    uVar19 = (uint)(char)uVar14;
    if (0xf < uVar16) {
      uVar16 = uVar15 - 0x20;
    }
    if (0x1f < uVar19) {
      uVar19 = uVar14 - 0x40;
    }
    phy_printf("%d, %d; ",uVar16,uVar19);
    psVar8 = psVar12;
  } while (psVar12 != (sleep_param_t *)chip7_sleep_params.target_power_chan_backoff);
  phy_printf(&DAT_000589a4);
  phy_printf("TXDC, ");
  psVar8 = psVar10;
  do {
    psVar7 = psVar8->target_power_chan_backoff;
    phy_printf("%d, %d, %d, %d; ",psVar8->txdc_table[0],psVar8->txdc_table[1],psVar8->txdc_table[2],
               psVar8->txdc_table[3]);
    psVar8 = (sleep_param_t *)(psVar7 + 2);
  } while ((sleep_param_t *)(psVar7 + 2) != (sleep_param_t *)(chip7_sleep_params.txdc_table + 0xe));
  phy_printf(&DAT_000589a4);
  phy_printf("BT_PA_GAIN, ");
  psVar8 = psVar10;
  do {
    psVar12 = (sleep_param_t *)((int)&psVar8->param_flag + 1);
    phy_printf("0x%x, ",psVar8->bt_pa_gain[0]);
    psVar8 = psVar12;
  } while (psVar12 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  phy_printf(&DAT_000589a4);
  phy_printf("BT_DIG_ATTEN, ");
  psVar8 = psVar10;
  do {
    psVar12 = (sleep_param_t *)((int)&psVar8->param_flag + 1);
    phy_printf(&DAT_0005899c,(int)psVar8->bt_dig_atten[0]);
    psVar8 = psVar12;
  } while (psVar12 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  phy_printf(&DAT_000589a4);
  phy_printf("BT_TX_BB, 0x%x\n",chip7_sleep_params.bt_bb_gain);
  phy_printf("delta_bt_atten, ");
  psVar8 = psVar10;
  do {
    psVar12 = (sleep_param_t *)((int)&psVar8->param_flag + 1);
    phy_printf(&DAT_0005899c,(int)psVar8->delta_bt_atten[0]);
    psVar8 = psVar12;
  } while (psVar12 != (sleep_param_t *)((int)chip7_sleep_params.target_power_chan_backoff + 1));
  phy_printf(&DAT_000589a4);
  phy_printf("BT_TXIQ,");
  psVar8 = psVar10;
  do {
    uVar15 = psVar8->bt_txiq[0] >> 6 & 0x1f;
    uVar16 = (uint)(char)uVar15;
    uVar14 = psVar8->bt_txiq[0] & 0x3f;
    uVar19 = (uint)(char)uVar14;
    psVar8 = (sleep_param_t *)((int)&psVar8->param_flag + 2);
    if (0xf < uVar16) {
      uVar16 = uVar15 - 0x20;
    }
    if (0x1f < uVar19) {
      uVar19 = uVar14 - 0x40;
    }
    phy_printf("%d, %d; ",uVar16,uVar19);
  } while (psVar8 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 1));
  phy_printf(&DAT_000589a4);
  phy_printf("BT_TXDC, ");
  psVar8 = psVar10;
  do {
    psVar7 = psVar8->target_power_chan_backoff;
    phy_printf("%d, %d, %d, %d; ",psVar8->bt_txdc_table[0],psVar8->bt_txdc_table[1],
               psVar8->bt_txdc_table[2],psVar8->bt_txdc_table[3]);
    psVar8 = (sleep_param_t *)(psVar7 + 2);
  } while ((sleep_param_t *)(psVar7 + 2) != (sleep_param_t *)(chip7_sleep_params.txdc_table + 6));
  phy_printf(&DAT_000589a4);
  phy_printf("RXIQ, ");
  do {
    puVar3 = psVar10->wifi_rxiq;
    psVar10 = (sleep_param_t *)((int)&psVar10->param_flag + 2);
    uVar15 = *puVar3 >> 6 & 0x1f;
    uVar16 = (uint)(char)uVar15;
    uVar14 = *puVar3 & 0x3f;
    uVar19 = (uint)(char)uVar14;
    if (0xf < uVar16) {
      uVar16 = uVar15 - 0x20;
    }
    if (0x1f < uVar19) {
      uVar19 = uVar14 - 0x40;
    }
    phy_printf("%d, %d; ",uVar16,uVar19);
  } while (psVar10 != (sleep_param_t *)(chip7_sleep_params.target_power_chan_backoff + 2));
  phy_printf(&DAT_000589a4);
  phy_printf("RXDC_RFRX_BT, ");
  puVar11 = phy_rxrf_dc;
  puVar9 = phy_rxrf_dc + 9;
  do {
    uVar17 = *puVar11;
    puVar11 = puVar11 + 1;
    phy_printf("%d, %d; ",(int)uVar17 >> 0x10,(int)(short)uVar17);
  } while (puVar11 != phy_rxrf_dc + 9);
  phy_printf(&DAT_000589a4);
  phy_printf("RXDC_RFRX_WIFI, ");
  do {
    iVar20 = 0x100;
    iVar18 = 0x100;
    uVar17 = *puVar9;
    if (uVar17 != 0) {
      iVar18 = (int)uVar17 >> 0x10;
      iVar20 = (int)(short)uVar17;
    }
    puVar9 = puVar9 + 1;
    phy_printf("%d, %d; ",iVar18,iVar20);
  } while (puVar9 != (uint32 *)&para_num);
  phy_printf(&DAT_000589a4);
  phy_printf("RXDC_RXBB_WIFI, ");
  puVar9 = phy_rxbb_dc;
  do {
    iVar18 = *puVar9;
    puVar9 = (uint32 *)((int)puVar9 + 4);
    phy_printf("%d, %d; ",iVar18 >> 0x10,(int)(short)iVar18);
  } while ((code *)puVar9 != ets_isr_attach);
  phy_printf(&DAT_000589a4);
  phy_printf("TX_VDD33=%d\n",uVar4 >> 0x10);
  return;
}



// WARNING: Unknown calling convention

void RFChannelSel(int8 channel,int8 sub_chan_cfg)

{
  chip_v7_set_chan(channel,sub_chan_cfg);
  return;
}



// WARNING: Unknown calling convention

STATUS phy_change_channel(uint16 chanFreq,bool bHomeChan,bool pBReset,int8 sub_chan_cfg)

{
  set_chanfreq(chanFreq,sub_chan_cfg);
  return OK;
}



// WARNING: Unknown calling convention

STATUS phy_change_channel_nomac(uint16 chanFreq,bool bHomeChan,bool pBReset,int8 sub_chan_cfg)

{
  set_chanfreq_nomac(chanFreq,sub_chan_cfg);
  return OK;
}



// WARNING: Unknown calling convention

S16 get_rate_pwctrl_offset(uint8 rate)

{
  S16 SVar1;
  uint8 sub_rate;
  
  SVar1 = 8;
  if ((7 < rate >> 2) && (((rate & 3) != 3 || (SVar1 = -2, 0x17 < rate >> 2)))) {
    SVar1 = 0;
  }
  return SVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_set_bbfreq_init(bool en_11b)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5ccb8);
  _DAT_3ff5ccb8 = uVar1 & 0x1fffffff | 0x20000000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff5c85c);
  memw();
  _DAT_3ff5c85c = uVar1 & 0xfffffff0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_tx_pwctrl_bg_init(void)

{
  uint uVar1;
  
  (*g_phyFuns->en_pwdet_)();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e060);
  memw();
  _DAT_3ff4e060 = uVar1 | 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void pwdet_sar2_init(void)

{
  uint uVar1;
  
  set_xpd_sar(true);
  _DAT_3ff48890 = esp_dport_access_reg_read(&DAT_3ff48890);
  _DAT_3ff48890 = _DAT_3ff48890 | 0x8000000;
  memw();
  _DAT_3ff66010 = esp_dport_access_reg_read(&DAT_3ff66010);
  _DAT_3ff66010 = _DAT_3ff66010 & 0xfffffffb;
  memw();
  _DAT_3ff48890 = esp_dport_access_reg_read(&DAT_3ff48890);
  _DAT_3ff48890 = _DAT_3ff48890 & 0xefffffff;
  memw();
  _DAT_3ff48894 = esp_dport_access_reg_read(&DAT_3ff48894);
  _DAT_3ff48894 = _DAT_3ff48894 | 0x80000000;
  memw();
  _DAT_3ff48894 = esp_dport_access_reg_read(&DAT_3ff48894);
  _DAT_3ff48894 = _DAT_3ff48894 & 0x8007ffff;
  memw();
  _DAT_3ff4882c = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = _DAT_3ff4882c | 0xc;
  memw();
  _DAT_3ff48838 = esp_dport_access_reg_read(&DAT_3ff48838);
  _DAT_3ff48838 = _DAT_3ff48838 & 0x3fffffff;
  memw();
  _DAT_3ff48838 = esp_dport_access_reg_read(&DAT_3ff48838);
  _DAT_3ff48838 = _DAT_3ff48838 & 0xfffffffc;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4882c);
  memw();
  _DAT_3ff4882c = uVar1 & 0xffffff1f | 0x80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_en_pwdet(void)

{
  _DAT_3ff4e05c = esp_dport_access_reg_read(&DAT_3ff4e05c);
  _DAT_3ff4e05c = _DAT_3ff4e05c & 0xff7fffff;
  memw();
  _DAT_3ff4e05c = esp_dport_access_reg_read(&DAT_3ff4e05c);
  _DAT_3ff4e05c = _DAT_3ff4e05c & 0xffdfffff;
  memw();
  _DAT_3ff4e050 = esp_dport_access_reg_read(&DAT_3ff4e050);
  _DAT_3ff4e050 = _DAT_3ff4e050 & 0xfffffffe;
  memw();
  _DAT_3ff460c0 = esp_dport_access_reg_read(&DAT_3ff460c0);
  _DAT_3ff460c0 = _DAT_3ff460c0 | 0x80;
  memw();
  _DAT_3ff4e050 = esp_dport_access_reg_read(&DAT_3ff4e050);
  _DAT_3ff4e050 = _DAT_3ff4e050 | 0xc0;
  memw();
  pwdet_sar2_init();
  return;
}



// WARNING: Unknown calling convention

uint16 ram_index_to_txbbgain(uint8 index)

{
  uint16 uVar1;
  uint uVar2;
  
  uVar2 = index - 1 & 0xff;
  uVar1 = 0x100;
  if (uVar2 < 4) {
    uVar1 = *(uint16 *)((int)&CSWTCH_266 + uVar2 * 2);
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_txdc_cal_v70(sint16 *dc_comp)

{
  short sVar1;
  u8 uVar2;
  u16 uVar3;
  u16 uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  byte bVar8;
  int iVar9;
  int local_40;
  int iStack_3c;
  int iStack_38;
  u16 *puStack_34;
  
  (*g_phyFuns->pbus_force_test_)('\x02','\x02',0x100);
  (*g_phyFuns->pbus_force_test_)('\x03','\x02',0x100);
  local_40 = 1;
  puStack_34 = (u16 *)dc_comp;
  do {
    bVar8 = 0;
    iVar6 = 0x100;
    iVar9 = 0x7c;
    iStack_3c = 0;
    iStack_38 = 0;
    iVar7 = iVar6;
    do {
      uVar3 = (u16)iVar7;
      uVar4 = (u16)iVar6;
      uVar2 = (u8)local_40;
      (*g_phyFuns->pbus_force_test_)('\x03',uVar2,uVar3);
      (*g_phyFuns->pbus_force_test_)('\x02',uVar2,uVar4);
      ets_delay_us(2);
      uVar5 = esp_dport_access_reg_read(&DAT_3ff4e04c);
      _DAT_3ff4e04c = uVar5 & 0xff000000 | 0x113cf1;
      memw();
      uVar5 = esp_dport_access_reg_read(&DAT_3ff4e04c);
      _DAT_3ff4e04c = uVar5 & 0xff000000 | 0x113cf3;
      memw();
      do {
        uVar5 = esp_dport_access_reg_read(&DAT_3ff4e04c);
      } while ((uVar5 & 0x1000000) == 0);
      iVar6 = esp_dport_access_reg_read(&DAT_3ff4e04c);
      uVar5 = esp_dport_access_reg_read(&DAT_3ff4e04c);
      sVar1 = (short)iVar9;
      if (iVar6 < 0) {
        iVar6 = (uint)(-1 < (short)(uVar4 - sVar1)) * (int)(short)(uVar4 - sVar1);
      }
      else {
        iVar6 = (int)(short)(uVar4 + sVar1);
        iVar6 = (uint)(iVar6 < 0x1ff) * iVar6 + (uint)(iVar6 >= 0x1ff) * 0x1ff;
      }
      if ((uVar5 & 0x40000000) == 0) {
        iVar7 = (int)(short)(uVar3 + sVar1);
        iVar7 = (uint)(iVar7 < 0x1ff) * iVar7 + (uint)(iVar7 >= 0x1ff) * 0x1ff;
      }
      else {
        iVar7 = (uint)(-1 < (short)(uVar3 - sVar1)) * (int)(short)(uVar3 - sVar1);
      }
      if (iVar9 == 2) {
        iVar9 = 1;
      }
      else {
        iVar9 = (iVar9 >> 1) + 1;
      }
      if (7 < bVar8) {
        iStack_38 = (int)(short)((short)iStack_38 + (short)iVar6);
        iStack_3c = (int)(short)((short)iStack_3c + (short)iVar7);
      }
      bVar8 = bVar8 + 1;
    } while (bVar8 != 0xc);
    uVar3 = (u16)(iStack_3c + 2 >> 2);
    (*g_phyFuns->pbus_force_test_)('\x03',uVar2,uVar3);
    uVar4 = (u16)(iStack_38 + 2 >> 2);
    local_40 = local_40 + 1;
    (*g_phyFuns->pbus_force_test_)('\x02',uVar2,uVar4);
    *puStack_34 = uVar4;
    puStack_34[1] = uVar3;
    puStack_34 = puStack_34 + 2;
  } while (local_40 != 3);
  uVar5 = esp_dport_access_reg_read(&DAT_3ff4e04c);
  memw();
  _DAT_3ff4e04c = uVar5 & 0xff000000 | 0x113cf0;
  return;
}



// WARNING: Unknown calling convention

void txcal_debuge_mode(bool bt_mode)

{
  byte bVar1;
  
  (*g_phyFuns->pbus_debugmode_)();
  (*g_phyFuns->pbus_xpd_tx_on_)((ushort)bt_mode << 8 | tx_rf_ana_gain[0],tx_rf_ana_gain[1]);
  bVar1 = (*g_phyFuns->txbbgain_to_index_)(tx_rf_ana_gain[1]);
  (*g_phyFuns->pbus_set_dco_)(chip7_sleep_params.txdc_table + (uint)bVar1 * 4);
  (*g_phyFuns->set_txclk_en_)(true);
  (*g_phyFuns->en_pwdet_)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_txcal_work_mode(void)

{
  (*g_phyFuns->stop_tx_tone_)(1);
  (*g_phyFuns->set_txclk_en_)(false);
  (*g_phyFuns->pbus_xpd_rx_on_)(0);
  (*g_phyFuns->pbus_workmode_)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

S16 ram_get_fm_sar_dout(S16 *vsig_dc,S16 *vref_dc)

{
  short sVar1;
  uint uVar2;
  S16 SVar3;
  uint uVar4;
  U16 vsig;
  uint uVar5;
  U16 vref;
  uint uVar6;
  U16 e [8];
  
  _DAT_3ff4e050 = esp_dport_access_reg_read(&DAT_3ff4e050);
  _DAT_3ff4e050 = _DAT_3ff4e050 & 0xfffffffd;
  memw();
  _DAT_3ff4e050 = esp_dport_access_reg_read(&DAT_3ff4e050);
  _DAT_3ff4e050 = _DAT_3ff4e050 | 2;
  memw();
  ets_delay_us(10);
  do {
    uVar2 = esp_dport_access_reg_read(&DAT_3ff4e050);
  } while ((uVar2 >> 0x18 & 7) != 0);
  (*g_phyFuns->read_sar_dout_)(e);
  SVar3 = 0;
  uVar2 = (uint)e[6] + (uint)e[7];
  uVar4 = uVar2 & 0xffff;
  uVar5 = (uint)e[3] + (uint)e[2];
  uVar6 = (uint)e[4] + (uint)e[5];
  sVar1 = (short)uVar2;
  if (uVar4 <= (uVar5 & 0xffff)) {
    SVar3 = (short)uVar5 - sVar1;
  }
  *vsig_dc = SVar3;
  memw();
  SVar3 = 0;
  if (uVar4 <= (uVar6 & 0xffff)) {
    SVar3 = (short)uVar6 - sVar1;
  }
  *vref_dc = SVar3;
  memw();
  return (S16)((int)((uint)e[3] + (uint)e[4] + (uint)e[5] + (uint)e[6]) >> 2);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_txiq_get_mis_pwr(bool gain_en,uint8 bb_att,S16 tone_freq,S16 *pwr1,S16 *pwr2,bool pkdet_en)

{
  S16 SVar1;
  uint uVar2;
  uint uVar3;
  
  uVar2 = (uint)gain_en;
  uVar3 = esp_dport_access_reg_read(&DAT_3ff460b8);
  _DAT_3ff460b8 =
       ((int)tone_freq >> 2 | 0x2c0000U | uVar2 << 0x1a) & 0xfffffff | (-(uint)bb_att & 0xff) << 10
       | uVar3 & 0xf0000000;
  memw();
  uVar3 = esp_dport_access_reg_read(&DAT_3ff450a8);
  _DAT_3ff450a8 = uVar3 & 0xfffffffc | (int)tone_freq & 3U;
  memw();
  ets_delay_us(10);
  SVar1 = (*g_phyFuns->txtone_linear_pwr_)(pkdet_en);
  *pwr1 = SVar1;
  memw();
  uVar3 = esp_dport_access_reg_read(&DAT_3ff460b8);
  _DAT_3ff460b8 = ((uVar2 ^ 1) & 1 | (uVar2 & 1) << 3) << 0x18 | uVar3 & 0xf0ffffff;
  memw();
  ets_delay_us(10);
  SVar1 = (*g_phyFuns->txtone_linear_pwr_)(pkdet_en);
  *pwr2 = SVar1;
  memw();
  return;
}



// WARNING: Unknown calling convention

void ram_txiq_cover(U8 tone_atten,S16 tone_freq,int8 *mis_data,bool pkdet_en)

{
  int8 iVar1;
  byte bVar2;
  sint32 sVar3;
  int8 iVar4;
  uint uVar5;
  int iVar6;
  byte bVar7;
  int iVar8;
  int iVar9;
  S16 pwr2;
  S16 pwr1;
  int iStack_40;
  uint uStack_3c;
  uint uStack_38;
  uint uStack_34;
  int iStack_30;
  uint uStack_2c;
  
  uStack_3c = (uint)pkdet_en;
  uStack_34 = (uint)tone_atten;
  bVar7 = 0;
  iStack_40 = (int)tone_freq;
  iStack_30 = (uint)(-1 < (char)(tone_atten + 0xf4)) * (int)(char)(tone_atten + 0xf4);
  uVar5 = 0;
  iVar1 = '\0';
  uStack_38 = 0;
  uStack_2c = 0;
  do {
    if (bVar7 < 4) {
      iVar1 = (*g_phyFuns->txiq_set_reg_)(iVar1,true);
      bVar2 = (*g_phyFuns->txiq_set_reg_)((int8)uVar5,false);
      uVar5 = (uint)bVar2;
    }
    iVar4 = (int8)uVar5;
    (*g_phyFuns->txiq_get_mis_pwr_)
              (true,(uint8)iStack_30,(S16)iStack_40,&pwr1,&pwr2,SUB41(uStack_3c,0));
    iVar9 = (int)pwr2;
    iVar6 = (int)pwr1;
    iVar8 = (uint)(iVar9 < iVar6) * iVar9 + (uint)(iVar9 >= iVar6) * iVar6;
    if (iVar8 == 0) {
      iVar8 = 1;
    }
    *mis_data = (int8)(((iVar9 - iVar6) * 0x800) / iVar8 + 0x10 >> 5);
    memw();
    (*g_phyFuns->txiq_get_mis_pwr_)
              (false,(uint8)uStack_34,(S16)iStack_40,&pwr1,&pwr2,SUB41(uStack_3c,0));
    iVar6 = (int)(short)(pwr1 + pwr2);
    if (iVar6 == 0) {
      iVar6 = 1;
    }
    iVar6 = (((int)pwr1 - (int)pwr2) * 0x1000) / iVar6 + 0x10 >> 5;
    mis_data[1] = (int8)iVar6;
    memw();
    if (bVar7 < 3) {
      uVar5 = uVar5 - iVar6 & 0xff;
      iVar1 = iVar1 - *mis_data;
    }
    else {
      uStack_38 = iVar6 + uStack_38 & 0xff;
      uStack_2c = (byte)*mis_data + uStack_2c & 0xff;
      sVar3 = (*g_phyFuns->abs_temp_)((int)*mis_data);
      if ((sVar3 < 2) && (sVar3 = (*g_phyFuns->abs_temp_)((int)mis_data[1]), sVar3 < 2))
      goto LAB_0004d9dc;
      if (bVar7 == 6) {
        iVar1 = iVar1 - (char)((char)uStack_2c + 2 >> 2);
        iVar4 = iVar4 - (char)((char)uStack_38 + 2 >> 2);
        goto LAB_0004d9dc;
      }
    }
    iVar4 = (int8)uVar5;
    bVar7 = bVar7 + 1;
    if (bVar7 == 7) {
LAB_0004d9dc:
      (*g_phyFuns->txiq_set_reg_)(iVar1,true);
      (*g_phyFuns->txiq_set_reg_)(iVar4,false);
      *mis_data = iVar1;
      mis_data[1] = iVar4;
      memw();
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rfcal_txiq(uint16 bbgain,uint16 *txdc,uint16 *para_txiq,uint8 tone_freq,int8 tone_atten,
               uint8 func_sel)

{
  uint8 uVar1;
  u16 uVar2;
  S16 SVar3;
  undefined4 uVar4;
  uint uVar5;
  ushort uVar6;
  char cVar7;
  ushort uVar8;
  _func_void_u8_u8_u16 *p_Var9;
  int iVar10;
  int8 mis_data [2];
  u32 tone_reg_old;
  
  _DAT_3ff450dc = esp_dport_access_reg_read(&DAT_3ff450dc);
  _DAT_3ff450dc = _DAT_3ff450dc | 0x800;
  memw();
  _DAT_3ff450dc = esp_dport_access_reg_read();
  _DAT_3ff450dc = _DAT_3ff450dc & 0xffffefff;
  memw();
  txcal_debuge_mode(func_sel == '\x01');
  (*g_phyFuns->pbus_force_test_)('\x01','\x02',bbgain);
  if (func_sel == '\x01') {
    p_Var9 = g_phyFuns->pbus_force_test_;
    uVar2 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
    (*p_Var9)('\x01','\x01',uVar2 | 2);
  }
  else if (func_sel == '\x02') {
    (*g_phyFuns->loopback_mode_en_)(true);
    (*g_phyFuns->txdc_cal_v70_)((sint16 *)txdc);
    goto LAB_0004dadd;
  }
  (*g_phyFuns->pbus_set_dco_)(txdc);
LAB_0004dadd:
  uVar4 = esp_dport_access_reg_read(&DAT_3ff460b8);
  cVar7 = '\x04';
  do {
    (*g_phyFuns->start_tx_tone_step_)(true,(ushort)tone_freq,tone_atten,false,0,'\0');
    ets_delay_us(2);
    SVar3 = (*g_phyFuns->txtone_linear_pwr_)(false);
    uVar1 = tone_atten + '\x04';
    if ((SVar3 >> 2 < 0x3e9) && (uVar1 = tone_atten + 0xfc, 599 < SVar3 >> 2)) break;
    tone_atten = uVar1;
    cVar7 = cVar7 + -1;
  } while (cVar7 != '\0');
  iVar10 = (int)tone_atten;
  iVar10 = (uint)(iVar10 < 0x78) * iVar10 + (uint)(iVar10 >= 0x78) * 0x78;
  ram_txiq_cover((-1 < iVar10) * (char)iVar10,(ushort)tone_freq,mis_data,false);
  (*g_phyFuns->txcal_work_mode_)();
  if (mis_data[0] < '\x10') {
    if (mis_data[0] < -0xf) {
      mis_data[0] = -0xf;
      memw();
      uVar6 = 0x440;
    }
    else {
      uVar6 = (ushort)(((byte)mis_data[0] & 0x1f) << 6);
    }
  }
  else {
    uVar6 = 0x3c0;
    mis_data[0] = '\x0f';
    memw();
  }
  if (mis_data[1] < ' ') {
    if (mis_data[1] < -0x1f) {
      mis_data[1] = -0x1f;
      memw();
      uVar8 = 0x21;
    }
    else {
      uVar8 = (byte)mis_data[1] & 0x3f;
    }
  }
  else {
    uVar8 = 0x1f;
    mis_data[1] = '\x1f';
    memw();
  }
  *para_txiq = uVar6 | uVar8;
  memw();
  memw();
  _DAT_3ff460b8 = uVar4;
  if (func_sel == '\x02') {
    (*g_phyFuns->loopback_mode_en_)(false);
  }
  uVar5 = esp_dport_access_reg_read(&DAT_3ff450dc);
  memw();
  _DAT_3ff450dc = uVar5 | 0x1000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_iq_est_enable(bool iq_est_en,uint16 est_length)

{
  uint uVar1;
  int iVar2;
  uint32_t val;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff46060);
  _DAT_3ff46060 = uVar1 & 0xf3ffffff | 0x4000000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4607c);
  _DAT_3ff4607c = uVar1 & 0xffe7ffff | 0x100000;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4607c);
  _DAT_3ff4607c = (est_length & 0x7fff) << 2 | uVar1 & 0xfffe0003;
  memw();
  _DAT_3ff4607c = esp_dport_access_reg_read(&DAT_3ff4607c);
  _DAT_3ff4607c = _DAT_3ff4607c | 1;
  memw();
  ets_delay_us(1);
  _DAT_3ff4607c = esp_dport_access_reg_read(&DAT_3ff4607c);
  _DAT_3ff4607c = _DAT_3ff4607c | 2;
  memw();
  do {
    iVar2 = esp_dport_access_reg_read(&DAT_3ff4607c);
  } while (-1 < iVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_iq_est_disable(void)

{
  uint uVar1;
  
  _DAT_3ff4607c = esp_dport_access_reg_read(&DAT_3ff4607c);
  _DAT_3ff4607c = _DAT_3ff4607c & 0xfffffffd;
  memw();
  ets_delay_us(1);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4607c);
  memw();
  _DAT_3ff4607c = uVar1 & 0xfffffffe;
  return;
}



// WARNING: Unknown calling convention

void ram_dc_iq_est(bool dc_est_en,uint16 smp_num,sint32 *dc_est)

{
  S16 SVar1;
  int iVar2;
  int iVar3;
  _func_void_varargs *p_Var4;
  
  iVar3 = smp_num + 1;
  (*g_phyFuns->iq_est_enable_)(dc_est_en,smp_num);
  iVar2 = esp_dport_access_reg_read(0x3ff460dc);
  *dc_est = (iVar2 >> 6) / iVar3;
  iVar2 = esp_dport_access_reg_read(0x3ff460e0);
  dc_est[1] = (iVar2 >> 6) / iVar3;
  iVar2 = esp_dport_access_reg_read(0x3ff460e4);
  iVar2 = (iVar2 / iVar3) * 8 - (*dc_est * *dc_est + dc_est[1] * dc_est[1]);
  SVar1 = (*g_phyFuns->linear_to_db_)((uint)(-1 < iVar2) * iVar2,'\0');
  p_Var4 = g_phyFuns->iq_est_disable_;
  dc_est[2] = SVar1 + 8 >> 4;
  (*p_Var4)();
  return;
}



// WARNING: Unknown calling convention

void ram_pbus_rx_dco_cal(uint16 smp_num,sint16 *dc_comp,uint16 ext_delay_us,bool rxdc_print_en,
                        bool print_debug)

{
  char cVar1;
  char cVar2;
  u16 uVar3;
  uint uVar4;
  int iVar5;
  sint32 sVar6;
  int iVar7;
  int iVar8;
  char cVar9;
  int iVar10;
  uint uVar11;
  int iVar12;
  u16 *puVar13;
  _func_void_u8_u8_u16 *p_Var14;
  sint32 dc_est [3];
  int iStack_5c;
  uint uStack_44;
  uint uStack_34;
  
  uVar3 = (*g_phyFuns->pbus_rd_)('\x01','\x02');
  uVar4 = uVar3 & 0x3f;
  if ((uVar3 & 0x3f) == 0) {
    uStack_34 = uVar3 >> 6 & 0xff;
    (*g_phyFuns->pbus_force_test_)('\x02','\x02',0x100);
    iVar12 = 5;
    (*g_phyFuns->pbus_force_test_)('\x03','\x02',0x100);
    uStack_44 = 0;
  }
  else {
    uStack_44 = 0;
    do {
      uVar11 = uVar4 & 1;
      uVar4 = uVar4 >> 1;
      uStack_44 = uStack_44 + uVar11 & 0xff;
    } while (uVar4 != 0);
    uStack_34 = uVar3 >> 6 & 0xff;
    (*g_phyFuns->pbus_force_test_)('\x02','\x02',0x100);
    (*g_phyFuns->pbus_force_test_)('\x03','\x02',0x100);
    iVar12 = 0xf;
    if (uStack_44 < 3) {
      iVar12 = 5;
    }
  }
  uVar4 = 4;
  if (2 < uStack_44) {
    uVar4 = uStack_44 + 2 & 0xff;
  }
  iVar7 = 5;
  if (uStack_44 < 4) {
    iVar7 = 2;
  }
  uVar11 = (uStack_44 + 6 & 0xff) + 2;
  iStack_5c = 0;
  puVar13 = (u16 *)dc_comp;
  do {
    iVar5 = 0x200;
    iVar8 = 0x200;
    cVar1 = '\x04';
    if (iStack_5c == 0) {
      iVar8 = (int)(short)((int)*dc_comp << 1);
      iVar5 = (int)(short)((int)dc_comp[1] << 1);
      cVar1 = '\f';
    }
    iVar10 = iStack_5c + 1;
    cVar9 = '\0';
    do {
      uVar3 = (u16)(iVar8 + 1 >> 1);
      p_Var14 = g_phyFuns->pbus_force_test_;
      *puVar13 = uVar3;
      memw();
      (*p_Var14)('\x02',(u8)iVar10,uVar3);
      uVar3 = (u16)(iVar5 + 1 >> 1);
      p_Var14 = g_phyFuns->pbus_force_test_;
      puVar13[1] = uVar3;
      memw();
      (*p_Var14)('\x03',(u8)iVar10,uVar3);
      ets_delay_us(ext_delay_us);
      (*g_phyFuns->dc_iq_est_)(true,smp_num,dc_est);
      if (print_debug) {
        phy_printf(" (%d,%d) ",(int)(short)*puVar13,(int)(short)puVar13[1]);
        phy_printf("%d,%d ",dc_est[0],dc_est[1]);
      }
      sVar6 = (*g_phyFuns->abs_temp_)(dc_est[0]);
      if ((sVar6 <= iVar12) &&
         (sVar6 = (*g_phyFuns->abs_temp_)(dc_est[1]), cVar2 = cVar9, sVar6 <= iVar12)) break;
      if (iStack_5c == 0) {
        sVar6 = (*g_phyFuns->abs_temp_)(dc_est[0]);
        if (iVar12 < sVar6) {
          iVar8 = (int)(short)((short)iVar8 -
                              (short)((int)((uint)"PG?82,"[uStack_34] * dc_est[0] * 6) >>
                                     (uVar11 & 0x1f)));
        }
        sVar6 = (*g_phyFuns->abs_temp_)(dc_est[1]);
        if (iVar12 < sVar6) {
          iVar5 = (int)(short)((short)iVar5 -
                              (short)((int)((uint)"PG?82,"[uStack_34] * dc_est[1] * 6) >>
                                     (uVar11 & 0x1f)));
        }
      }
      else {
        sVar6 = (*g_phyFuns->abs_temp_)(dc_est[0]);
        if (iVar12 < sVar6) {
          iVar8 = (int)(short)((short)iVar8 - (short)(dc_est[0] * 0x118 >> (uVar4 + 2 & 0x1f)));
        }
        sVar6 = (*g_phyFuns->abs_temp_)(dc_est[1]);
        if (iVar12 < sVar6) {
          iVar5 = (int)(short)((short)iVar5 - (short)(dc_est[1] * 0x118 >> (uVar4 + 2 & 0x1f)));
        }
      }
      iVar8 = (uint)(iVar8 < 0x3fe) * iVar8 + (uint)(iVar8 >= 0x3fe) * 0x3fe;
      iVar5 = (uint)(iVar5 < 0x3fe) * iVar5 + (uint)(iVar5 >= 0x3fe) * 0x3fe;
      cVar9 = cVar9 + '\x01';
      iVar8 = (uint)(-1 < iVar8) * iVar8;
      iVar5 = (uint)(-1 < iVar5) * iVar5;
      cVar2 = cVar1;
    } while (cVar1 != cVar9);
    if (rxdc_print_en) {
      phy_printf("stage %d: CGAIN=%d FGAIN=%d, (%d,%d) %d; ",iVar10,uStack_44,uStack_34,dc_est[0],
                 dc_est[1],cVar2);
    }
    if (print_debug) {
      phy_printf(&DAT_00058ecc);
    }
    puVar13 = puVar13 + 2;
    iVar12 = iVar7;
    iStack_5c = iVar10;
    if (iVar10 == 2) {
      if (!rxdc_print_en) {
        return;
      }
      phy_printf(&DAT_00058ecc);
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void rxdc_est_min(uint16 smp_num,bool cal_en,int32 *dc_est)

{
  int iVar1;
  byte bVar2;
  int32 dc_est_m [3];
  
  iVar1 = 100;
  bVar2 = 0;
  do {
    (*g_phyFuns->dc_iq_est_)(true,smp_num,dc_est_m);
    if ((dc_est_m[2] < iVar1) || (bVar2 == 0)) {
      *dc_est = dc_est_m[0];
      dc_est[2] = dc_est_m[2];
      dc_est[1] = dc_est_m[1];
      if (dc_est_m[2] < 0x30 && 1 < bVar2) {
        return;
      }
      iVar1 = dc_est_m[2];
      if (dc_est_m[2] < 0x24) {
        return;
      }
    }
    else if ((iVar1 < 0x30) && (1 < bVar2)) {
      return;
    }
    bVar2 = bVar2 + 1;
    if (bVar2 == 10) {
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void pbus_rx_dco_cal_1step
               (bool bt_mode,uint8 mode,uint16 smp_num,sint16 *dc_comp,int32 *dc_est,uint8 *dc_flag)

{
  bool bVar1;
  bool bVar2;
  phy_romfuncs *ppVar3;
  u8 uVar4;
  u16 uVar5;
  u16 uVar6;
  uint uVar7;
  _func_void_u8_u8_u16 *p_Var8;
  int iVar9;
  s32 sVar10;
  int32 *piVar11;
  sint32 sVar12;
  short sVar13;
  int iVar14;
  int32 *piVar15;
  uint uVar16;
  int32 *piVar17;
  char cVar18;
  int iVar19;
  int iVar20;
  sint16 *psVar21;
  int32 iVar22;
  sint32 sVar23;
  sint32 sVar24;
  sint32 sVar25;
  _func_sint32_sint32 *p_Var26;
  int32 dcest_pwrm [16];
  int32 dcestq [16];
  int32 dcesti [16];
  sint16 dcomq [16];
  sint16 dcomi [16];
  int32 dc_est_1 [3];
  int32 dc_est_0 [3];
  sint16 *psStack_6c;
  int iStack_68;
  int iStack_64;
  int iStack_50;
  uint16 rfrx;
  
  iVar19 = 8;
  if (mode != '\x01') {
    iVar19 = 0x10;
  }
  psStack_6c = (sint16 *)(int)*dc_comp;
  iStack_68 = (int)dc_comp[1];
  dc_est_0[0] = 0;
  dc_est_0[1] = 0;
  dc_est_0[2] = 0;
  dc_est_1[0] = 0;
  dc_est_1[1] = 0;
  dc_est_1[2] = 0;
  uVar5 = (*g_phyFuns->pbus_rd_)('\x01','\x02');
  uVar6 = (*g_phyFuns->pbus_rd_)('\0','\x01');
  uVar7 = uVar5 & 1;
  if ((uVar7 < 3) || (mode != '\x01')) {
    cVar18 = '\x01';
  }
  else {
    cVar18 = (char)uVar7 + -1;
  }
  uVar4 = (mode == '\x01') + '\x01';
  iVar20 = (int)cVar18;
  iStack_64 = 0;
  *dc_flag = '\0';
  cVar18 = '\0';
  do {
    uVar5 = (u16)psStack_6c;
    p_Var8 = g_phyFuns->pbus_force_test_;
    *dc_comp = uVar5;
    sVar13 = (short)iStack_68;
    dc_comp[1] = sVar13;
    memw();
    (*p_Var8)('\x02',uVar4,uVar5);
    (*g_phyFuns->pbus_force_test_)('\x03',uVar4,dc_comp[1]);
    if (mode == '\x01') {
      ets_delay_us(10);
      rxdc_est_min(smp_num,true,dc_est);
      iStack_50 = dc_est[2];
      if (uVar7 < 2) {
        iVar9 = 2;
        uVar16 = 0;
        sVar24 = *dc_est;
      }
      else {
        sVar24 = *dc_est;
        iVar9 = 2;
        uVar16 = uVar7 - 1 & 0xff;
      }
    }
    else {
      (*g_phyFuns->pbus_force_test_)('\x01','\x02',0);
      ets_delay_us(10);
      rxdc_est_min(smp_num,true,dc_est_0);
      (*g_phyFuns->pbus_force_test_)('\x01','\x02',0x20);
      ets_delay_us(10);
      rxdc_est_min(smp_num,true,dc_est_1);
      uVar16 = 0;
      iVar9 = 1;
      sVar24 = dc_est_1[0] - dc_est_0[0];
      iStack_50 = (uint)(dc_est_1[2] < dc_est_0[2]) * dc_est_0[2] +
                  (uint)(dc_est_1[2] >= dc_est_0[2]) * dc_est_1[2];
      *dc_est = sVar24;
      dc_est[1] = dc_est_1[1] - dc_est_0[1];
    }
    sVar24 = (*g_phyFuns->abs_temp_)(sVar24);
    if (sVar24 < iVar20) {
      sVar24 = (*g_phyFuns->abs_temp_)(dc_est[1]);
      if (sVar24 < iVar20) {
        iVar9 = 0;
      }
      else {
        iVar9 = (int)(short)(iVar9 * dc_est[1] >> (uVar16 & 0x1f));
      }
LAB_0004e357:
      sVar24 = (*g_phyFuns->abs_temp_)(dc_est_0[0]);
      if (sVar24 < 0x32) {
        iVar14 = 1;
        if (*dc_est < 1) {
          iVar14 = -(uint)(*dc_est != 0);
        }
      }
      else {
        iVar14 = (int)(short)(dc_est_0[0] >> (uVar16 & 0x1f));
      }
LAB_0004e385:
      if (iVar9 == 0) goto LAB_0004e387;
    }
    else {
      iVar14 = (int)(short)(iVar9 * *dc_est >> (uVar16 & 0x1f));
      sVar24 = (*g_phyFuns->abs_temp_)(dc_est[1]);
      if (iVar20 <= sVar24) {
        iVar9 = (int)(short)(iVar9 * dc_est[1] >> (uVar16 & 0x1f));
        if (iVar14 == 0) goto LAB_0004e357;
        goto LAB_0004e385;
      }
      if (iVar14 == 0) {
        iVar9 = 0;
        goto LAB_0004e357;
      }
LAB_0004e387:
      sVar24 = (*g_phyFuns->abs_temp_)(dc_est_0[1]);
      if (sVar24 < 0x32) {
        iVar9 = 1;
        if (dc_est[1] < 1) {
          iVar9 = -(uint)(dc_est[1] != 0);
        }
      }
      else {
        iVar9 = (int)(short)(dc_est_0[1] >> (uVar16 & 0x1f));
      }
    }
    if (mode == '\x01') {
      sVar24 = *dc_est;
    }
    else {
      if ((0x33 < dc_est_0[2]) || (0x33 < dc_est_1[2])) {
        iVar9 = 0;
        iVar14 = 0;
      }
      if (0x186 < uVar6) {
        sVar10 = (*g_phyFuns->get_data_sat_)(iVar14,5,-5);
        iVar14 = (int)(short)sVar10;
        sVar10 = (*g_phyFuns->get_data_sat_)(iVar9,5,-5);
        iVar9 = (int)(short)sVar10;
      }
      dcomi[iStack_64] = uVar5;
      memw();
      sVar24 = *dc_est;
      iVar22 = dc_est[1];
      dcomq[iStack_64] = sVar13;
      memw();
      dcesti[iStack_64] = sVar24;
      dcestq[iStack_64] = iVar22;
      dcest_pwrm[iStack_64] = iStack_50;
    }
    sVar24 = (*g_phyFuns->abs_temp_)(sVar24);
    if (((sVar24 <= iVar20) && (sVar24 = (*g_phyFuns->abs_temp_)(dc_est[1]), iStack_50 < 0x31)) &&
       (sVar24 <= iVar20)) {
      sVar24 = (*g_phyFuns->abs_temp_)(dc_est_0[0]);
      if ((sVar24 < 0x1e) && (sVar24 = (*g_phyFuns->abs_temp_)(dc_est_0[1]), sVar24 < 0x1e)) {
        *dc_flag = '\x01';
        memw();
        goto code_r0x0004e6ad;
      }
      break;
    }
    sVar24 = (*g_phyFuns->abs_temp_)(*dc_est);
    if (iVar20 < sVar24) {
      psStack_6c = (sint16 *)(int)(short)(uVar5 - (short)iVar14);
    }
    sVar24 = (*g_phyFuns->abs_temp_)(dc_est[1]);
    if (iVar20 < sVar24) {
      iStack_68 = (int)(short)(sVar13 - (short)iVar9);
    }
    cVar18 = cVar18 + '\x01';
    iVar9 = (uint)((int)psStack_6c < 0x1ff) * (int)psStack_6c +
            (uint)((int)psStack_6c >= 0x1ff) * 0x1ff;
    iStack_68 = (uint)(iStack_68 < 0x1ff) * iStack_68 + (uint)(iStack_68 >= 0x1ff) * 0x1ff;
    psStack_6c = (sint16 *)((uint)(-1 < iVar9) * iVar9);
    iStack_68 = (uint)(-1 < iStack_68) * iStack_68;
    iStack_64 = (int)cVar18;
  } while (iStack_64 < iVar19);
  if (((mode != '\x01') && (*dc_flag == '\0')) && ('\x0e' < cVar18)) {
    if (0x30 < iStack_50) {
      *dc_est = 100;
      dc_est[1] = 100;
    }
    bVar2 = false;
    piVar17 = dcesti + 0xf;
    psStack_6c = dcomq + 0xf;
    psVar21 = dcomi + 0xf;
    piVar15 = dcest_pwrm + 0xf;
    bVar1 = false;
    piVar11 = dcestq + 0xf;
    do {
      sVar23 = *piVar17;
      sVar24 = (*g_phyFuns->abs_temp_)(sVar23);
      sVar12 = (*g_phyFuns->abs_temp_)(*dc_est);
      ppVar3 = g_phyFuns;
      if (sVar24 < sVar12) {
        if (0x30 < *piVar15) {
          (*g_phyFuns->abs_temp_)(*piVar11);
          (*g_phyFuns->abs_temp_)(dc_est[1]);
LAB_0004e648:
          if (!bVar1) goto LAB_0004e64d;
LAB_0004e661:
          bVar1 = true;
          goto code_r0x0004e66e;
        }
        sVar25 = *piVar11;
        *dc_comp = *psVar21;
        memw();
        p_Var26 = ppVar3->abs_temp_;
        *dc_est = sVar23;
        sVar24 = (*p_Var26)(sVar25);
        sVar12 = (*g_phyFuns->abs_temp_)(dc_est[1]);
        if (sVar12 <= sVar24) goto LAB_0004e661;
        bVar2 = true;
        bVar1 = true;
        dc_comp[1] = *psStack_6c;
        dc_est[1] = sVar25;
      }
      else {
        sVar23 = *piVar11;
        sVar24 = (*g_phyFuns->abs_temp_)(sVar23);
        sVar12 = (*g_phyFuns->abs_temp_)(dc_est[1]);
        if ((sVar12 <= sVar24) || (0x30 < *piVar15)) goto LAB_0004e648;
        dc_comp[1] = *psStack_6c;
        dc_est[1] = sVar23;
        bVar2 = true;
        if (bVar1) {
          bVar1 = true;
          goto LAB_0004e687;
        }
LAB_0004e64d:
        bVar1 = false;
        *dc_comp = dcomi[0];
        memw();
code_r0x0004e66e:
        if (bVar2) {
          bVar2 = true;
        }
        else {
          dc_comp[1] = dcomq[0];
          memw();
        }
      }
LAB_0004e687:
      piVar17 = piVar17 + -1;
      piVar15 = piVar15 + -1;
      psVar21 = psVar21 + -1;
      piVar11 = piVar11 + -1;
      psStack_6c = psStack_6c + -1;
    } while (dcestq + 0xf != piVar17);
  }
code_r0x0004e6ad:
  uVar5 = *dc_comp;
  if ((short)uVar5 < 0) {
    uVar5 = 0;
    *dc_comp = 0;
    memw();
  }
  else if (0x1ff < (short)uVar5) {
    uVar5 = 0x1ff;
    *dc_comp = 0x1ff;
    memw();
  }
  if (dc_comp[1] < 0) {
    dc_comp[1] = 0;
    memw();
  }
  else if (0x1ff < dc_comp[1]) {
    dc_comp[1] = 0x1ff;
    memw();
  }
  (*g_phyFuns->pbus_force_test_)('\x02',uVar4,uVar5);
  (*g_phyFuns->pbus_force_test_)('\x03',uVar4,dc_comp[1]);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rc_cal(void)

{
  short sVar1;
  uint uVar2;
  uint uVar3;
  short sVar4;
  uint uVar5;
  short sVar6;
  uint uVar7;
  short sVar8;
  uint uVar9;
  short sVar10;
  uint8 uVar11;
  
  if ((chip7_sleep_params.param_flag & 0x800000) == 0) {
    (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\x06','\x04','\0','\x02');
    (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\0','\x05','\x04','\x02');
    uVar11 = '\a';
    if ((chip7_phy_init_ctrl.crystal_select != '\x01') &&
       (uVar11 = '\v', chip7_phy_init_ctrl.crystal_select == '\x02')) {
      uVar11 = '\x06';
    }
    (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\x04','\a','\x04',uVar11);
    (*g_phyFuns->i2c_writeReg_Mask_)('h','\x03','\x01','\x05','\x05','\x01');
    (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\x04','\0','\0','\x01');
    (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\x04','\x03','\x03','\0');
    (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\x04','\x03','\x03','\x01');
    ets_delay_us(100);
    chip7_sleep_params.rc_dout = (*g_phyFuns->i2c_readReg_Mask_)('j','\x02','\x05','\x05','\0');
    uVar2 = (uint)chip7_sleep_params.rc_dout;
    memw();
    (*g_phyFuns->i2c_writeReg_Mask_)('h','\x03','\x01','\x05','\x05','\0');
    uVar2 = uVar2 + 0x38 & 0xff;
    (*g_phyFuns->i2c_writeReg_Mask_)('j','\x02','\x04','\0','\0','\0');
    chip7_sleep_params.filter_dcap_wifi[0] = '\x7f';
    uVar7 = ((uVar2 * 0x2ee) / (uint)wifi_txband - 0x39) / 10;
    uVar9 = ((uVar2 * 0x2ee) / 0x5f - 0x39) / 10;
    uVar5 = ((uVar2 * 0x26c) / (uint)wifi_txband_ht40 - 0x39) / 10;
    uVar3 = ((uVar2 * 0x26c) / 0xc3 - 0x39) / 10;
    uVar2 = ((uVar2 * 400) / 0x1e - 0x39) / 10;
    sVar6 = (short)uVar7;
    sVar8 = (short)uVar9;
    sVar4 = (short)uVar5;
    sVar1 = (short)uVar3;
    sVar10 = (short)uVar2;
    if ((sVar6 < 0x80) && (chip7_sleep_params.filter_dcap_wifi[0] = '\x02', 1 < sVar6)) {
      chip7_sleep_params.filter_dcap_wifi[0] = (uint8)uVar7;
    }
    memw();
    chip7_sleep_params.filter_dcap_wifi[2] = '\x7f';
    if ((sVar4 < 0x80) && (chip7_sleep_params.filter_dcap_wifi[2] = '\x02', 1 < sVar4)) {
      chip7_sleep_params.filter_dcap_wifi[2] = (uint8)uVar5;
    }
    memw();
    chip7_sleep_params.filter_dcap_wifi[1] = '\x7f';
    if ((sVar8 < 0x80) && (chip7_sleep_params.filter_dcap_wifi[1] = '\x0e', 0xd < sVar8)) {
      chip7_sleep_params.filter_dcap_wifi[1] = (uint8)uVar9;
    }
    memw();
    chip7_sleep_params.filter_dcap_wifi[3] = '\x7f';
    if ((sVar1 < 0x80) && (chip7_sleep_params.filter_dcap_wifi[3] = '\x0e', 0xd < sVar1)) {
      chip7_sleep_params.filter_dcap_wifi[3] = (uint8)uVar3;
    }
    memw();
    chip7_sleep_params.filter_dcap_bt[1] = '\x7f';
    if (sVar10 < 0x80) {
      uVar11 = (uint8)uVar2;
      chip7_sleep_params.filter_dcap_bt[0] = '\x02';
      if (1 < sVar10) {
        chip7_sleep_params.filter_dcap_bt[0] = uVar11;
      }
      memw();
      chip7_sleep_params.filter_dcap_bt[1] = '\x02';
      if (1 < sVar10) {
        chip7_sleep_params.filter_dcap_bt[1] = uVar11;
      }
    }
    else {
      chip7_sleep_params.filter_dcap_bt[0] = '\x7f';
      memw();
    }
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x800000;
  }
  bb_bss_cbw40_ana(0);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\a',chip7_sleep_params.filter_dcap_bt[0] + 0xfe);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\b',chip7_sleep_params.filter_dcap_bt[0]);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\x05',chip7_sleep_params.filter_dcap_bt[1] + 0xfe);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\x06',chip7_sleep_params.filter_dcap_bt[1]);
  return;
}



// WARNING: Unknown calling convention

void ram_rfcal_txcap(uint8 tone_freq,uint8 tone_atten,bool print_debug,U8 *indata)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  int iVar4;
  char cVar5;
  byte bVar6;
  S16 SVar7;
  uint8 uVar9;
  char cVar10;
  uint uVar11;
  uint uStack_30;
  int iVar8;
  
  (*g_phyFuns->start_tx_tone_step_)(true,(ushort)tone_freq,tone_atten,false,0,'\0');
  cVar5 = '\x01';
  uStack_30 = 0;
code_r0x0004eacb:
  uVar11 = uStack_30 & 0xff;
  uVar9 = (uint8)uStack_30;
  if (uVar11 == 1) {
    bVar6 = (*g_phyFuns->i2c_readReg_Mask_)('k','\x02','\x02','\x03','\0');
    bVar2 = 0xf;
  }
  else if (uVar11 == 2) {
    bVar6 = (*g_phyFuns->i2c_readReg_Mask_)('k',uVar9,uVar9,'\x06','\x04');
    bVar2 = 7;
  }
  else {
    bVar6 = (*g_phyFuns->i2c_readReg_Mask_)('k','\x02','\x01','\x03','\0');
    bVar2 = 0xf;
  }
  bVar3 = false;
  *indata = bVar6;
  memw();
  cVar10 = '\0';
  iVar4 = 0;
  bVar1 = bVar6;
  do {
    while (bVar6 <= bVar2) {
      if (uVar11 == 1) {
        (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x02','\x03','\0',bVar6);
      }
      else if (uVar11 == 2) {
        (*g_phyFuns->i2c_writeReg_Mask_)('k',uVar9,uVar9,'\x06','\x04',bVar6);
      }
      else {
        (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x01','\x03','\0',bVar6);
      }
      SVar7 = (*g_phyFuns->txtone_linear_pwr_)(false);
      iVar8 = (int)SVar7;
      if (print_debug) {
        phy_printf("%d, %d; ",bVar6,iVar8);
      }
      if (iVar8 <= iVar4) break;
      *indata = bVar6;
      memw();
      iVar4 = iVar8;
      if (cVar10 == '\0') {
        if (bVar6 < bVar1) {
          bVar3 = true;
        }
        bVar6 = bVar6 - 1;
      }
      else {
        bVar6 = bVar6 + 1;
      }
    }
    if ((bVar3) || (cVar10 = cVar10 + '\x01', cVar10 == '\x02')) break;
    bVar6 = bVar1 + 1;
    bVar1 = bVar6;
  } while( true );
  if (print_debug) {
    phy_printf("reg_i=%d, indata=%d\n",uStack_30,*indata);
  }
  if (uVar11 == 1) {
    (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x02','\x03','\0',*indata);
  }
  else {
    if (uVar11 == 2) {
      (*g_phyFuns->i2c_writeReg_Mask_)('k',uVar9,uVar9,'\x06','\x04',*indata);
LAB_0004ec68:
      (*g_phyFuns->stop_tx_tone_)(1);
      return;
    }
    (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x01','\x03','\0',*indata);
    if (cVar5 == '\x03') goto LAB_0004ec68;
  }
  indata = indata + 1;
  cVar5 = cVar5 + '\x01';
  uStack_30 = uStack_30 + 1;
  goto code_r0x0004eacb;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void tx_cap_init(void)

{
  char cVar1;
  S16 SVar2;
  char cVar3;
  uint8 *puVar4;
  uint uVar5;
  uint uVar6;
  int8 *piVar7;
  int iVar8;
  int8 channel;
  uint uVar9;
  
  if ((chip7_sleep_params.param_flag & 0x40000) != 0) {
    return;
  }
  txcal_debuge_mode(false);
  (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x01','\x03','\0','\x0f');
  (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x02','\x03','\0','\a');
  (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\x02','\x06','\x04','\x03');
  uVar5 = 0x50;
  uVar6 = 1;
  channel = '\x01';
  puVar4 = chip7_sleep_params.para_txcap;
  do {
    set_channel_rfpll_freq(channel,chip7_phy_init_ctrl.crystal_select,0);
    if (uVar6 == 1) {
      cVar3 = '\x04';
      while( true ) {
        (*g_phyFuns->start_tx_tone_step_)(true,0x80,(uint8)uVar5,false,0,'\0');
        ets_delay_us(2);
        SVar2 = (*g_phyFuns->get_power_db_)(pwrdet_offset);
        uVar9 = (uint)(int)SVar2 >> 2 & 0xffff;
        iVar8 = uVar9 - 0x28;
        cVar1 = (char)iVar8;
        iVar8 = (int)(short)iVar8;
        if ((uVar9 - 0x25 & 0xffff) < 7) break;
        if (iVar8 < 1) {
          iVar8 = iVar8 * 3;
          if (iVar8 < 0) {
            iVar8 = iVar8 + 3;
          }
          cVar1 = (char)(iVar8 >> 2);
        }
        iVar8 = (int)(char)((uint8)uVar5 + cVar1);
        iVar8 = (uint)(iVar8 < 0x78) * iVar8 + (uint)(iVar8 >= 0x78) * 0x78;
        cVar3 = cVar3 + -1;
        uVar5 = (uint)(-1 < iVar8) * iVar8;
        if (cVar3 == '\0') {
          uVar5 = uVar5 & 0xff;
          break;
        }
        uVar5 = uVar5 & 0xff;
      }
      rfcal_bb_atten_init = (uint8)uVar5 + 0xf8;
      memw();
      (*g_phyFuns->rfcal_txcap_)(0x80,(uint8)uVar5,false,puVar4);
    }
    else {
      (*g_phyFuns->rfcal_txcap_)(0x80,(uint8)uVar5,false,puVar4);
      if (uVar6 == 3) {
        chip7_sleep_params.para_txcap[0xb] = chip7_sleep_params.para_txcap[8];
        chip7_sleep_params.para_txcap[9] = chip7_sleep_params.para_txcap[6];
        chip7_sleep_params.para_txcap[10] = chip7_sleep_params.para_txcap[7];
        memw();
        (*g_phyFuns->txcal_work_mode_)();
        chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x40000;
        return;
      }
    }
    piVar7 = (int8 *)((int)&CSWTCH_283 + uVar6);
    puVar4 = puVar4 + 3;
    uVar6 = uVar6 + 1 & 0xff;
    channel = *piVar7;
  } while( true );
}



// WARNING: Unknown calling convention

S16 ram_meas_tone_pwr_db(S8 tone_atten)

{
  S16 SVar1;
  int iVar2;
  int iVar3;
  
  (*g_phyFuns->start_tx_tone_step_)(true,0x80,tone_atten,false,0,'\0');
  iVar3 = 0;
  iVar2 = 4;
  do {
    iVar2 = iVar2 + -1;
    SVar1 = (*g_phyFuns->get_power_db_)(pwrdet_offset);
    iVar3 = (int)(short)(SVar1 + (short)iVar3);
  } while (iVar2 != 0);
  (*g_phyFuns->stop_tx_tone_)(1);
  iVar2 = iVar3 + 4;
  if (iVar3 + 4 < 0) {
    iVar2 = iVar3 + 0xb;
  }
  return (S16)(iVar2 >> 3);
}



// WARNING: Unknown calling convention

void ram_rfcal_pwrctrl(U8 tone_freq,U8 *rate_power,U8 pwctrl_num,U8 pwctrl_tone_offset,
                      S8 *rate_atten,uint16 pwdetect_offset,S8 atten_init,bool print_debug)

{
  byte bVar1;
  uint8 uVar2;
  S16 SVar3;
  S16 SVar4;
  int iVar5;
  uint uVar6;
  char *pcVar7;
  char cVar8;
  uint8 uVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  short sVar14;
  uint uVar15;
  bool bVar16;
  int iStack_4c;
  S8 rate_i;
  
  uVar10 = pwctrl_num - 1;
  iStack_4c = (int)(char)uVar10;
  if (-1 < iStack_4c) {
    iVar12 = 0;
    _rate_i = uVar10;
    do {
      _rate_i = _rate_i & 0xff;
      bVar1 = rate_power[iStack_4c];
      if (iStack_4c < (int)uVar10) {
        iVar12 = (int)(short)(((ushort)(rate_power + iStack_4c)[1] - (ushort)bVar1) + (short)iVar12)
        ;
      }
      iVar13 = 0;
      uVar15 = 2;
      do {
        cVar8 = atten_init + (char)iVar12;
        cVar8 = (-1 < cVar8) * cVar8;
        uVar9 = (cVar8 < 'd') * cVar8 + (cVar8 >= 'd') * 'd';
        iVar11 = (int)(char)uVar9;
        (*g_phyFuns->start_tx_tone_step_)(true,(ushort)tone_freq,uVar9,false,0,'\0');
        ets_delay_us(2);
        SVar3 = (*g_phyFuns->get_power_db_)(pwdetect_offset);
        SVar4 = (*g_phyFuns->get_power_db_)(pwdetect_offset);
        iVar5 = (short)(SVar3 + SVar4) + 4 >> 3;
        if (iVar5 < 0) {
          sVar14 = 0;
          iVar5 = 0;
        }
        else {
          sVar14 = (short)iVar5;
          iVar5 = (int)sVar14;
        }
        uVar6 = (uint)(short)(sVar14 - (ushort)bVar1);
        uVar2 = uVar9;
        if ((int)uVar6 < 0x19) {
          if ((int)uVar6 < -0x18) {
            uVar6 = 0xffffffe8;
            goto LAB_0004f0ce;
          }
          if (print_debug) goto LAB_0004efcc;
LAB_0004efeb:
          if ((uVar6 == 0) && ((((int)(char)iVar13 >> 7) - iVar13 & 0x80U) != 0)) break;
        }
        else {
          uVar6 = 0x18;
LAB_0004f0ce:
          if (print_debug) {
LAB_0004efcc:
            phy_printf("i=%02d  acc=%03d  tgt=%03d  err=%03d  ser=%03d att=%03d\n",iVar13,iVar5,
                       bVar1,uVar6,iVar12,iVar11);
            goto LAB_0004efeb;
          }
        }
        bVar16 = uVar6 == 0xffffffff && uVar15 == 1;
        if (((bVar16) || (bVar16 = uVar15 == 0 || bVar16, bVar16)) ||
           ((iVar11 == 0 || bVar16 && (uVar2 = bVar16, (int)uVar6 < 0)))) break;
        if ((iVar11 == 100) && ((((int)uVar6 >> 0xf) - uVar6 & 0x8000) != 0)) {
          uVar2 = 'd';
          break;
        }
        sVar14 = (short)uVar6 + (short)iVar12;
        if (4 < ((uVar6 & 0xffff) + 2 & 0xffff)) {
          sVar14 = sVar14 - (short)((int)uVar6 >> 2);
        }
        iVar13 = iVar13 + 1;
        iVar12 = (int)sVar14;
        uVar15 = uVar6;
        uVar2 = uVar9;
      } while (iVar13 != 10);
      _rate_i = _rate_i - 1;
      cVar8 = uVar2 - pwctrl_tone_offset;
      pcVar7 = rate_atten + iStack_4c;
      iStack_4c = (int)(char)_rate_i;
      *pcVar7 = (cVar8 < -0x18) * -0x18 + (cVar8 >= -0x18) * cVar8;
    } while (iStack_4c != -1);
  }
  if (0x32 < (int)rate_atten[pwctrl_num - 1] - (int)*rate_atten) {
    *rate_atten = rate_atten[pwctrl_num - 1] + -0x32;
    memw();
  }
  (*g_phyFuns->stop_tx_tone_)(1);
  return;
}



// WARNING: Unknown calling convention

S16 ram_tx_pwr_backoff(U8 *target_pwr,bool *linear_flag)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  S16 SVar4;
  uint uVar5;
  uint uVar6;
  short sVar7;
  int iVar8;
  char cVar9;
  char tone_atten;
  uint uVar10;
  int iVar11;
  short sVar12;
  u8 target_power_low;
  S8 bb_atten_low;
  S16 target_pwr_edb;
  int iStack_3c;
  byte *pbStack_38;
  bool *pbStack_34;
  int iStack_30;
  uint uStack_2c;
  int iStack_28;
  uint uStack_24;
  
  bVar1 = *target_pwr;
  uVar5 = (uint)bVar1;
  iStack_3c = uVar5 << 1;
  _target_pwr_edb = (int)(short)iStack_3c;
  if (uVar5 < 0x4d) {
    target_power_low = bVar1 - 0x1a;
    memw();
  }
  else {
    target_power_low = '2';
    memw();
  }
  bVar2 = uVar5 >= 0x4d;
  pbStack_38 = target_pwr;
  pbStack_34 = linear_flag;
  ram_rfcal_pwrctrl(0x80,&target_power_low,'\x01','+',&bb_atten_low,pwrdet_offset,
                    rfcal_bb_atten_init,false);
  cVar9 = '\0';
  uStack_24 = 0;
  sVar7 = 0;
  uVar5 = (byte)bb_atten_low + 0x2b;
  uVar6 = uVar5 & 0xff;
  uVar10 = (byte)bb_atten_low + 0x11;
  rfcal_bb_atten_init = (S8)uVar5;
  memw();
  bb_atten_low = rfcal_bb_atten_init;
  do {
    iVar11 = (int)(char)uVar10;
    uVar5 = (iVar11 < (int)uStack_24) * uStack_24 + (uint)(iVar11 >= (int)uStack_24) * iVar11;
    uStack_2c = uVar5 & 0xff;
    if ('{' < (char)uVar6) {
      bb_atten_low = '{';
    }
    tone_atten = (char)uVar5;
    iStack_28 = (int)tone_atten;
    SVar4 = ram_meas_tone_pwr_db(tone_atten);
    iStack_30 = (int)SVar4;
    SVar4 = ram_meas_tone_pwr_db(bb_atten_low);
    uVar5 = uStack_24;
    if (cVar9 == '\0') {
      uVar5 = 1;
    }
    sVar12 = (short)iStack_30 - SVar4;
    if ((((_target_pwr_edb <= iStack_30) || ((uVar5 & 0xff) == 0)) || (sVar12 < 0x2d)) || (bVar2)) {
      if (!bVar2) goto LAB_0004f1e8;
      bVar2 = false;
      bVar3 = bVar2;
      if (0x2b < sVar12) goto LAB_0004f1d4;
    }
    else {
LAB_0004f1d4:
      if ((sVar12 < 0x2d) && (_target_pwr_edb <= iStack_30)) {
LAB_0004f1e8:
        if ((0x2c < sVar12) || (bVar2 = sVar12 <= sVar7 && 0x2b < sVar12, bVar3 = bVar2, bVar2)) {
LAB_0004f1ed:
          *pbStack_34 = 0x30 < sVar12;
          memw();
          if ((int)((uint)*pbStack_38 * 2) <= iStack_30) {
            return 0;
          }
          return (S16)((int)(((uint)*pbStack_38 * 2 - iStack_30) + 1) >> 1);
        }
      }
      else {
        bVar2 = true;
        bVar3 = _target_pwr_edb <= iStack_30;
      }
    }
    if ((SVar4 < 0x51) || (((bVar3 || (bb_atten_low == '{')) || (iStack_28 == 0))))
    goto LAB_0004f1ed;
    if (bVar2) {
      if ((sVar12 < 0x31) || ((uVar5 & 0xff) == 0)) {
        iVar8 = -8;
        iVar11 = iStack_30 - iStack_3c;
        uVar5 = 0xfc;
      }
      else {
        iVar11 = iStack_30 - iStack_3c;
        uVar6 = iVar11 / 2 - 1;
        uVar5 = uVar6 & 0xff;
        iVar8 = (int)(char)uVar6 << 1;
      }
      if (iVar8 < iVar11) {
        uVar5 = (uint)((iVar11 + -1) - (iVar11 + -1 >> 0x1f)) >> 1 & 0xff;
      }
      uVar10 = uStack_2c + uVar5 & 0xff;
      bb_atten_low = (char)(uStack_2c + uVar5) + '\x1a';
      memw();
      sVar7 = 0;
    }
    else {
      uVar10 = (uStack_2c & 0xff) + 2;
      bb_atten_low = (char)uStack_2c + '\x1c';
      memw();
      sVar7 = sVar12;
    }
    cVar9 = cVar9 + '\x01';
    if (cVar9 == '\n') goto LAB_0004f1ed;
    uVar6 = (uint)(byte)bb_atten_low;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void cal_rf_ana_gain(void)

{
  byte bVar1;
  sint16 correct_qdb;
  S8 bb_atten;
  
  (*g_phyFuns->pbus_force_test_)('\x05','\x01',tx_rf_ana_gain[0]);
  (*g_phyFuns->pbus_force_test_)('\x01','\x02',tx_rf_ana_gain[1]);
  bVar1 = (*g_phyFuns->txbbgain_to_index_)(tx_rf_ana_gain[1]);
  (*g_phyFuns->pbus_set_dco_)((U16 *)((uint)bVar1 * 8 + 0x5bbc4));
  ram_rfcal_pwrctrl(0x80,chip7_sleep_params.phy_pwctrl_target_power + 5,'\x01','+',&bb_atten,
                    pwrdet_offset,rfcal_bb_atten_init,false);
  if (0x10 < (byte)(bb_atten - 0xcU)) {
    correct_qdb = 0x14 - bb_atten;
    memw();
    correct_rf_ana_gain_new(&correct_qdb,tx_rf_ana_gain,tx_rf_ana_gain + 1,false);
    (*g_phyFuns->pbus_force_test_)('\x05','\x01',tx_rf_ana_gain[0]);
    (*g_phyFuns->pbus_force_test_)('\x01','\x02',tx_rf_ana_gain[1]);
    rfcal_bb_atten_init = 'E' - (char)correct_qdb;
    memw();
    return;
  }
  rfcal_bb_atten_init = bb_atten + '1';
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

S16 tx_pwctrl_init_cal(U8 chan_num,u8 backoff_en)

{
  S16 SVar1;
  S16 SVar2;
  uint uVar3;
  char cVar4;
  uint uVar5;
  sint16 sVar6;
  U8 target_power [6];
  bool linear_flag;
  uint uStack_30;
  uint uStack_2c;
  int iStack_28;
  int iStack_24;
  
  set_channel_rfpll_freq(chan_num,chip7_phy_init_ctrl.crystal_select,0);
  (*g_phyFuns->set_txcap_reg_)((U8 *)0x5bbf8,chan_num);
  if (chan_num != '\x06') {
    if (backoff_en == '\x01') goto LAB_0004f473;
    goto LAB_0004f4c9;
  }
  cal_rf_ana_gain();
  if (backoff_en == '\x01') {
LAB_0004f473:
    SVar1 = ram_tx_pwr_backoff(chip7_sleep_params.phy_pwctrl_target_power,&linear_flag);
    if ((SVar1 == 0) && (linear_flag == true)) {
LAB_0004f4c9:
      uStack_30 = 0;
      sVar6 = 0;
    }
    else {
      SVar2 = ram_tx_pwr_backoff(chip7_sleep_params.phy_pwctrl_target_power,&linear_flag);
      if ((SVar2 == 0) && (linear_flag == true)) goto LAB_0004f4c9;
      uVar3 = ((short)(SVar1 + SVar2) + 1) / 2;
      uStack_30 = uVar3 & 0xff;
      sVar6 = (sint16)uVar3;
    }
    cVar4 = (char)uStack_30;
    uVar3 = (uint)(byte)(chan_num - 1);
    (*g_phyFuns->target_power_add_backoff_)(target_power,(U8 *)0x5bc12,sVar6);
    if (10 < uVar3) {
      uStack_2c = 0xffffff;
      iStack_24 = 0x17;
      iStack_28 = 0x12;
      uVar3 = 0x18;
      uVar5 = 3;
      goto LAB_0004f51c;
    }
  }
  else {
    uVar3 = 5;
    cVar4 = '\0';
    (*g_phyFuns->target_power_add_backoff_)(target_power,(U8 *)0x5bc12,0);
    sVar6 = 0;
    uStack_30 = 0;
  }
  uVar5 = (uint)(byte)CSWTCH_289[uVar3];
  uVar3 = uVar5 << 3;
  iStack_28 = uVar5 * 6;
  uStack_2c = 0xff << 0x20 - (0x20 - (uVar3 & 0x1f)) ^ 0xffffffff;
  iStack_24 = iStack_28 + 5;
LAB_0004f51c:
  chip7_sleep_params.target_power_chan_backoff[uVar5] = sVar6;
  uVar5 = esp_dport_access_reg_read(&DAT_3ff460f8);
  _DAT_3ff460f8 = uVar5 & uStack_2c | uStack_30 << 0x20 - (0x20 - (uVar3 & 0x1f));
  memw();
  rfcal_bb_atten_init = cVar4 + rfcal_bb_atten_init;
  memw();
  ram_rfcal_pwrctrl(0x80,target_power,'\x06','+',chip7_sleep_params.tx_pwctrl_atten + iStack_28,
                    pwrdet_offset,rfcal_bb_atten_init,false);
  rfcal_bb_atten_init = chip7_sleep_params.tx_pwctrl_atten[iStack_24] + '+';
  memw();
  return sVar6;
}



// WARNING: Unknown calling convention

void tx_pwctrl_init(u8 backoff_en)

{
  if ((chip7_sleep_params.param_flag & 0x100000) == 0) {
    txcal_debuge_mode(false);
    tx_pwctrl_init_cal('\x06',backoff_en);
    tx_pwctrl_init_cal('\x01',backoff_en);
    tx_pwctrl_init_cal('\v',backoff_en);
    chip7_sleep_params.target_power_chan_backoff[3] =
         chip7_sleep_params.target_power_chan_backoff[2];
    memw();
    chip7_sleep_params.tx_pwctrl_atten[0x12] = chip7_sleep_params.tx_pwctrl_atten[0xc];
    memw();
    (*g_phyFuns->txcal_work_mode_)();
    chip7_sleep_params.loop_tx_rf_ana_gain[1] = tx_rf_ana_gain[1];
    chip7_sleep_params.loop_tx_rf_ana_gain[0] = tx_rf_ana_gain[0];
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x100000;
    chip7_sleep_params.phy_channel_num = '\x0e';
    memw();
    return;
  }
  tx_rf_ana_gain[0] = chip7_sleep_params.loop_tx_rf_ana_gain[0];
  tx_rf_ana_gain[1] = chip7_sleep_params.loop_tx_rf_ana_gain[1];
  memw();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_tx_pwctrl_init(void)

{
  bool bVar1;
  phy_romfuncs *ppVar2;
  u16 uVar3;
  sleep_param_t *psVar4;
  uint8 *puVar5;
  uint8 channel;
  _func_void_u8_u8_u16 *p_Var6;
  sint16 correct_qdb;
  uint16 bbgain;
  uint8 target_power;
  sint8 bb_atten;
  sleep_param_t *psStack_30;
  
  if ((chip7_sleep_params.param_flag & 0x8000) == 0) {
    psVar4 = &chip7_sleep_params;
    channel = '\a';
    puVar5 = "\a\x01\x03\v";
    while( true ) {
      target_power = '.';
      memw();
      set_channel_rfpll_freq(channel,chip7_phy_init_ctrl.crystal_select,0);
      (*g_phyFuns->set_txcap_reg_)(chip7_sleep_params.para_txcap,channel);
      if (channel == '\a') {
        bVar1 = false;
        psStack_30 = psVar4;
        while( true ) {
          bbgain = bt_index_to_bb(1);
          memw();
          txcal_debuge_mode(true);
          (*g_phyFuns->pbus_force_test_)('\x05','\x01',bt_tx_pa_gain);
          (*g_phyFuns->pbus_force_test_)('\x01','\x02',bbgain);
          p_Var6 = g_phyFuns->pbus_force_test_;
          uVar3 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
          (*p_Var6)('\x01','\x01',uVar3 | 2);
          (*g_phyFuns->pbus_set_dco_)(chip7_sleep_params.bt_txdc_table + 4);
          ram_rfcal_pwrctrl(' ',&target_power,'\x01','\v',&bb_atten,pwrdet_offset,'#',false);
          psVar4 = psStack_30;
          if ((bVar1) || ((byte)(bb_atten - 0x10U) < 9)) break;
          memw();
          correct_qdb = 0x14 - bb_atten;
          correct_rf_ana_gain_new(&correct_qdb,&bt_tx_pa_gain,&bbgain,true);
          bVar1 = true;
        }
        chip7_sleep_params.bt_bb_gain = bbgain;
        chip7_sleep_params.bt_txpwr_atten = bb_atten;
        memw();
        (*g_phyFuns->txcal_work_mode_)();
      }
      else {
        bbgain = bt_index_to_bb(1);
        memw();
        txcal_debuge_mode(true);
        (*g_phyFuns->pbus_force_test_)('\x05','\x01',bt_tx_pa_gain);
        (*g_phyFuns->pbus_force_test_)('\x01','\x02',bbgain);
        p_Var6 = g_phyFuns->pbus_force_test_;
        uVar3 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
        (*p_Var6)('\x01','\x01',uVar3 | 2);
        (*g_phyFuns->pbus_set_dco_)(chip7_sleep_params.bt_txdc_table + 4);
        ram_rfcal_pwrctrl(' ',&target_power,'\x01','\v',&bb_atten,pwrdet_offset,'\x19',false);
        ppVar2 = g_phyFuns;
        psVar4->delta_bt_atten[0] = bb_atten - chip7_sleep_params.bt_txpwr_atten;
        memw();
        (*ppVar2->txcal_work_mode_)();
      }
      psVar4 = (sleep_param_t *)((int)&psVar4->param_flag + 1);
      puVar5 = puVar5 + 1;
      if (psVar4 == (sleep_param_t *)chip7_sleep_params.target_power_chan_backoff) break;
      channel = *puVar5;
    }
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x8000;
    chip7_sleep_params.delta_bt_atten[4] = chip7_sleep_params.delta_bt_atten[3];
    memw();
  }
  return;
}



// WARNING: Unknown calling convention

S8 set_bt_chan_cal_interp(uint8 chan)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  sint8 sVar4;
  int iVar5;
  
  uVar2 = (uint)chan;
  if (uVar2 < 0xb) {
    return chip7_sleep_params.delta_bt_atten[1];
  }
  if (uVar2 < 0x15) {
    iVar3 = ((int)chip7_sleep_params.delta_bt_atten[2] - (int)chip7_sleep_params.delta_bt_atten[1])
            * (uVar2 - 10);
    iVar5 = 0x66666667;
    cVar1 = chip7_sleep_params.delta_bt_atten[1];
LAB_0004f963:
    return ((char)(int)((longlong)iVar3 * (longlong)iVar5 >> 0x22) - (char)(iVar3 >> 0x1f)) + cVar1;
  }
  if (uVar2 < 0x29) {
    iVar3 = uVar2 - 0x14;
    sVar4 = chip7_sleep_params.delta_bt_atten[0];
    cVar1 = chip7_sleep_params.delta_bt_atten[2];
  }
  else {
    if (0x3c < uVar2) {
      if (0x4e < uVar2) {
        return chip7_sleep_params.delta_bt_atten[4];
      }
      iVar3 = ((int)chip7_sleep_params.delta_bt_atten[4] - (int)chip7_sleep_params.delta_bt_atten[3]
              ) * (uVar2 - 0x3c);
      iVar5 = 0x38e38e39;
      cVar1 = chip7_sleep_params.delta_bt_atten[3];
      goto LAB_0004f963;
    }
    iVar3 = uVar2 - 0x28;
    sVar4 = chip7_sleep_params.delta_bt_atten[3];
    cVar1 = chip7_sleep_params.delta_bt_atten[0];
  }
  return (char)((((int)sVar4 - (int)cVar1) * iVar3) / 0x14) + cVar1;
}



// WARNING: Unknown calling convention

S8 phy_set_bt_dig_gain(uint8 chan)

{
  S8 SVar1;
  sint8 dig_atten [8];
  
  SVar1 = set_bt_chan_cal_interp(chan);
  dig_atten[0] = SVar1 + chip7_sleep_params.bt_dig_atten[0];
  memw();
  wr_bt_tx_atten(dig_atten);
  return '\0';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

U16 ram_phy_get_vdd33(void)

{
  uint uVar1;
  U16 e [8];
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = uVar1 & 0xffffff1f | 0x80;
  memw();
  _DAT_3ff460c0 = esp_dport_access_reg_read(&DAT_3ff460c0);
  _DAT_3ff460c0 = _DAT_3ff460c0 | 0x80;
  memw();
  set_xpd_sar(true);
  _DAT_3ff48890 = esp_dport_access_reg_read(&DAT_3ff48890);
  _DAT_3ff48890 = _DAT_3ff48890 | 0x8000000;
  memw();
  (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\t','\a','\a','\x01');
  _DAT_3ff4882c = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = _DAT_3ff4882c | 0x10;
  memw();
  _DAT_3ff48838 = esp_dport_access_reg_read(&DAT_3ff48838);
  _DAT_3ff48838 = _DAT_3ff48838 & 0x3fffffff;
  memw();
  _DAT_3ff4e05c = esp_dport_access_reg_read(&DAT_3ff4e05c);
  _DAT_3ff4e05c = _DAT_3ff4e05c | 0x800000;
  memw();
  _DAT_3ff4e05c = esp_dport_access_reg_read(&DAT_3ff4e05c);
  _DAT_3ff4e05c = _DAT_3ff4e05c & 0xffdfffff;
  memw();
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4e050);
  } while ((uVar1 >> 0x18 & 7) != 0);
  _DAT_3ff4e050 = esp_dport_access_reg_read(&DAT_3ff4e050);
  _DAT_3ff4e050 = _DAT_3ff4e050 & 0xfffffffd;
  memw();
  _DAT_3ff4e050 = esp_dport_access_reg_read(&DAT_3ff4e050);
  _DAT_3ff4e050 = _DAT_3ff4e050 | 2;
  memw();
  ets_delay_us(10);
  do {
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4e050);
  } while ((uVar1 >> 0x18 & 7) != 0);
  (*g_phyFuns->read_sar_dout_)(e);
  (*g_phyFuns->i2c_writeReg_Mask_)('k','\x02','\t','\a','\a','\0');
  _DAT_3ff4882c = esp_dport_access_reg_read(&DAT_3ff4882c);
  _DAT_3ff4882c = _DAT_3ff4882c & 0xffffffef;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e05c);
  memw();
  _DAT_3ff4e05c = uVar1 & 0xff7fffff;
  return (U16)(e[0] + 4 >> 3);
}



// WARNING: Unknown calling convention

void txpwr_offset(S16 m_offset)

{
  byte bVar1;
  U16 UVar2;
  S16 SVar3;
  S16 SVar4;
  uint uVar6;
  uint uVar5;
  
  if ((chip7_sleep_params.param_flag & 0x400000) == 0) {
    UVar2 = (*g_phyFuns->phy_get_vdd33_)();
    uVar5 = (uint)UVar2;
    uVar6 = 0;
    if (uVar5 < 0xd33) {
      SVar3 = (*g_phyFuns->linear_to_db_)(uVar5,'\x03');
      SVar4 = (*g_phyFuns->linear_to_db_)(0xd33,'\x03');
      uVar6 = ((int)(char)(((char)SVar3 - (char)SVar4) * '\x02') + 2U >> 2 & 0xff) << 8;
    }
    bVar1 = temprature_sens_read();
    chip7_sleep_params.phy_pwctrl_target_power[0] = chip7_phy_init_ctrl.target_power_init[0];
    memw();
    chip7_sleep_params.vdd33_code = uVar5 << 0x10 | (uint)bVar1 | uVar6;
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x400000;
  }
  return;
}



// WARNING: Unknown calling convention

sint16 phy_get_bb_freqoffset(void)

{
  short sVar1;
  ushort uVar2;
  uint uVar3;
  
  uVar3 = esp_dport_access_reg_read(0x600330a8);
  if ((uVar3 >> 0x10 & 0xf) < 8) {
    sVar1 = esp_dport_access_reg_read(0x3ff5c83c);
    return sVar1 / 0x30;
  }
  uVar2 = esp_dport_access_reg_read(0x3ff5cc88);
  uVar3 = (uint)(short)(uVar2 & 0x7fff);
  if (0x3fff < uVar3) {
    uVar3 = (uint)(short)((uVar2 & 0x7fff) + 0x8000);
  }
  return (sint16)((int)uVar3 / 0x1a);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_pwdet_always_en(bool always_en)

{
  uint uVar1;
  
  if (!always_en) {
    phy_dis_pwdet_one = true;
    memw();
    _DAT_3ff4e050 = esp_dport_access_reg_read(&DAT_3ff4e050);
    _DAT_3ff4e050 = _DAT_3ff4e050 & 0xfffffffe;
    memw();
    ets_delay_us(1);
    do {
      uVar1 = esp_dport_access_reg_read(&DAT_3ff4e050);
    } while ((uVar1 >> 0x18 & 7) != 0);
    return;
  }
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e050);
  memw();
  _DAT_3ff4e050 = uVar1 | 1;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void dpd_scale_set(void)

{
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2c_bbpll_init(void)

{
  (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x02','\a','\a','\x01');
  (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\x02','\0','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\x05','\a','\x06','\x01');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2c_bbpll_init(void)

{
  if (chip7_phy_init_ctrl.crystal_select == '\x01') {
    i2c_bbpll_init();
  }
  return;
}



// WARNING: Unknown calling convention

void bb_bss_cbw40_ana(int cbw40)

{
  uint8 uVar1;
  int iVar2;
  uint8 delta_rx;
  char cVar3;
  int iVar4;
  uint8 delta_tx;
  char cVar5;
  byte bVar6;
  
  iVar2 = 0;
  if (cbw40 != 0) {
    iVar2 = 2;
  }
  cVar5 = '\x02';
  if (cbw40 != 0) {
    cVar5 = '\x01';
  }
  iVar4 = 3;
  if (cbw40 == 0) {
    iVar4 = 1;
  }
  uVar1 = 'q';
  if (cbw40 != 0) {
    uVar1 = '1';
  }
  cVar3 = '\x05';
  if (cbw40 == 0) {
    cVar3 = '\n';
  }
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\x03',chip7_sleep_params.filter_dcap_wifi[iVar2] - cVar5);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\x04',chip7_sleep_params.filter_dcap_wifi[iVar2]);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\n','\x10');
  if (cbw40 == 0) {
    (*g_phyFuns->i2c_writeReg_)
              ('g','\x01','\x01',chip7_sleep_params.filter_dcap_wifi[iVar4] + 10 | 0x80);
    bVar6 = chip7_sleep_params.filter_dcap_wifi[iVar4] + 10;
  }
  else {
    (*g_phyFuns->i2c_writeReg_)
              ('g','\x01','\x01',(chip7_sleep_params.filter_dcap_wifi[iVar4] - cVar3) - 4 | 0x80);
    bVar6 = chip7_sleep_params.filter_dcap_wifi[iVar4] - 4;
  }
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\x02',bVar6 | 0x80);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\t',uVar1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2c_bt_filter_set(void)

{
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\v','a');
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\f','\x10');
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\x0f',0xea);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\a',chip7_sleep_params.filter_dcap_bt[0] + 0xfe);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\b',chip7_sleep_params.filter_dcap_bt[0]);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\x05',chip7_sleep_params.filter_dcap_bt[1] + 0xfe);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\x06',chip7_sleep_params.filter_dcap_bt[1]);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_i2c_init(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  undefined4 uVar4;
  uint8 pData [4];
  uint8 reg_add [4];
  uint8 host_id [4];
  uint8 block [4];
  
  uVar4 = phy_enter_critical();
  bVar1 = (*g_phyFuns->i2c_readReg_)('f','\x04','\n');
  bVar2 = (*g_phyFuns->i2c_readReg_)('f','\x04','\v');
  bVar3 = (*g_phyFuns->i2c_readReg_)('f','\x04','\t');
  block[0] = 'c';
  pData[0] = 0xf3;
  pData[1] = 0xa8;
  host_id[0] = '\0';
  reg_add[0] = '\x01';
  block[1] = 'k';
  reg_add[1] = '\x03';
  block[2] = 'b';
  host_id[2] = '\x01';
  reg_add[2] = '\x03';
  pData[2] = 'w';
  host_id[1] = '\x02';
  memw();
  i2c_write_master(block,host_id,reg_add,pData,'\x03');
  pData[2] = bVar1 & 0xcf | 0x10;
  reg_add[0] = '\b';
  pData[0] = '\0';
  block[2] = 'f';
  memw();
  pData[1] = '\a';
  block[0] = 'b';
  host_id[0] = '\x01';
  block[1] = 'k';
  reg_add[2] = '\n';
  host_id[1] = '\x02';
  reg_add[1] = '\x04';
  host_id[2] = '\x04';
  memw();
  i2c_write_master(block,host_id,reg_add,pData,'\x03');
  pData[2] = bVar2 & 0xfe;
  pData[0] = 0xb0;
  reg_add[1] = '\x05';
  memw();
  pData[1] = '\b';
  block[2] = 'f';
  reg_add[0] = '\n';
  block[0] = 'b';
  host_id[0] = '\x01';
  block[1] = 'k';
  reg_add[2] = '\v';
  host_id[1] = '\x02';
  host_id[2] = '\x04';
  memw();
  i2c_write_master(block,host_id,reg_add,pData,'\x03');
  reg_add[1] = '\x06';
  block[0] = 'b';
  host_id[0] = '\x01';
  pData[0] = '\a';
  block[1] = 'k';
  pData[1] = 0xb8;
  reg_add[0] = '\t';
  host_id[1] = '\x02';
  memw();
  i2c_write_master(block,host_id,reg_add,pData,'\x02');
  reg_add[0] = '\0';
  reg_add[1] = '\a';
  pData[0] = '0';
  pData[1] = ']';
  block[0] = 'b';
  host_id[0] = '\x01';
  block[1] = 'k';
  host_id[1] = '\x02';
  memw();
  i2c_write_master(block,host_id,reg_add,pData,'\x02');
  block[1] = 'k';
  block[0] = 'b';
  pData[1] = 't';
  host_id[0] = '\x01';
  pData[0] = 0xbf;
  reg_add[1] = '\n';
  reg_add[0] = '\x04';
  host_id[1] = '\x02';
  memw();
  i2c_write_master(block,host_id,reg_add,pData,'\x02');
  builtin_memcpy(pData,"qch!",4);
  builtin_memcpy(host_id,"\x01\x03\x02\x04",4);
  reg_add[1] = '\0';
  reg_add[3] = '\b';
  builtin_memcpy(block,"ghjf",4);
  reg_add[0] = '\t';
  reg_add[2] = '\x02';
  memw();
  i2c_write_master(block,host_id,reg_add,pData,'\x04');
  pData[3] = bVar3 & 0xf0 | 4;
  block[0] = 'g';
  memw();
  reg_add[0] = '\v';
  builtin_memcpy(host_id,"\x01\x03\x02\x04",4);
  pData[0] = 'a';
  block[1] = 'h';
  reg_add[1] = '\x01';
  block[2] = 'j';
  pData[1] = 0x80;
  reg_add[2] = '\0';
  pData[2] = dreg_1p2_set;
  block[3] = 'f';
  reg_add[3] = '\t';
  memw();
  i2c_write_master(block,host_id,reg_add,pData,'\x04');
  i2c_bt_filter_set();
  if (chip7_phy_init_ctrl.crystal_select == '\x01') {
    i2c_bbpll_init();
  }
  phy_exit_critical(uVar4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void ram_pbus_force_mode(bool pbus_force_en)

{
  uint uVar1;
  
  if (pbus_force_en) {
    _DAT_3ff4609c = esp_dport_access_reg_read(&DAT_3ff4609c);
    _DAT_3ff4609c = _DAT_3ff4609c & 0xf7ffffff;
    memw();
    uVar1 = esp_dport_access_reg_read(&DAT_3ff46094);
    memw();
    _DAT_3ff46094 = uVar1 | 1;
    return;
  }
  _DAT_3ff46094 = esp_dport_access_reg_read(&DAT_3ff46094);
  _DAT_3ff46094 = _DAT_3ff46094 & 0xfffffffe;
  memw();
  _DAT_3ff4609c = esp_dport_access_reg_read(&DAT_3ff4609c);
  _DAT_3ff4609c = _DAT_3ff4609c & 0xf7ffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff00024);
  if ((uVar1 & 2) != 0) {
    ets_delay_us(1);
    uVar1 = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = uVar1 & 0xffffff | 0x32000000;
    memw();
    _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = _DAT_3ff5c02c | 0x800000;
    memw();
    ets_delay_us(2);
    _DAT_3ff5c02c = esp_dport_access_reg_read(&DAT_3ff5c02c);
    _DAT_3ff5c02c = _DAT_3ff5c02c & 0xff7fffff;
    memw();
  }
  return;
}



// WARNING: Unknown calling convention

void ram_pbus_xpd_tx_on(U16 pa_gain,U16 bbgain)

{
  u16 uVar1;
  _func_void_u8_u8_u16 *p_Var2;
  sint16 dc_comp [4];
  
  dc_comp[0] = 0x100;
  dc_comp[1] = 0x100;
  dc_comp[2] = 0x100;
  dc_comp[3] = 0x100;
  memw();
  (*g_phyFuns->pbus_force_test_)('\0','\x01',1);
  (*g_phyFuns->pbus_force_test_)('\x01','\x01',0x7c);
  (*g_phyFuns->pbus_set_dco_)((U16 *)dc_comp);
  (*g_phyFuns->pbus_force_test_)('\x01','\x02',bbgain);
  if ((pa_gain & 0x100) != 0) {
    p_Var2 = g_phyFuns->pbus_force_test_;
    uVar1 = (*g_phyFuns->pbus_rd_)('\x01','\x01');
    (*p_Var2)('\x01','\x01',uVar1 | 2);
  }
  (*g_phyFuns->pbus_force_test_)('\x04','\x01',0x7f);
  (*g_phyFuns->pbus_force_test_)('\x05','\x01',pa_gain);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2c_xtal_init(void)

{
  (*g_phyFuns->i2c_writeReg_)('h','\x03','\0','c');
  (*g_phyFuns->i2c_writeReg_)('h','\x03','\x01',0x80);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2c_rfpll_init(void)

{
  (*g_phyFuns->i2c_writeReg_)('c','\0','\x01',0xf3);
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x03','\x02','\x01','\x03');
  (*g_phyFuns->i2c_writeReg_)('b','\x01','\b','\0');
  (*g_phyFuns->i2c_writeReg_)('b','\x01','\n',0xb0);
  (*g_phyFuns->i2c_writeReg_)('b','\x01','\t','\a');
  (*g_phyFuns->i2c_writeReg_)('b','\x01','\0','?');
  (*g_phyFuns->i2c_writeReg_)('b','\x01','\x04',0xbf);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_rfpll_reset(void)

{
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_restart_cal(void)

{
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\x06','\x06','\x01');
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\x05','\x05','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\x05','\x05','\x01');
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\x06','\x06','\0');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ram_wait_rfpll_cal_end(void)

{
  bool bVar1;
  char cVar2;
  uint8 uVar3;
  
  cVar2 = 'd';
  do {
    ets_delay_us(0x14);
    uVar3 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\a','\a','\a');
    if (uVar3 != '\0') {
      return;
    }
    bVar1 = cVar2 != '\x01';
    cVar2 = cVar2 + -1;
  } while (bVar1);
  phy_printf("error: pll_cal exceeds 2ms!!!\n");
  return;
}



// WARNING: Unknown calling convention

void ram_rfpll_set_freq(uint32 freq,uint8 crystal_select,sint16 freq_offset,uint8 *x_reg)

{
  ulonglong uVar1;
  bool bVar2;
  undefined4 uVar3;
  uint uVar4;
  float fVar5;
  undefined8 uVar6;
  
  uVar6 = __floatunsidf((freq * 0x400 + (int)freq_offset) * 4);
  uVar4 = crystal_select - 1 & 0xff;
  __divdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),0,0x40080000);
  uVar3 = __truncdfsf2();
  fVar5 = 40960.0;
  if (uVar4 < 4) {
    fVar5 = *(float *)(CSWTCH_169 + uVar4 * 4) * 1024.0;
  }
  fVar5 = (float)__divsf3(uVar3,fVar5);
  fVar5 = fVar5 - 32.0;
  uVar1 = (ulonglong)(fVar5 * 1.0);
  bVar2 = uVar1 >> 0x10 != 0;
  uVar4 = (uint)((!NAN(fVar5) && !bVar2) && -1 < (longlong)uVar1) * (int)uVar1 -
          (uint)(NAN(fVar5) || bVar2);
  *x_reg = (uint8)uVar4;
  fVar5 = (fVar5 - (float)(uVar4 & 0xff) / 1.0) * 256.0;
  uVar1 = (ulonglong)(fVar5 * 1.0);
  bVar2 = uVar1 >> 0x10 != 0;
  uVar4 = (uint)((!NAN(fVar5) && !bVar2) && -1 < (longlong)uVar1) * (int)uVar1 -
          (uint)(NAN(fVar5) || bVar2);
  x_reg[1] = (uint8)uVar4;
  fVar5 = (fVar5 - (float)(uVar4 & 0xff) / 1.0) * 256.0;
  uVar1 = (ulonglong)(fVar5 * 1.0);
  bVar2 = uVar1 >> 0x10 != 0;
  x_reg[2] = ((!NAN(fVar5) && !bVar2) && -1 < (longlong)uVar1) * (char)uVar1 - (NAN(fVar5) || bVar2)
  ;
  memw();
  return;
}



// WARNING: Unknown calling convention

void get_lna_vga_dcap_val(uint16 pll_cap,sint16 *rfrx_cap)

{
  s32 sVar1;
  _func_s32_s32_s32_s32 *p_Var2;
  
  sVar1 = (*g_phyFuns->get_data_sat_)((int)((uint)pll_cap * 0x18 + -0x154) / 0xe3,0xf,0);
  p_Var2 = g_phyFuns->get_data_sat_;
  *rfrx_cap = (sint16)sVar1;
  memw();
  sVar1 = (*p_Var2)(((uint)pll_cap * 0x17 + 0x1d) / 0xcf,0xf,0);
  rfrx_cap[1] = (sint16)sVar1;
  memw();
  return;
}



// WARNING: Unknown calling convention

void chip_v7_rxmax_ext_ana(uint8 ext_level)

{
  byte bVar1;
  char cVar2;
  short sVar3;
  sint16 rfrx_dcap [2];
  
  bVar1 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\x05','\a','\0');
  get_lna_vga_dcap_val((ushort)bVar1,rfrx_dcap);
  if (ext_level < 3) {
    (*g_phyFuns->i2c_writeReg_)('d','\0','\x04',(byte)rfrx_dcap[0] | 0x40);
    if (ext_level != '\x02') goto LAB_000506dd;
  }
  else {
    cVar2 = '\b';
    if (7 < rfrx_dcap[0]) {
      cVar2 = -8;
    }
    (*g_phyFuns->i2c_writeReg_)('d','\0','\x04',cVar2 + (byte)rfrx_dcap[0] | 0x40);
  }
  sVar3 = 8;
  if (7 < rfrx_dcap[1]) {
    sVar3 = -8;
  }
  rfrx_dcap[1] = sVar3 + rfrx_dcap[1];
LAB_000506dd:
  (*g_phyFuns->i2c_writeReg_)('d','\0','\a',(byte)rfrx_dcap[1] | 0x40);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_freq_correct_opt(void)

{
  uint uVar1;
  
  (*g_phyFuns->phy_freq_correct_)(true,phy_freq_offset);
  _DAT_3ff5c400 = esp_dport_access_reg_read(&DAT_3ff5c400);
  _DAT_3ff5c400 = _DAT_3ff5c400 & 0xfff8ffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e054);
  memw();
  _DAT_3ff4e054 = uVar1 & 0xffffff00 | 200;
  return;
}



// WARNING: Unknown calling convention

void chip_v7_adc_wr_dly(uint8 dly1,uint8 dly2,uint8 dly3,uint8 dly4,uint8 dly5,uint8 dly6)

{
  (*g_phyFuns->i2c_writeReg_)('f','\x04','\b',dly2 << 2 | dly1 | dly3 << 4 | dly4 << 6);
  (*g_phyFuns->i2c_writeReg_Mask_)('f','\x04','\t','\x03','\0',(byte)((dly6 & 0x3f) << 2) | dly5);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2c_bbtop_init(void)

{
  (*g_phyFuns->i2c_writeReg_)('f','\x04','\b','!');
  (*g_phyFuns->i2c_writeReg_)('f','\x04','\t',0x84);
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\t','q');
  (*g_phyFuns->i2c_writeReg_)('g','\x01','\v','a');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2c_rftx_init(void)

{
  (*g_phyFuns->i2c_writeReg_)('k','\x02','\x03',0x88);
  (*g_phyFuns->i2c_writeReg_)('k','\x02','\x04','\x06');
  (*g_phyFuns->i2c_writeReg_)('k','\x02','\x05','\b');
  (*g_phyFuns->i2c_writeReg_)('k','\x02','\x06',0xf8);
  (*g_phyFuns->i2c_writeReg_)('k','\x02','\a',']');
  (*g_phyFuns->i2c_writeReg_)('k','\x02','\n','t');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void i2c_bias_init(void)

{
  (*g_phyFuns->i2c_writeReg_)('j','\x02','\x02','h');
  (*g_phyFuns->i2c_writeReg_)('j','\x02','\0',dreg_1p2_set);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rfpll_1p2_opt(void)

{
  uint8 uVar1;
  uint8 uVar2;
  int iVar3;
  int iVar4;
  uint8 *puVar5;
  char cVar6;
  uint8 reg [4];
  
  puVar5 = reg;
  cVar6 = '\0';
  reg[0] = '0';
  reg[1] = 0x80;
  reg[2] = '\b';
  reg[3] = 'q';
  memw();
  iVar3 = 0;
  do {
    iVar4 = iVar3 + 1;
    uVar2 = (*g_phyFuns->i2c_readReg_)('b','\x01',(uint8)iVar3);
    uVar1 = *puVar5;
    puVar5 = puVar5 + 1;
    if (uVar1 != uVar2) {
      cVar6 = cVar6 + '\x01';
    }
    iVar3 = iVar4;
  } while (iVar4 != 4);
  if (cVar6 != '\0') {
    dreg_1p2_set = '*';
    memw();
    (*g_phyFuns->i2c_writeReg_)('j','\x02','\0','*');
  }
  return;
}



// WARNING: Unknown calling convention

void get_rf_freq_cap(uint16 freq,sint16 freq_offset,uint8 *x_reg,uint8 *cap_array)

{
  uint8 uVar1;
  byte bVar2;
  byte bVar3;
  
  (*g_phyFuns->rfpll_reset_)();
  (*g_phyFuns->rfpll_set_freq_)((uint)freq,chip7_phy_init_ctrl.crystal_select,freq_offset,x_reg);
  (*g_phyFuns->write_rfpll_sdm_)(x_reg);
  (*g_phyFuns->restart_cal_)();
  (*g_phyFuns->wait_rfpll_cal_end_)();
  chip_v7_rxmax_ext_ana('\0');
  uVar1 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\x05','\a','\0');
  *cap_array = uVar1;
  memw();
  bVar2 = (*g_phyFuns->i2c_readReg_)('b','\x01','\x02');
  bVar3 = (*g_phyFuns->i2c_readReg_Mask_)('b','\x01','\x06','\x03','\0');
  cap_array[1] = bVar2 & 0xf0 | bVar3 | 0x80;
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void correct_rfpll_offset(sint16 freq_offset,uint8 crystal_select)

{
  byte bVar1;
  short sVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  byte bVar7;
  int iStack_28;
  
  if (crystal_select == '\0') {
    sVar2 = (short)(freq_offset * 9 >> 2);
  }
  else {
    sVar2 = (short)(freq_offset * 0x1b >> 3);
  }
  iStack_28 = (int)sVar2;
  iVar4 = (int)rfpll_offset_delta;
  if (iStack_28 != iVar4) {
    bVar1 = 0x55;
    bVar7 = 0;
    if (phy_freq_wifi_only) {
      bVar1 = 0xe;
    }
    uVar5 = 1;
    do {
      uVar6 = uVar5;
      if ((phy_freq_wifi_only != false) && (uVar6 = 0xfd, bVar7 < 0xd)) {
        uVar6 = (uint)(byte)(bVar7 * '\x0f' + 0x25);
      }
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      _DAT_3ff4e0c4 = uVar3 & 0xffffff00 | uVar6;
      bVar7 = bVar7 + 1;
      memw();
      uVar6 = esp_dport_access_reg_read(&DAT_3ff4e0c0);
      _DAT_3ff4e148 = (uVar6 & 0xffffff) + (iStack_28 - iVar4) | uVar6 & 0xff000000;
      memw();
      _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x200;
      memw();
      _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffdff;
      uVar5 = uVar5 + 3 & 0xff;
      memw();
    } while (bVar1 != bVar7);
    memw();
    rfpll_offset_delta = sVar2;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void wr_rf_freq_mem(uint8 chan_freq,uint32 *mem_data)

{
  uint uVar1;
  uint uVar2;
  uint32 *puVar3;
  uint32 uVar4;
  
  uVar2 = (uint)chan_freq * 3;
  puVar3 = mem_data + 3;
  do {
    uVar4 = *mem_data;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = uVar1 & 0xffffff00 | uVar2 & 0xff;
    uVar2 = (uVar2 & 0xff) + 1;
    mem_data = mem_data + 1;
    memw();
    memw();
    _DAT_3ff4e148 = uVar4;
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x200;
    memw();
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffdff;
    memw();
  } while (puVar3 != mem_data);
  return;
}



// WARNING: Unknown calling convention

void write_freq_mem_all(uint8 *rf_cal_data)

{
  uint32 uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint8 *data;
  uint32 *puVar5;
  int iVar6;
  uint32 mem_data [3];
  uint uStack_30;
  
  if ((chip7_sleep_params.param_flag & 0x18) == 0x10) {
    uVar3 = 0xc;
    uVar2 = 0;
    uVar4 = 0x55;
    if (phy_freq_wifi_only) {
      uVar4 = 0xe;
    }
    do {
      if (phy_freq_wifi_only == false) {
        iVar6 = uVar2 * 0xc;
        uStack_30 = uVar2;
      }
      else {
        iVar6 = 0x3f0;
        uStack_30 = 0x54;
        if (uVar2 < 0xd) {
          iVar6 = uVar3 * 0xc;
          uStack_30 = uVar3;
        }
      }
      data = rf_cal_data + iVar6;
      puVar5 = mem_data;
      do {
        uVar1 = phy_byte_to_word(data);
        *puVar5 = uVar1;
        data = data + 4;
        puVar5 = puVar5 + 1;
      } while (rf_cal_data + iVar6 + 0xc != data);
      uVar2 = uVar2 + 1;
      wr_rf_freq_mem((uint8)uStack_30,mem_data);
      uVar3 = uVar3 + 5 & 0xff;
    } while ((uVar2 & 0xff) < uVar4);
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 8;
  }
  return;
}



// WARNING: Unknown calling convention

uint8 get_rfrx_dcap_bt(uint8 reg_addr)

{
  byte bVar1;
  s32 sVar2;
  uint8 data;
  
  bVar1 = (*g_phyFuns->i2c_readReg_)('d','\0',reg_addr);
  sVar2 = (*g_phyFuns->get_data_sat_)((bVar1 & 0xf) - 5,0xf,1);
  return bVar1 & 0xf0 | (byte)sVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void get_rf_freq_init(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  uint16 uVar5;
  uint16 freq;
  uint uVar6;
  uint8 uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint32 mem_data [3];
  uint8 pll_xreg_array [3];
  uint8 pll_cap_array [2];
  U8 set_freq_num;
  
  uVar6 = 0xe;
  if (!phy_freq_wifi_only) {
    uVar6 = 0x55;
  }
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\a','\a','\0');
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\x02','\a','\a','\0');
  bVar1 = (*g_phyFuns->i2c_readReg_)('h','\x03','\0');
  bVar2 = (*g_phyFuns->i2c_readReg_)('f','\x04','\x05');
  uVar8 = 0xc;
  uVar9 = 0;
  uVar5 = 0x96c;
  uVar7 = 'n';
  do {
    if (phy_freq_wifi_only == false) {
      freq = (short)uVar9 + 0x960;
      uVar10 = uVar9;
    }
    else {
      uVar10 = 0x54;
      freq = 0x9b4;
      if (uVar9 < 0xd) {
        uVar10 = uVar8;
        freq = uVar5;
      }
    }
    uVar9 = uVar9 + 1;
    uVar5 = uVar5 + 5;
    (*g_phyFuns->i2c_writeReg_)('b','\x01','\x01',uVar7);
    get_rf_freq_cap(freq,0,pll_xreg_array,pll_cap_array);
    uVar7 = pll_cap_array[0];
    bVar3 = get_rfrx_dcap_bt('\x04');
    bVar4 = get_rfrx_dcap_bt('\a');
    mem_data[2] = (uint)bVar3 | (uint)bVar1 << 0x18 | (uint)bVar2 << 0x10 | (uint)bVar4 << 8;
    mem_data[0] = (uint32)(ushort)pll_cap_array;
    mem_data[1] = (uint)pll_xreg_array[0] << 0x10 | (uint)pll_xreg_array[1] << 8 |
                  (uint)pll_xreg_array[2];
    wr_rf_freq_mem((uint8)uVar10,mem_data);
    uVar8 = uVar8 + 5 & 0xff;
  } while ((uVar9 & 0xff) < uVar6);
  chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x10;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void get_rf_freq_init(void)

{
  if ((chip7_sleep_params.param_flag & 0x10) == 0) {
    get_rf_freq_init();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bt_i2c_read_set(u8 i2c_mst,u8 i2c_block,u8 i2c_addr,u8 i2c_data_mask,bool i2c_rd_en,
                    bool i2c_comp_en)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e14c);
  _DAT_3ff4e14c = (i2c_mst & 0xf) << 0x10 | uVar1 & 0xfff0ffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e14c);
  _DAT_3ff4e14c = uVar1 & 0xffffff00 | (uint)i2c_block;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e14c);
  _DAT_3ff4e14c = uVar1 & 0xffff00ff | (uint)i2c_addr << 8;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e14c);
  _DAT_3ff4e14c = (i2c_rd_en & 1) << 0x14 | uVar1 & 0xffefffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e150);
  _DAT_3ff4e150 = (i2c_comp_en & 1) << 0x11 | uVar1 & 0xfffdffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e150);
  memw();
  _DAT_3ff4e150 = uVar1 & 0xffffff00 | (uint)i2c_data_mask;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void bt_i2c_read_mem(void)

{
  uint uVar1;
  undefined4 uVar2;
  uint uVar3;
  char cVar4;
  
  phy_printf("i=%d, ",0);
  cVar4 = '\x01';
  do {
    uVar3 = 0;
    if (cVar4 == '\x01') {
LAB_00050f30:
      uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      _DAT_3ff4e0c4 = uVar1 & 0xffffff00 | uVar3;
      memw();
      uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c0);
      phy_printf("0x%x, ",uVar2);
      if (cVar4 == '\x03') {
        phy_printf(&DAT_00058f88);
        return;
      }
    }
    else {
      if (cVar4 != '\x02') {
        uVar3 = 2;
        goto LAB_00050f30;
      }
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      _DAT_3ff4e0c4 = uVar3 & 0xffffff00 | 1;
      memw();
      uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c0);
      phy_printf("0x%x, ",uVar2);
    }
    cVar4 = cVar4 + '\x01';
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bt_i2c_write_set(U8 *i2c_mst,U8 *i2c_block,U8 *i2c_addr,U8 *i2c_addr_tx,U8 *i2c_data_tx,
                     U8 *i2c_addr_rx,U8 *i2c_data_rx,U8 i2c_num,U8 *i2c_rd_en)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  byte *pbVar6;
  byte *pbVar7;
  uint uVar8;
  uint *puVar9;
  
  uVar5 = (uint)i2c_num;
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = (uVar5 & 0x1f) << 10 | uVar2 & 0xffff83ff;
  memw();
  if (uVar5 == 0) {
    memw();
    _DAT_3ff4e164 = uVar5;
    return;
  }
  uVar2 = 0;
  _DAT_3ff4e164 = 0;
  do {
    if (*i2c_rd_en == '\x01') {
      _DAT_3ff4e164 = _DAT_3ff4e164 + (1 << 0x20 - (0x20 - (uVar2 & 0x1f)));
    }
    uVar2 = uVar2 + 1;
    i2c_rd_en = i2c_rd_en + 1;
  } while ((uVar2 & 0xff) < uVar5);
  memw();
  uVar2 = 0;
  do {
    uVar3 = (uVar2 & 0xff) >> 3;
    if (uVar3 == 0) {
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e100);
      _DAT_3ff4e100 =
           (0xf << 0x20 - (0x20 - (uVar2 << 2 & 0x1f)) ^ 0xffffffffU) & uVar3 |
           (*i2c_mst & 0xf) << 0x20 - (0x20 - (uVar2 << 2 & 0x1f));
      memw();
    }
    else if (uVar3 == 1) {
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e104);
      _DAT_3ff4e104 =
           (0xf << 0x20 - ((uVar2 & 7) * -4 + 0x20) ^ 0xffffffffU) & uVar3 |
           (*i2c_mst & 0xf) << 0x20 - ((uVar2 & 7) * -4 + 0x20);
      memw();
    }
    else {
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e108);
      _DAT_3ff4e108 =
           (0xf << 0x20 - ((uVar2 & 7) * -4 + 0x20) ^ 0xffffffffU) & uVar3 |
           (*i2c_mst & 0xf) << 0x20 - ((uVar2 & 7) * -4 + 0x20);
      memw();
    }
    uVar2 = uVar2 + 1;
    i2c_mst = i2c_mst + 1;
  } while ((uVar5 - 1 & 0xff) + 1 != uVar2);
  uVar3 = 0;
  uVar2 = 0;
  do {
    switch(uVar2 >> 1) {
    case 0:
      uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0d8);
      _DAT_3ff4e0d8 =
           (uint)CONCAT11(*i2c_addr,*i2c_block) << 0x20 - (0x20 - (uVar3 << 4 & 0x1f)) |
           (0xffff << 0x20 - (0x20 - (uVar3 << 4 & 0x1f)) ^ 0xffffffffU) & uVar2;
      memw();
      goto LAB_00051239;
    case 1:
      puVar9 = (uint *)0x3ff4e0dc;
      break;
    case 2:
      puVar9 = (uint *)0x3ff4e0e0;
      break;
    case 3:
      puVar9 = (uint *)0x3ff4e0e4;
      break;
    case 4:
      puVar9 = (uint *)0x3ff4e0e8;
      break;
    case 5:
      puVar9 = (uint *)&DAT_3ff4e0ec;
      break;
    case 6:
      puVar9 = (uint *)0x3ff4e0f0;
      break;
    case 7:
      puVar9 = (uint *)0x3ff4e0f4;
      break;
    case 8:
      puVar9 = (uint *)0x3ff4e10c;
      break;
    default:
      uVar4 = esp_dport_access_reg_read(&DAT_3ff4e110);
      _DAT_3ff4e110 =
           (uint)CONCAT11(*i2c_addr,*i2c_block) << 0x20 - ((uVar2 & 1) * -0x10 + 0x20) |
           (0xffff << 0x20 - ((uVar2 & 1) * -0x10 + 0x20) ^ 0xffffffffU) & uVar4;
      memw();
      goto LAB_00051239;
    }
    uVar4 = esp_dport_access_reg_read(puVar9);
    memw();
    *puVar9 = (uint)CONCAT11(*i2c_addr,*i2c_block) << 0x20 - ((uVar2 & 1) * -0x10 + 0x20) |
              (0xffff << 0x20 - ((uVar2 & 1) * -0x10 + 0x20) ^ 0xffffffffU) & uVar4;
LAB_00051239:
    uVar3 = uVar3 + 1;
    uVar2 = uVar3 & 0xff;
    i2c_addr = i2c_addr + 1;
    i2c_block = i2c_block + 1;
  } while (uVar2 < uVar5);
  uVar2 = 0;
  uVar3 = 0;
  pbVar6 = i2c_addr_rx;
  pbVar7 = i2c_addr_tx;
  do {
    uVar4 = esp_dport_access_reg_read(&DAT_3ff4e128);
    uVar8 = 1 << 0x20 - (0x20 - (uVar2 & 0x1f)) ^ 0xffffffff;
    _DAT_3ff4e128 = (*pbVar6 >> 4 & 1) << 0x20 - (0x20 - (uVar2 & 0x1f)) | uVar4 & uVar8;
    memw();
    uVar4 = esp_dport_access_reg_read(&DAT_3ff4e12c);
    _DAT_3ff4e12c = (*pbVar7 >> 4 & 1) << 0x20 - (0x20 - (uVar2 & 0x1f)) | uVar8 & uVar4;
    memw();
    if (uVar3 >> 3 == 0) {
      uVar8 = uVar2 << 2;
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0d0);
      uVar4 = 0xf << 0x20 - (0x20 - (uVar8 & 0x1f)) ^ 0xffffffff;
      _DAT_3ff4e0d0 = (*pbVar6 & 0xf) << 0x20 - (0x20 - (uVar8 & 0x1f)) | uVar3 & uVar4;
      memw();
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e11c);
      _DAT_3ff4e11c = (*pbVar7 & 0xf) << 0x20 - (0x20 - (uVar8 & 0x1f)) | uVar4 & uVar3;
      memw();
    }
    else if (uVar3 >> 3 == 1) {
      uVar4 = esp_dport_access_reg_read(&DAT_3ff4e0d4);
      uVar3 = uVar3 & 7;
      uVar8 = 0xf << 0x20 - (uVar3 * -4 + 0x20) ^ 0xffffffff;
      _DAT_3ff4e0d4 = (*pbVar6 & 0xf) << 0x20 - (uVar3 * -4 + 0x20) | uVar4 & uVar8;
      memw();
      uVar4 = esp_dport_access_reg_read(&DAT_3ff4e120);
      _DAT_3ff4e120 = (*pbVar7 & 0xf) << 0x20 - (uVar3 * -4 + 0x20) | uVar8 & uVar4;
      memw();
    }
    else {
      uVar3 = uVar3 & 7;
      uVar4 = esp_dport_access_reg_read(&DAT_3ff4e124);
      _DAT_3ff4e124 =
           (0xf << 0x20 - (uVar3 * -4 + 0x20) ^ 0xffffffffU) & uVar4 |
           (*pbVar6 & 0xf) << 0x20 - (uVar3 * -4 + 0x20);
      memw();
      uVar4 = esp_dport_access_reg_read(&DAT_3ff4e124);
      uVar3 = uVar3 * 4 + 0x10;
      _DAT_3ff4e124 =
           (0xf << 0x20 - (0x20 - (uVar3 & 0x1f)) ^ 0xffffffffU) & uVar4 |
           (*pbVar7 & 0xf) << 0x20 - (0x20 - (uVar3 & 0x1f));
      memw();
    }
    uVar2 = uVar2 + 1;
    uVar3 = uVar2 & 0xff;
    pbVar6 = pbVar6 + 1;
    pbVar7 = pbVar7 + 1;
  } while (uVar3 < uVar5);
  uVar2 = 0;
  do {
    bVar1 = *i2c_addr_rx >> 2;
    if (bVar1 == 1) {
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0cc);
      _DAT_3ff4e0cc =
           (0xff << 0x20 - ((*i2c_addr_rx & 3) * -8 + 0x20) ^ 0xffffffffU) & uVar3 |
           (uint)*i2c_data_rx << 0x20 - ((*i2c_addr_rx & 3) * -8 + 0x20);
      memw();
    }
    else if (bVar1 == 0) {
      uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c8);
      _DAT_3ff4e0c8 =
           (0xff << 0x20 - ((*i2c_addr_rx & 3) * -8 + 0x20) ^ 0xffffffffU) & uVar3 |
           (uint)*i2c_data_rx << 0x20 - ((*i2c_addr_rx & 3) * -8 + 0x20);
      memw();
    }
    else {
      if (bVar1 == 2) {
        puVar9 = (uint *)&DAT_3ff4e114;
      }
      else {
        if (bVar1 != 3) goto code_r0x000514cb;
        puVar9 = (uint *)&DAT_3ff4e118;
      }
      uVar3 = esp_dport_access_reg_read(puVar9);
      memw();
      *puVar9 = (0xff << 0x20 - ((*i2c_addr_rx & 3) * -8 + 0x20) ^ 0xffffffffU) & uVar3 |
                (uint)*i2c_data_rx << 0x20 - ((*i2c_addr_rx & 3) * -8 + 0x20);
    }
code_r0x000514cb:
    bVar1 = *i2c_addr_tx >> 2;
    if (bVar1 == 1) {
      puVar9 = (uint *)&DAT_3ff4e0cc;
LAB_000514fc:
      uVar3 = esp_dport_access_reg_read(puVar9);
      memw();
      *puVar9 = (0xff << 0x20 - ((*i2c_addr_tx & 3) * -8 + 0x20) ^ 0xffffffffU) & uVar3 |
                (uint)*i2c_data_tx << 0x20 - ((*i2c_addr_tx & 3) * -8 + 0x20);
    }
    else {
      if (bVar1 == 0) {
        puVar9 = (uint *)&DAT_3ff4e0c8;
        goto LAB_000514fc;
      }
      if (bVar1 == 2) {
        puVar9 = (uint *)&DAT_3ff4e114;
        goto LAB_000514fc;
      }
      if (bVar1 == 3) {
        puVar9 = (uint *)&DAT_3ff4e118;
        goto LAB_000514fc;
      }
    }
    uVar2 = uVar2 + 1 & 0xff;
    i2c_addr_rx = i2c_addr_rx + 1;
    i2c_addr_tx = i2c_addr_tx + 1;
    i2c_data_tx = i2c_data_tx + 1;
    i2c_data_rx = i2c_data_rx + 1;
    if (uVar5 <= uVar2) {
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void bt_i2c_set_wifi_data(U8 *data,U8 i2c_num)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  
  if (i2c_num != '\0') {
    uVar1 = 0;
    do {
      uVar2 = (uVar1 & 0xff) >> 2;
      if (uVar2 == 1) {
        uVar2 = esp_dport_access_reg_read(&DAT_3ff4e134);
        _DAT_3ff4e134 =
             (0xff << 0x20 - ((uVar1 & 3) * -8 + 0x20) ^ 0xffffffffU) & uVar2 |
             (uint)*data << 0x20 - ((uVar1 & 3) * -8 + 0x20);
        memw();
      }
      else if (uVar2 == 0) {
        uVar2 = esp_dport_access_reg_read(&DAT_3ff4e130);
        _DAT_3ff4e130 =
             (0xff << 0x20 - (0x20 - (uVar1 << 3 & 0x1f)) ^ 0xffffffffU) & uVar2 |
             (uint)*data << 0x20 - (0x20 - (uVar1 << 3 & 0x1f));
        memw();
      }
      else {
        if (uVar2 == 2) {
          puVar3 = (uint *)0x3ff4e138;
        }
        else if (uVar2 == 3) {
          puVar3 = (uint *)0x3ff4e13c;
        }
        else {
          puVar3 = (uint *)&DAT_3ff4e140;
        }
        uVar2 = esp_dport_access_reg_read(puVar3);
        memw();
        *puVar3 = (0xff << 0x20 - ((uVar1 & 3) * -8 + 0x20) ^ 0xffffffffU) & uVar2 |
                  (uint)*data << 0x20 - ((uVar1 & 3) * -8 + 0x20);
      }
      uVar1 = uVar1 + 1;
      data = data + 1;
    } while (uVar1 != (i2c_num - 1 & 0xff) + 1);
  }
  return;
}



// WARNING: Unknown calling convention

void phy_wifi_pll_track(bool enable)

{
  phy_wifi_pll_track_en = enable;
  memw();
  return;
}



// WARNING: Unknown calling convention

void phy_bt_pll_track(bool enable)

{
  memw();
  phy_bt_pll_track_en = enable;
  phy_bt_ifs_set();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void tsens_read_init(void)

{
  uint uVar1;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = uVar1 & 0xff00ffff | 0x20000;
  memw();
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c | 0x2000000;
  memw();
  _DAT_3ff4884c = esp_dport_access_reg_read(&DAT_3ff4884c);
  _DAT_3ff4884c = _DAT_3ff4884c & 0xfeffffff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4884c);
  memw();
  _DAT_3ff4884c = uVar1 | 0x1000000;
  return;
}



// WARNING: Unknown calling convention

void phy_bt_power_track(bool enable)

{
  memw();
  phy_bt_power_track_en = enable;
  tsens_read_init();
  return;
}



// WARNING: Unknown calling convention

void bt_get_i2c_data(U8 *i2c_mst,U8 *i2c_block,U8 *i2c_addr,U8 *i2c_addr_tx,U8 *i2c_data_tx,
                    U8 *i2c_addr_rx,U8 *i2c_data_rx,uint8 i2c_num,uint8 *i2c_rd_en)

{
  byte bVar1;
  uint uVar2;
  U8 *pUVar3;
  uint uVar4;
  U8 *pUVar5;
  byte *pbVar6;
  U8 *pUVar7;
  U8 *pUVar8;
  U8 *pUVar9;
  byte *pbVar10;
  
  uVar2 = (uint)i2c_num;
  (*g_phyFuns->i2c_writeReg_Mask_)('b','\x01','\0','\a','\a','\x01');
  bVar1 = (*g_phyFuns->i2c_readReg_)('b','\x01','\0');
  uVar4 = 0;
  if (uVar2 == 0) {
    return;
  }
  bVar1 = bVar1 & 0x9f | 0x20;
  do {
    i2c_rd_en[uVar4] = '\0';
    memw();
    switch(uVar4) {
    case 0:
      i2c_mst[uVar4] = '\0';
      i2c_block[uVar4] = 'c';
      memw();
      i2c_addr[uVar4] = '\0';
      i2c_addr_tx[uVar4] = '\x0f';
      i2c_data_tx[uVar4] = '\0';
      i2c_data_rx[uVar4] = '\0';
      i2c_addr_rx[uVar4] = '\x0f';
      i2c_rd_en[uVar4] = '\x01';
      memw();
      if (uVar2 < 2) {
        return;
      }
      i2c_rd_en[1] = '\0';
      memw();
      uVar4 = 1;
    case 1:
      i2c_mst[uVar4] = '\x01';
      i2c_block[uVar4] = 'b';
      memw();
      i2c_addr[uVar4] = '\x01';
      i2c_addr_tx[uVar4] = '\x10';
      i2c_data_tx[uVar4] = '\0';
      i2c_addr_rx[uVar4] = '\x10';
      i2c_data_rx[uVar4] = '\0';
      memw();
      if (uVar2 < 3) {
        return;
      }
      i2c_rd_en[2] = '\0';
      memw();
      uVar4 = 2;
    case 2:
      i2c_mst[uVar4] = '\x01';
      i2c_block[uVar4] = 'b';
      i2c_addr[uVar4] = '\x02';
      i2c_addr_tx[uVar4] = '\x11';
      memw();
      i2c_data_tx[uVar4] = '\0';
      i2c_addr_rx[uVar4] = '\x11';
      i2c_data_rx[uVar4] = '\0';
      memw();
      if (uVar2 < 4) {
        return;
      }
      i2c_rd_en[3] = '\0';
      memw();
      uVar4 = 3;
    case 3:
      i2c_mst[uVar4] = '\0';
      i2c_block[uVar4] = 'c';
      memw();
      i2c_addr[uVar4] = '\0';
      i2c_addr_tx[uVar4] = '\0';
      memw();
      i2c_data_tx[uVar4] = '\a';
      i2c_addr_rx[uVar4] = '\0';
      i2c_data_rx[uVar4] = '\a';
      memw();
      if (uVar2 < 5) {
        return;
      }
      i2c_rd_en[4] = '\0';
      memw();
      uVar4 = 4;
    case 4:
      i2c_mst[uVar4] = '\0';
      i2c_block[uVar4] = 'c';
      i2c_addr[uVar4] = '\x03';
      i2c_addr_tx[uVar4] = '\x16';
      memw();
      i2c_data_tx[uVar4] = '\0';
      i2c_addr_rx[uVar4] = '\x16';
      i2c_data_rx[uVar4] = '\0';
      memw();
      if (uVar2 < 6) {
        return;
      }
      i2c_rd_en[5] = '\0';
      memw();
      uVar4 = 5;
    case 5:
      i2c_mst[uVar4] = '\0';
      i2c_block[uVar4] = 'c';
      i2c_addr[uVar4] = '\x05';
      i2c_addr_tx[uVar4] = '\x14';
      memw();
      i2c_data_tx[uVar4] = '\0';
      i2c_addr_rx[uVar4] = '\x14';
      i2c_data_rx[uVar4] = '\0';
      memw();
      if (uVar2 < 7) {
        return;
      }
      i2c_rd_en[6] = '\0';
      memw();
      uVar4 = 6;
    case 6:
      i2c_mst[uVar4] = '\0';
      i2c_block[uVar4] = 'c';
      i2c_addr[uVar4] = '\x04';
      i2c_addr_tx[uVar4] = '\x15';
      memw();
      i2c_data_tx[uVar4] = '\0';
      i2c_addr_rx[uVar4] = '\x15';
      i2c_data_rx[uVar4] = '\0';
      memw();
      if (uVar2 < 8) {
        return;
      }
      i2c_rd_en[7] = '\0';
      memw();
      uVar4 = 7;
    case 7:
      i2c_mst[uVar4] = '\0';
      pUVar7 = i2c_addr_tx + uVar4;
      i2c_block[uVar4] = 'c';
      pUVar5 = i2c_data_tx + uVar4;
      i2c_addr[uVar4] = '\0';
      pUVar3 = i2c_addr_rx + uVar4;
      pUVar8 = i2c_data_rx + uVar4;
      uVar4 = 8;
      *pUVar7 = '\x01';
      *pUVar5 = '\x17';
      *pUVar3 = '\x01';
      *pUVar8 = '\x17';
      memw();
      if (uVar2 < 9) {
        return;
      }
      i2c_rd_en[8] = '\0';
      memw();
    case 8:
      pUVar5 = i2c_addr_tx + uVar4;
      i2c_mst[uVar4] = '\x01';
      i2c_block[uVar4] = 'b';
      memw();
      pUVar3 = i2c_addr_rx + uVar4;
      pbVar6 = i2c_data_tx + uVar4;
      pbVar10 = i2c_data_rx + uVar4;
      i2c_addr[uVar4] = '\0';
      uVar4 = 9;
      *pUVar5 = '\x02';
      memw();
      *pbVar6 = bVar1;
      *pUVar3 = '\x02';
      *pbVar10 = bVar1;
      memw();
      if (uVar2 < 10) {
        return;
      }
      i2c_rd_en[9] = '\0';
      memw();
    case 9:
      i2c_mst[uVar4] = '\0';
      i2c_block[uVar4] = 'd';
      memw();
      i2c_addr[uVar4] = '\x04';
      i2c_addr_tx[uVar4] = '\x18';
      i2c_data_tx[uVar4] = '\0';
      i2c_addr_rx[uVar4] = '\x18';
      i2c_data_rx[uVar4] = '\0';
      memw();
      if (uVar2 < 0xb) {
        return;
      }
      i2c_rd_en[10] = '\0';
      memw();
      uVar4 = 10;
    case 10:
      pUVar8 = i2c_addr + uVar4;
      pUVar7 = i2c_addr_tx + uVar4;
      pUVar5 = i2c_data_tx + uVar4;
      i2c_mst[uVar4] = '\0';
      i2c_block[uVar4] = 'd';
      memw();
      pUVar3 = i2c_addr_rx + uVar4;
      pUVar9 = i2c_data_rx + uVar4;
      uVar4 = 0xb;
      *pUVar8 = '\a';
      *pUVar7 = '\x19';
      *pUVar5 = '\0';
      *pUVar3 = '\x19';
      *pUVar9 = '\0';
      memw();
      if (uVar2 < 0xc) {
        return;
      }
      i2c_rd_en[0xb] = '\0';
      memw();
    }
    i2c_mst[uVar4] = '\0';
    pUVar3 = i2c_block + uVar4;
    uVar4 = uVar4 + 1 & 0xff;
    *pUVar3 = '\0';
    memw();
  } while (uVar4 < uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void write_wifi_chan_data(uint8 chan_freq)

{
  uint uVar1;
  uint uVar2;
  undefined4 uVar3;
  byte bVar4;
  uint uVar5;
  u32 *puVar6;
  u32 mem_data [3];
  sint16 rfrx_cap [2];
  
  puVar6 = mem_data;
  uVar1 = (uint)chan_freq * 3 & 0xff;
  uVar5 = uVar1 + 3;
  do {
    uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = uVar2 & 0xffffff00 | uVar1;
    memw();
    uVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c0);
    uVar1 = uVar1 + 1 & 0xff;
    *puVar6 = uVar3;
    puVar6 = puVar6 + 1;
  } while (uVar1 != (uVar5 & 0xff));
  get_lna_vga_dcap_val((ushort)mem_data[0] & 0xff,rfrx_cap);
  uVar1 = (uint)freq_i2c_addr[0];
  if (0xf < uVar1) {
    bt_wifi_chan_data[0] = (uint8)(mem_data[0] >> ((uVar1 & 3) << 3));
    if (0x13 < uVar1) {
      bt_wifi_chan_data[0] = (uint8)(mem_data[1] >> (uVar1 << 3 & 0x1f));
      if (0x17 < uVar1) {
        bt_wifi_chan_data[0] = (uint8)(mem_data[2] >> (uVar1 << 3 & 0x1f));
      }
    }
    memw();
  }
  bVar4 = bt_wifi_chan_data[9] & 0xf0;
  bt_wifi_chan_data[9] = bVar4 | (byte)rfrx_cap[0];
  bt_wifi_chan_data[10] = bVar4 | (byte)rfrx_cap[0] & 0xf0 | (byte)rfrx_cap[1];
  memw();
  bt_i2c_set_wifi_data(bt_wifi_chan_data,'\v');
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_chan_freq_hw_init(S8 tx_freq_offset,S8 rx_freq_offset)

{
  uint uVar1;
  U8 i2c_rd_en [11];
  U8 i2c_data_rx [11];
  U8 i2c_data_tx [11];
  U8 i2c_addr_rx [11];
  U8 i2c_addr [11];
  U8 i2c_block [11];
  U8 i2c_mst [11];
  
  if ((chip7_sleep_params.param_flag & 0x10) == 0) {
    get_rf_freq_init();
  }
  if ((chip7_sleep_params.param_flag & 0x2000) == 0) {
    bt_get_i2c_data(i2c_mst,i2c_block,i2c_addr,freq_i2c_addr,i2c_data_tx,i2c_addr_rx,i2c_data_rx,
                    '\v',i2c_rd_en);
    bt_i2c_write_set(i2c_mst,i2c_block,i2c_addr,freq_i2c_addr,i2c_data_tx,i2c_addr_rx,i2c_data_rx,
                     '\v',i2c_rd_en);
    bt_wifi_chan_data[0] = i2c_data_tx[0];
    memw();
    write_wifi_chan_data('\f');
    uVar1 = esp_dport_access_reg_read(&DAT_60033d38);
    _DAT_60033d38 = uVar1 & 0xffff | 0xc800000;
    chip7_sleep_params.param_flag = chip7_sleep_params.param_flag | 0x2000;
    memw();
  }
  i2cmst_reg_init();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rf_init(void)

{
  U16 dco [4];
  
  i2c_bias_init();
  reg_init_begin(false);
  rfpll_1p2_opt();
  phy_i2c_init();
  if ((re_entry == '\0') || (phy_init_flag == false)) {
    (*g_phyFuns->pbus_debugmode_)();
    dco[0] = 0x100;
    dco[1] = 0x100;
    dco[2] = 0x100;
    dco[3] = 0x100;
    memw();
    (*g_phyFuns->pbus_set_dco_)(dco);
    (*g_phyFuns->pbus_xpd_tx_off_)();
    (*g_phyFuns->pbus_xpd_rx_off_)();
    (*g_phyFuns->pbus_workmode_)();
  }
  set_chan_freq_hw_init('\x02','\x04');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void check_rfpll_write_i2c(void)

{
  uint8 uVar1;
  uint8 uVar2;
  uint8 uVar3;
  uint8 *puVar4;
  uint8 *puVar5;
  U8 *pUVar6;
  U8 i2c_rd_en [11];
  U8 i2c_data_rx [11];
  U8 i2c_data_tx [11];
  U8 i2c_addr_rx [11];
  U8 i2c_addr [11];
  U8 i2c_block [11];
  U8 i2c_mst [11];
  
  puVar5 = i2c_addr;
  bt_get_i2c_data(i2c_mst,i2c_block,i2c_addr,freq_i2c_addr,i2c_data_tx,i2c_addr_rx,i2c_data_rx,'\v',
                  i2c_rd_en);
  puVar4 = i2c_block;
  pUVar6 = i2c_mst;
  do {
    uVar3 = *pUVar6;
    pUVar6 = pUVar6 + 1;
    uVar1 = *puVar5;
    puVar5 = puVar5 + 1;
    uVar2 = *puVar4;
    puVar4 = puVar4 + 1;
    uVar3 = (*g_phyFuns->i2c_readReg_)(uVar2,uVar3,uVar1);
    phy_printf("0x%x, ",uVar3);
  } while (i2c_mst != puVar4);
  phy_printf(&DAT_00058f88);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void phy_hw_set_freq_enable(bool enable)

{
  int iVar1;
  uint uVar2;
  
  if (enable) {
    if (phy_hw_set_freq_enable::flag == 1) {
      if (!force_hw_set_freq_flag) {
        _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
        _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfdffffff;
        memw();
      }
      uVar2 = esp_dport_access_reg_read(&DAT_3ff5c07c);
      _DAT_3ff5c07c = uVar2 & 0xff00ffff | 0x9c0000;
      memw();
    }
    phy_hw_set_freq_enable::flag = phy_hw_set_freq_enable::flag + -1;
    return;
  }
  if (phy_hw_set_freq_enable::flag == 0) {
    do {
      iVar1 = esp_dport_access_reg_read(&DAT_3ff4e168);
      if (-1 < iVar1) break;
      uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    } while ((uVar2 & 0x100) == 0);
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x2000000;
    memw();
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
    memw();
    ets_delay_us(2);
  }
  phy_hw_set_freq_enable::flag = phy_hw_set_freq_enable::flag + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void set_chan_freq_sw_start(U8 chan_freq,sint16 freq_offset,uint8 crystal_select)

{
  sint8 sVar1;
  uint uVar2;
  int iVar3;
  char cVar4;
  char cVar5;
  u8 pll_cap_ext;
  uint8 tx_freq_offset;
  uint8 rx_freq_offset;
  undefined4 uStack_28;
  
  phy_sw_set_chan_en = true;
  memw();
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _tx_freq_offset = uVar2 >> 0x10 & 0xf;
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _rx_freq_offset = uVar2 >> 0x14 & 0xf;
  phy_dis_hw_set_freq();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
  memw();
  uStack_28 = 0xfffffeff;
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = uVar2 & 0xe7ffffff | 0x10000000;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfff0ffff;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xff0fffff;
  memw();
  correct_rfpll_offset(freq_offset,crystal_select);
  write_wifi_chan_data(chan_freq);
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = (chan_freq & 0x7f) << 1 | uVar2 & 0xffffff00;
  memw();
  cVar4 = '\f';
  cVar5 = '\0';
  do {
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x100;
    memw();
    ets_delay_us(2);
    do {
      iVar3 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      if (iVar3 < 0) break;
      uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    } while ((uVar2 & 0x100) != 0);
    _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
    memw();
    ets_delay_us(0x28);
    sVar1 = pll_correct_dcap(chan_freq,&pll_cap_ext,true);
    if ((((sVar1 == '\0') || ((sVar1 == '\x01' && (cVar5 == -1)))) ||
        ((sVar1 == -1 && (cVar5 == '\x01')))) || (cVar4 = cVar4 + -1, cVar5 = sVar1, cVar4 == '\0'))
    {
      phy_sw_set_chan_en = false;
      memw();
      uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      _DAT_3ff4e0c4 = uVar2 & 0xfff0ffff | _tx_freq_offset << 0x10;
      memw();
      uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      _DAT_3ff4e0c4 = uVar2 & 0xff0fffff | _rx_freq_offset << 0x14;
      memw();
      _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
      _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xe7ffffff;
      memw();
      if (phy_force_wifi_chan_en == false) {
        phy_en_hw_set_freq();
      }
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint16 set_channel_rfpll_freq(int8 channel,uint8 crystal_select,sint16 freq_offset)

{
  uint16 uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  U8 chan_freq;
  int iVar5;
  
  if ((chip7_sleep_params.param_flag & 0x10) == 0) {
    uVar1 = (*g_phyFuns->set_channel_freq_)(channel,crystal_select,freq_offset);
    return uVar1;
  }
  iVar5 = (int)channel;
  if ((iVar5 == 0) || (0xe < iVar5)) {
    phy_printf("set_chan error! %d\n");
    chan_freq = '\f';
    uVar4 = 0xc;
    uVar1 = 0x96c;
  }
  else if (iVar5 == 0xe) {
    chan_freq = 'T';
    uVar1 = 0x9b4;
    uVar4 = 0x54;
  }
  else {
    uVar2 = (iVar5 + -1) * 5;
    uVar3 = (uVar2 & 0xffff) + 0xc;
    uVar4 = uVar3 & 0xffff;
    uVar1 = (short)uVar2 + 0x96c;
    chan_freq = (U8)uVar3;
  }
  uVar2 = esp_dport_access_reg_read(0x3ff5d008);
  if ((uVar2 & 0x20000000) == 0) {
    set_chan_freq_sw_start(chan_freq,freq_offset,crystal_select);
    return uVar1;
  }
  do {
    iVar5 = esp_dport_access_reg_read(&DAT_3ff4e168);
  } while (iVar5 < 0);
  write_wifi_chan_data(chan_freq);
  uVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  memw();
  _DAT_3ff4e0c4 = (uVar4 & 0x7f) << 1 | uVar2 & 0xffffff00;
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void chip_v7_set_chan_nomac(int8 channel,int8 sub_chan_cfg)

{
  S16 freq_offset;
  uint16 uVar1;
  undefined4 uVar2;
  u32 t0;
  int8 iVar3;
  
  freq_offset = phy_freq_offset;
  memw();
  memw();
  phy_dis_pwdet_one = true;
  memw();
  chip7_sleep_params.phy_channel_num = channel;
  disable_wifi_agc();
  uVar2 = phy_enter_critical();
  uVar1 = set_channel_rfpll_freq(channel,chip7_phy_init_ctrl.crystal_select,freq_offset);
  if (sub_chan_cfg < '\x04') {
    iVar3 = chip7_sleep_params.phy_sub_chan_cfg;
    if (chip7_sleep_params.phy_sub_chan_cfg != sub_chan_cfg) {
      bb_bss_cbw40(sub_chan_cfg);
      memw();
      chip7_sleep_params.phy_sub_chan_cfg = sub_chan_cfg;
      iVar3 = sub_chan_cfg;
    }
  }
  else {
    bb_bss_cbw40(chip7_sleep_params.phy_sub_chan_cfg);
    iVar3 = sub_chan_cfg;
  }
  (*g_phyFuns->spur_coef_cfg_)(channel,uVar1,iVar3);
  chip_v7_set_chan_misc(channel);
  phy_exit_critical(uVar2);
  if (chan14_mic_en != false) {
    if (channel == '\x0e') {
      chan14_mic_cfg('\x01');
    }
    else {
      chan14_mic_cfg('\0');
    }
  }
  enable_wifi_agc();
  return;
}



// WARNING: Unknown calling convention

void chip_v7_set_chan(int8 channel,int8 sub_chan_cfg)

{
  chip_sleep_prot_en();
  chip_v7_set_chan_nomac(channel,sub_chan_cfg);
  chip_sleep_prot_dis();
  return;
}



// WARNING: Unknown calling convention

void chip_v7_set_chan_offset(sint16 freq_offset)

{
  undefined4 uVar1;
  CriticalType crit_level;
  
  uVar1 = phy_enter_critical();
  memw();
  phy_freq_offset = freq_offset;
  if (chip7_phy_init_ctrl.force_freq_offset_enbale != '\0') {
    phy_freq_offset = chip7_phy_init_ctrl.force_freq_offset_num * 8 + freq_offset;
    memw();
  }
  phy_freq_correct_opt();
  set_channel_rfpll_freq
            (chip7_sleep_params.phy_channel_num,chip7_phy_init_ctrl.crystal_select,phy_freq_offset);
  bb_bss_cbw40(chip7_sleep_params.phy_sub_chan_cfg);
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Unknown calling convention

void chip_v7_set_chan_ana(int8 channel)

{
  set_channel_rfpll_freq(channel,chip7_phy_init_ctrl.crystal_select,0);
  chip7_sleep_params.phy_channel_num = channel;
  memw();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void freq_write_wifi_chan(uint8 chan_freq)

{
  uint uVar1;
  int iVar2;
  uint32_t val;
  
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = uVar1 & 0xe7ffffff | 0x10000000;
  memw();
  write_wifi_chan_data(chan_freq);
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = (chan_freq & 0x7f) << 1 | uVar1 & 0xffffff00;
  memw();
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 | 0x100;
  memw();
  ets_delay_us(2);
  do {
    iVar2 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
    if (iVar2 < 0) break;
    uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  } while ((uVar1 & 0x100) != 0);
  _DAT_3ff4e0c4 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  _DAT_3ff4e0c4 = _DAT_3ff4e0c4 & 0xfffffeff;
  memw();
  uVar1 = esp_dport_access_reg_read(&DAT_3ff4e0c4);
  memw();
  _DAT_3ff4e0c4 = uVar1 & 0xe7ffffff;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void phy_unforce_chan(void)

{
  CriticalType crit_level;
  undefined4 uVar1;
  uint8 chan_freq;
  
  uVar1 = phy_enter_critical();
  chan_freq = 'T';
  if ((byte)chip7_sleep_params.phy_channel_num < 0xe) {
    chan_freq = (chip7_sleep_params.phy_channel_num + -1) * '\x05' + '\f';
  }
  freq_write_wifi_chan(chan_freq);
  phy_en_hw_set_freq();
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Unknown calling convention

void phy_force_chan(uint8 chan_freq)

{
  undefined4 uVar1;
  CriticalType crit_level;
  
  uVar1 = phy_enter_critical();
  phy_dis_hw_set_freq();
  freq_write_wifi_chan(chan_freq);
  phy_exit_critical(uVar1);
  return;
}



// WARNING: Unknown calling convention

void phy_set_wifi_mode_only(bool wifi_only)

{
  phy_freq_wifi_only = wifi_only;
  memw();
  return;
}


